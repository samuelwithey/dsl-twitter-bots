# Generated from dsl.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3r")
        buf.write("\u010f\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\3\2\3\2\3\2\6\2P\n\2\r\2\16\2Q\3\3\3\3\3\4\3\4\3\4\3")
        buf.write("\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4`\n\4\3\5\3\5\3\5\3\5\7")
        buf.write("\5f\n\5\f\5\16\5i\13\5\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\5\7{\n\7\3\b\3\b\3\b")
        buf.write("\3\b\3\b\3\b\7\b\u0083\n\b\f\b\16\b\u0086\13\b\3\t\3\t")
        buf.write("\3\t\3\t\3\n\3\n\3\n\3\n\5\n\u0090\n\n\3\n\3\n\7\n\u0094")
        buf.write("\n\n\f\n\16\n\u0097\13\n\3\13\3\13\3\13\3\13\3\13\3\13")
        buf.write("\3\13\3\13\3\f\3\f\3\f\3\r\3\r\3\r\3\r\3\16\3\16\3\16")
        buf.write("\3\17\3\17\3\17\3\17\3\20\3\20\3\20\3\21\3\21\3\21\3\21")
        buf.write("\5\21\u00b6\n\21\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3")
        buf.write("\22\3\23\3\23\3\23\3\23\3\24\3\24\3\24\3\24\3\25\3\25")
        buf.write("\3\25\3\25\3\26\3\26\3\26\3\26\3\27\3\27\3\30\3\30\3\31")
        buf.write("\3\31\3\32\3\32\3\33\3\33\3\33\3\34\3\34\3\34\3\34\3\34")
        buf.write("\3\34\3\34\3\34\3\35\3\35\3\35\3\35\7\35\u00e7\n\35\f")
        buf.write("\35\16\35\u00ea\13\35\3\36\3\36\3\37\3\37\3\37\3\37\6")
        buf.write("\37\u00f2\n\37\r\37\16\37\u00f3\3 \3 \3 \3 \3 \3 \3 \3")
        buf.write(" \3!\3!\3!\3!\3\"\3\"\3#\5#\u0105\n#\3#\3#\3$\3$\3%\3")
        buf.write("%\3&\3&\3&\2\2\'\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36")
        buf.write(" \"$&(*,.\60\62\64\668:<>@BDFHJ\2\t\4\2,\64\66A\4\2,\64")
        buf.write("\66T\3\2,M\3\2,p\3\2\3\4\3\2qr\3\2\b\t\2\u00fe\2O\3\2")
        buf.write("\2\2\4S\3\2\2\2\6_\3\2\2\2\ba\3\2\2\2\nj\3\2\2\2\fz\3")
        buf.write("\2\2\2\16|\3\2\2\2\20\u0087\3\2\2\2\22\u008b\3\2\2\2\24")
        buf.write("\u0098\3\2\2\2\26\u00a0\3\2\2\2\30\u00a3\3\2\2\2\32\u00a7")
        buf.write("\3\2\2\2\34\u00aa\3\2\2\2\36\u00ae\3\2\2\2 \u00b1\3\2")
        buf.write("\2\2\"\u00b7\3\2\2\2$\u00bf\3\2\2\2&\u00c3\3\2\2\2(\u00c7")
        buf.write("\3\2\2\2*\u00cb\3\2\2\2,\u00cf\3\2\2\2.\u00d1\3\2\2\2")
        buf.write("\60\u00d3\3\2\2\2\62\u00d5\3\2\2\2\64\u00d7\3\2\2\2\66")
        buf.write("\u00da\3\2\2\28\u00e2\3\2\2\2:\u00eb\3\2\2\2<\u00ed\3")
        buf.write("\2\2\2>\u00f5\3\2\2\2@\u00fd\3\2\2\2B\u0101\3\2\2\2D\u0104")
        buf.write("\3\2\2\2F\u0108\3\2\2\2H\u010a\3\2\2\2J\u010c\3\2\2\2")
        buf.write("LM\5\4\3\2MN\7\35\2\2NP\3\2\2\2OL\3\2\2\2PQ\3\2\2\2QO")
        buf.write("\3\2\2\2QR\3\2\2\2R\3\3\2\2\2ST\5\6\4\2T\5\3\2\2\2U`\5")
        buf.write("\b\5\2V`\5\16\b\2W`\5\22\n\2X`\5\26\f\2Y`\5\32\16\2Z`")
        buf.write("\5\36\20\2[`\5\64\33\2\\`\58\35\2]`\5:\36\2^`\5<\37\2")
        buf.write("_U\3\2\2\2_V\3\2\2\2_W\3\2\2\2_X\3\2\2\2_Y\3\2\2\2_Z\3")
        buf.write("\2\2\2_[\3\2\2\2_\\\3\2\2\2_]\3\2\2\2_^\3\2\2\2`\7\3\2")
        buf.write("\2\2ab\7\13\2\2bg\5\n\6\2cd\7\34\2\2df\5\f\7\2ec\3\2\2")
        buf.write("\2fi\3\2\2\2ge\3\2\2\2gh\3\2\2\2h\t\3\2\2\2ig\3\2\2\2")
        buf.write("jk\7\r\2\2kl\7\36\2\2lm\5B\"\2m\13\3\2\2\2no\7\16\2\2")
        buf.write("op\7\36\2\2p{\5J&\2qr\7\7\2\2rs\7\36\2\2s{\5D#\2tu\7\17")
        buf.write("\2\2uv\7\36\2\2v{\5D#\2wx\7\23\2\2xy\7\36\2\2y{\5J&\2")
        buf.write("zn\3\2\2\2zq\3\2\2\2zt\3\2\2\2zw\3\2\2\2{\r\3\2\2\2|}")
        buf.write("\7\20\2\2}~\5\n\6\2~\177\7\34\2\2\177\u0084\5\20\t\2\u0080")
        buf.write("\u0081\7\34\2\2\u0081\u0083\5\f\7\2\u0082\u0080\3\2\2")
        buf.write("\2\u0083\u0086\3\2\2\2\u0084\u0082\3\2\2\2\u0084\u0085")
        buf.write("\3\2\2\2\u0085\17\3\2\2\2\u0086\u0084\3\2\2\2\u0087\u0088")
        buf.write("\7\21\2\2\u0088\u0089\7\36\2\2\u0089\u008a\5B\"\2\u008a")
        buf.write("\21\3\2\2\2\u008b\u008c\7\24\2\2\u008c\u008f\5\24\13\2")
        buf.write("\u008d\u008e\7\34\2\2\u008e\u0090\5\20\t\2\u008f\u008d")
        buf.write("\3\2\2\2\u008f\u0090\3\2\2\2\u0090\u0095\3\2\2\2\u0091")
        buf.write("\u0092\7\34\2\2\u0092\u0094\5\f\7\2\u0093\u0091\3\2\2")
        buf.write("\2\u0094\u0097\3\2\2\2\u0095\u0093\3\2\2\2\u0095\u0096")
        buf.write("\3\2\2\2\u0096\23\3\2\2\2\u0097\u0095\3\2\2\2\u0098\u0099")
        buf.write("\7\f\2\2\u0099\u009a\7\36\2\2\u009a\u009b\5D#\2\u009b")
        buf.write("\u009c\7\34\2\2\u009c\u009d\7\r\2\2\u009d\u009e\7\36\2")
        buf.write("\2\u009e\u009f\5B\"\2\u009f\25\3\2\2\2\u00a0\u00a1\7\25")
        buf.write("\2\2\u00a1\u00a2\5\30\r\2\u00a2\27\3\2\2\2\u00a3\u00a4")
        buf.write("\7\n\2\2\u00a4\u00a5\7\36\2\2\u00a5\u00a6\5D#\2\u00a6")
        buf.write("\31\3\2\2\2\u00a7\u00a8\7\27\2\2\u00a8\u00a9\5\34\17\2")
        buf.write("\u00a9\33\3\2\2\2\u00aa\u00ab\7\n\2\2\u00ab\u00ac\7\36")
        buf.write("\2\2\u00ac\u00ad\5D#\2\u00ad\35\3\2\2\2\u00ae\u00af\7")
        buf.write("\30\2\2\u00af\u00b0\5 \21\2\u00b0\37\3\2\2\2\u00b1\u00b2")
        buf.write("\5\"\22\2\u00b2\u00b5\7\34\2\2\u00b3\u00b6\5\b\5\2\u00b4")
        buf.write("\u00b6\5\16\b\2\u00b5\u00b3\3\2\2\2\u00b5\u00b4\3\2\2")
        buf.write("\2\u00b6!\3\2\2\2\u00b7\u00b8\5$\23\2\u00b8\u00b9\7\34")
        buf.write("\2\2\u00b9\u00ba\5&\24\2\u00ba\u00bb\7\34\2\2\u00bb\u00bc")
        buf.write("\5(\25\2\u00bc\u00bd\7\34\2\2\u00bd\u00be\5*\26\2\u00be")
        buf.write("#\3\2\2\2\u00bf\u00c0\7\"\2\2\u00c0\u00c1\7\36\2\2\u00c1")
        buf.write("\u00c2\5\62\32\2\u00c2%\3\2\2\2\u00c3\u00c4\7#\2\2\u00c4")
        buf.write("\u00c5\7\36\2\2\u00c5\u00c6\5\60\31\2\u00c6\'\3\2\2\2")
        buf.write("\u00c7\u00c8\7(\2\2\u00c8\u00c9\7\36\2\2\u00c9\u00ca\5")
        buf.write(".\30\2\u00ca)\3\2\2\2\u00cb\u00cc\7$\2\2\u00cc\u00cd\7")
        buf.write("\36\2\2\u00cd\u00ce\5,\27\2\u00ce+\3\2\2\2\u00cf\u00d0")
        buf.write("\t\2\2\2\u00d0-\3\2\2\2\u00d1\u00d2\t\3\2\2\u00d2/\3\2")
        buf.write("\2\2\u00d3\u00d4\t\4\2\2\u00d4\61\3\2\2\2\u00d5\u00d6")
        buf.write("\t\5\2\2\u00d6\63\3\2\2\2\u00d7\u00d8\7\26\2\2\u00d8\u00d9")
        buf.write("\5\66\34\2\u00d9\65\3\2\2\2\u00da\u00db\7*\2\2\u00db\u00dc")
        buf.write("\7\36\2\2\u00dc\u00dd\5D#\2\u00dd\u00de\7\34\2\2\u00de")
        buf.write("\u00df\7\33\2\2\u00df\u00e0\7\36\2\2\u00e0\u00e1\5B\"")
        buf.write("\2\u00e1\67\3\2\2\2\u00e2\u00e3\7)\2\2\u00e3\u00e8\5@")
        buf.write("!\2\u00e4\u00e5\7\34\2\2\u00e5\u00e7\5@!\2\u00e6\u00e4")
        buf.write("\3\2\2\2\u00e7\u00ea\3\2\2\2\u00e8\u00e6\3\2\2\2\u00e8")
        buf.write("\u00e9\3\2\2\2\u00e99\3\2\2\2\u00ea\u00e8\3\2\2\2\u00eb")
        buf.write("\u00ec\7 \2\2\u00ec;\3\2\2\2\u00ed\u00ee\7&\2\2\u00ee")
        buf.write("\u00f1\5> \2\u00ef\u00f0\7\34\2\2\u00f0\u00f2\5@!\2\u00f1")
        buf.write("\u00ef\3\2\2\2\u00f2\u00f3\3\2\2\2\u00f3\u00f1\3\2\2\2")
        buf.write("\u00f3\u00f4\3\2\2\2\u00f4=\3\2\2\2\u00f5\u00f6\7!\2\2")
        buf.write("\u00f6\u00f7\7\36\2\2\u00f7\u00f8\5\62\32\2\u00f8\u00f9")
        buf.write("\7\34\2\2\u00f9\u00fa\7%\2\2\u00fa\u00fb\7\36\2\2\u00fb")
        buf.write("\u00fc\5B\"\2\u00fc?\3\2\2\2\u00fd\u00fe\7\37\2\2\u00fe")
        buf.write("\u00ff\7\36\2\2\u00ff\u0100\5B\"\2\u0100A\3\2\2\2\u0101")
        buf.write("\u0102\7\5\2\2\u0102C\3\2\2\2\u0103\u0105\5F$\2\u0104")
        buf.write("\u0103\3\2\2\2\u0104\u0105\3\2\2\2\u0105\u0106\3\2\2\2")
        buf.write("\u0106\u0107\5H%\2\u0107E\3\2\2\2\u0108\u0109\t\6\2\2")
        buf.write("\u0109G\3\2\2\2\u010a\u010b\t\7\2\2\u010bI\3\2\2\2\u010c")
        buf.write("\u010d\t\b\2\2\u010dK\3\2\2\2\rQ_gz\u0084\u008f\u0095")
        buf.write("\u00b5\u00e8\u00f3\u0104")
        return buf.getvalue()


class dslParser ( Parser ):

    grammarFileName = "dsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'+'", "'-'", "<INVALID>", "<INVALID>", 
                     "'lat'", "'True'", "'False'", "'id'", "'tweet'", "'in_reply_to_status_id'", 
                     "'status'", "'possibly_sensitive'", "'long'", "'tweet_with_image'", 
                     "'image_name'", "'place_id'", "'display_coordinates'", 
                     "'reply_to_tweet'", "'retweet'", "'direct_message'", 
                     "'favourite'", "'schedule'", "'date'", "'time'", "'text'", 
                     "','", "';'", "':'", "'keyword'", "'follow_all_followers'", 
                     "'automate_time_minutes'", "'minute'", "'hour'", "'month'", 
                     "'response'", "'automate_reply_to_mentions'", "<INVALID>", 
                     "'day_of_month'", "'automate_favourites_retweets'", 
                     "'recipient_id'", "'0'", "'1'", "'2'", "'3'", "'4'", 
                     "'5'", "'6'", "'7'", "'8'", "'9'", "'00'", "'01'", 
                     "'02'", "'03'", "'04'", "'05'", "'06'", "'07'", "'08'", 
                     "'09'", "'10'", "'11'", "'12'", "'13'", "'14'", "'15'", 
                     "'16'", "'17'", "'18'", "'19'", "'20'", "'21'", "'22'", 
                     "'23'", "'24'", "'25'", "'26'", "'27'", "'28'", "'29'", 
                     "'30'", "'31'", "'32'", "'33'", "'34'", "'35'", "'36'", 
                     "'37'", "'38'", "'39'", "'40'", "'41'", "'42'", "'43'", 
                     "'44'", "'45'", "'46'", "'47'", "'48'", "'49'", "'50'", 
                     "'51'", "'52'", "'53'", "'54'", "'55'", "'56'", "'57'", 
                     "'58'", "'59'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "StringLiteral", 
                      "UnterminatedStringLiteral", "LAT", "TRUE", "FALSE", 
                      "ID", "TWEET", "REPLY_ID", "STATUS", "POSSIBLY_SENSITIVE", 
                      "LONG", "TWEET_IMAGE", "IMAGE_NAME", "PLACE_ID", "DISPLAY_COORDINATES", 
                      "REPLY", "RETWEET", "DIRECT_MESSAGE", "FAVOURITE", 
                      "SCHEDULE", "DATE", "TIME", "TEXT", "COMMA", "SEMICOLON", 
                      "COLON", "KEYWORD", "FOLLOWALL", "AUTOMATE_TIME", 
                      "MINUTE", "HOUR", "MONTH", "RESPONSE", "AUTOMATE_REPLY_MENTIONS", 
                      "WS", "DAY_OF_MONTH", "AUTO_FAV_RETWEET", "RECIPIENT_ID", 
                      "INT_0", "INT_1", "INT_2", "INT_3", "INT_4", "INT_5", 
                      "INT_6", "INT_7", "INT_8", "INT_9", "INT_00", "INT_01", 
                      "INT_02", "INT_03", "INT_04", "INT_05", "INT_06", 
                      "INT_07", "INT_08", "INT_09", "INT_10", "INT_11", 
                      "INT_12", "INT_13", "INT_14", "INT_15", "INT_16", 
                      "INT_17", "INT_18", "INT_19", "INT_20", "INT_21", 
                      "INT_22", "INT_23", "INT_24", "INT_25", "INT_26", 
                      "INT_27", "INT_28", "INT_29", "INT_30", "INT_31", 
                      "INT_32", "INT_33", "INT_34", "INT_35", "INT_36", 
                      "INT_37", "INT_38", "INT_39", "INT_40", "INT_41", 
                      "INT_42", "INT_43", "INT_44", "INT_45", "INT_46", 
                      "INT_47", "INT_48", "INT_49", "INT_50", "INT_51", 
                      "INT_52", "INT_53", "INT_54", "INT_55", "INT_56", 
                      "INT_57", "INT_58", "INT_59", "UNSIGNED_INT", "UNSIGNED_FLOAT" ]

    RULE_twitbot = 0
    RULE_stat = 1
    RULE_action = 2
    RULE_tweet = 3
    RULE_tweet_required_parameter = 4
    RULE_tweet_optional_parameters = 5
    RULE_tweetImage = 6
    RULE_tweet_image_required_parameter = 7
    RULE_reply = 8
    RULE_reply_required_parameters = 9
    RULE_retweet = 10
    RULE_retweet_required_parameter = 11
    RULE_favourite = 12
    RULE_favourite_required_parameter = 13
    RULE_scheduleTweet = 14
    RULE_schedule_tweet_required_parameter = 15
    RULE_date_time_parameter = 16
    RULE_minute = 17
    RULE_hour = 18
    RULE_day_of_month = 19
    RULE_month = 20
    RULE_numeric_month = 21
    RULE_numeric_day = 22
    RULE_numeric_hour = 23
    RULE_numeric_minute = 24
    RULE_directMessage = 25
    RULE_direct_message_required_parameters = 26
    RULE_autoFavouriteRetweet = 27
    RULE_autoFollowFollowers = 28
    RULE_autoReplyMentions = 29
    RULE_automateReplyParameter = 30
    RULE_keyword = 31
    RULE_stringValue = 32
    RULE_number = 33
    RULE_unary_operator = 34
    RULE_unsigned_number = 35
    RULE_boolean = 36

    ruleNames =  [ "twitbot", "stat", "action", "tweet", "tweet_required_parameter", 
                   "tweet_optional_parameters", "tweetImage", "tweet_image_required_parameter", 
                   "reply", "reply_required_parameters", "retweet", "retweet_required_parameter", 
                   "favourite", "favourite_required_parameter", "scheduleTweet", 
                   "schedule_tweet_required_parameter", "date_time_parameter", 
                   "minute", "hour", "day_of_month", "month", "numeric_month", 
                   "numeric_day", "numeric_hour", "numeric_minute", "directMessage", 
                   "direct_message_required_parameters", "autoFavouriteRetweet", 
                   "autoFollowFollowers", "autoReplyMentions", "automateReplyParameter", 
                   "keyword", "stringValue", "number", "unary_operator", 
                   "unsigned_number", "boolean" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    StringLiteral=3
    UnterminatedStringLiteral=4
    LAT=5
    TRUE=6
    FALSE=7
    ID=8
    TWEET=9
    REPLY_ID=10
    STATUS=11
    POSSIBLY_SENSITIVE=12
    LONG=13
    TWEET_IMAGE=14
    IMAGE_NAME=15
    PLACE_ID=16
    DISPLAY_COORDINATES=17
    REPLY=18
    RETWEET=19
    DIRECT_MESSAGE=20
    FAVOURITE=21
    SCHEDULE=22
    DATE=23
    TIME=24
    TEXT=25
    COMMA=26
    SEMICOLON=27
    COLON=28
    KEYWORD=29
    FOLLOWALL=30
    AUTOMATE_TIME=31
    MINUTE=32
    HOUR=33
    MONTH=34
    RESPONSE=35
    AUTOMATE_REPLY_MENTIONS=36
    WS=37
    DAY_OF_MONTH=38
    AUTO_FAV_RETWEET=39
    RECIPIENT_ID=40
    INT_0=41
    INT_1=42
    INT_2=43
    INT_3=44
    INT_4=45
    INT_5=46
    INT_6=47
    INT_7=48
    INT_8=49
    INT_9=50
    INT_00=51
    INT_01=52
    INT_02=53
    INT_03=54
    INT_04=55
    INT_05=56
    INT_06=57
    INT_07=58
    INT_08=59
    INT_09=60
    INT_10=61
    INT_11=62
    INT_12=63
    INT_13=64
    INT_14=65
    INT_15=66
    INT_16=67
    INT_17=68
    INT_18=69
    INT_19=70
    INT_20=71
    INT_21=72
    INT_22=73
    INT_23=74
    INT_24=75
    INT_25=76
    INT_26=77
    INT_27=78
    INT_28=79
    INT_29=80
    INT_30=81
    INT_31=82
    INT_32=83
    INT_33=84
    INT_34=85
    INT_35=86
    INT_36=87
    INT_37=88
    INT_38=89
    INT_39=90
    INT_40=91
    INT_41=92
    INT_42=93
    INT_43=94
    INT_44=95
    INT_45=96
    INT_46=97
    INT_47=98
    INT_48=99
    INT_49=100
    INT_50=101
    INT_51=102
    INT_52=103
    INT_53=104
    INT_54=105
    INT_55=106
    INT_56=107
    INT_57=108
    INT_58=109
    INT_59=110
    UNSIGNED_INT=111
    UNSIGNED_FLOAT=112

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class TwitbotContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.StatContext)
            else:
                return self.getTypedRuleContext(dslParser.StatContext,i)


        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.SEMICOLON)
            else:
                return self.getToken(dslParser.SEMICOLON, i)

        def getRuleIndex(self):
            return dslParser.RULE_twitbot

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTwitbot" ):
                listener.enterTwitbot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTwitbot" ):
                listener.exitTwitbot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTwitbot" ):
                return visitor.visitTwitbot(self)
            else:
                return visitor.visitChildren(self)




    def twitbot(self):

        localctx = dslParser.TwitbotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_twitbot)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 77 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 74
                self.stat()
                self.state = 75
                self.match(dslParser.SEMICOLON)
                self.state = 79 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << dslParser.TWEET) | (1 << dslParser.TWEET_IMAGE) | (1 << dslParser.REPLY) | (1 << dslParser.RETWEET) | (1 << dslParser.DIRECT_MESSAGE) | (1 << dslParser.FAVOURITE) | (1 << dslParser.SCHEDULE) | (1 << dslParser.FOLLOWALL) | (1 << dslParser.AUTOMATE_REPLY_MENTIONS) | (1 << dslParser.AUTO_FAV_RETWEET))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action(self):
            return self.getTypedRuleContext(dslParser.ActionContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_stat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat" ):
                listener.enterStat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat" ):
                listener.exitStat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat" ):
                return visitor.visitStat(self)
            else:
                return visitor.visitChildren(self)




    def stat(self):

        localctx = dslParser.StatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_stat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 81
            self.action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tweet(self):
            return self.getTypedRuleContext(dslParser.TweetContext,0)


        def tweetImage(self):
            return self.getTypedRuleContext(dslParser.TweetImageContext,0)


        def reply(self):
            return self.getTypedRuleContext(dslParser.ReplyContext,0)


        def retweet(self):
            return self.getTypedRuleContext(dslParser.RetweetContext,0)


        def favourite(self):
            return self.getTypedRuleContext(dslParser.FavouriteContext,0)


        def scheduleTweet(self):
            return self.getTypedRuleContext(dslParser.ScheduleTweetContext,0)


        def directMessage(self):
            return self.getTypedRuleContext(dslParser.DirectMessageContext,0)


        def autoFavouriteRetweet(self):
            return self.getTypedRuleContext(dslParser.AutoFavouriteRetweetContext,0)


        def autoFollowFollowers(self):
            return self.getTypedRuleContext(dslParser.AutoFollowFollowersContext,0)


        def autoReplyMentions(self):
            return self.getTypedRuleContext(dslParser.AutoReplyMentionsContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction" ):
                return visitor.visitAction(self)
            else:
                return visitor.visitChildren(self)




    def action(self):

        localctx = dslParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_action)
        try:
            self.state = 93
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dslParser.TWEET]:
                self.enterOuterAlt(localctx, 1)
                self.state = 83
                self.tweet()
                pass
            elif token in [dslParser.TWEET_IMAGE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 84
                self.tweetImage()
                pass
            elif token in [dslParser.REPLY]:
                self.enterOuterAlt(localctx, 3)
                self.state = 85
                self.reply()
                pass
            elif token in [dslParser.RETWEET]:
                self.enterOuterAlt(localctx, 4)
                self.state = 86
                self.retweet()
                pass
            elif token in [dslParser.FAVOURITE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 87
                self.favourite()
                pass
            elif token in [dslParser.SCHEDULE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 88
                self.scheduleTweet()
                pass
            elif token in [dslParser.DIRECT_MESSAGE]:
                self.enterOuterAlt(localctx, 7)
                self.state = 89
                self.directMessage()
                pass
            elif token in [dslParser.AUTO_FAV_RETWEET]:
                self.enterOuterAlt(localctx, 8)
                self.state = 90
                self.autoFavouriteRetweet()
                pass
            elif token in [dslParser.FOLLOWALL]:
                self.enterOuterAlt(localctx, 9)
                self.state = 91
                self.autoFollowFollowers()
                pass
            elif token in [dslParser.AUTOMATE_REPLY_MENTIONS]:
                self.enterOuterAlt(localctx, 10)
                self.state = 92
                self.autoReplyMentions()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TWEET(self):
            return self.getToken(dslParser.TWEET, 0)

        def tweet_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Tweet_required_parameterContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def tweet_optional_parameters(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.Tweet_optional_parametersContext)
            else:
                return self.getTypedRuleContext(dslParser.Tweet_optional_parametersContext,i)


        def getRuleIndex(self):
            return dslParser.RULE_tweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweet" ):
                listener.enterTweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweet" ):
                listener.exitTweet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTweet" ):
                return visitor.visitTweet(self)
            else:
                return visitor.visitChildren(self)




    def tweet(self):

        localctx = dslParser.TweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_tweet)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 95
            self.match(dslParser.TWEET)
            self.state = 96
            self.tweet_required_parameter()
            self.state = 101
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dslParser.COMMA:
                self.state = 97
                self.match(dslParser.COMMA)
                self.state = 98
                self.tweet_optional_parameters()
                self.state = 103
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tweet_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STATUS(self):
            return self.getToken(dslParser.STATUS, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_tweet_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweet_required_parameter" ):
                listener.enterTweet_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweet_required_parameter" ):
                listener.exitTweet_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTweet_required_parameter" ):
                return visitor.visitTweet_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def tweet_required_parameter(self):

        localctx = dslParser.Tweet_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_tweet_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 104
            self.match(dslParser.STATUS)
            self.state = 105
            self.match(dslParser.COLON)
            self.state = 106
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tweet_optional_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POSSIBLY_SENSITIVE(self):
            return self.getToken(dslParser.POSSIBLY_SENSITIVE, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def boolean(self):
            return self.getTypedRuleContext(dslParser.BooleanContext,0)


        def LAT(self):
            return self.getToken(dslParser.LAT, 0)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def LONG(self):
            return self.getToken(dslParser.LONG, 0)

        def DISPLAY_COORDINATES(self):
            return self.getToken(dslParser.DISPLAY_COORDINATES, 0)

        def getRuleIndex(self):
            return dslParser.RULE_tweet_optional_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweet_optional_parameters" ):
                listener.enterTweet_optional_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweet_optional_parameters" ):
                listener.exitTweet_optional_parameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTweet_optional_parameters" ):
                return visitor.visitTweet_optional_parameters(self)
            else:
                return visitor.visitChildren(self)




    def tweet_optional_parameters(self):

        localctx = dslParser.Tweet_optional_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_tweet_optional_parameters)
        try:
            self.state = 120
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dslParser.POSSIBLY_SENSITIVE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 108
                self.match(dslParser.POSSIBLY_SENSITIVE)
                self.state = 109
                self.match(dslParser.COLON)
                self.state = 110
                self.boolean()
                pass
            elif token in [dslParser.LAT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 111
                self.match(dslParser.LAT)
                self.state = 112
                self.match(dslParser.COLON)
                self.state = 113
                self.number()
                pass
            elif token in [dslParser.LONG]:
                self.enterOuterAlt(localctx, 3)
                self.state = 114
                self.match(dslParser.LONG)
                self.state = 115
                self.match(dslParser.COLON)
                self.state = 116
                self.number()
                pass
            elif token in [dslParser.DISPLAY_COORDINATES]:
                self.enterOuterAlt(localctx, 4)
                self.state = 117
                self.match(dslParser.DISPLAY_COORDINATES)
                self.state = 118
                self.match(dslParser.COLON)
                self.state = 119
                self.boolean()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TweetImageContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TWEET_IMAGE(self):
            return self.getToken(dslParser.TWEET_IMAGE, 0)

        def tweet_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Tweet_required_parameterContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def tweet_image_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Tweet_image_required_parameterContext,0)


        def tweet_optional_parameters(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.Tweet_optional_parametersContext)
            else:
                return self.getTypedRuleContext(dslParser.Tweet_optional_parametersContext,i)


        def getRuleIndex(self):
            return dslParser.RULE_tweetImage

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweetImage" ):
                listener.enterTweetImage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweetImage" ):
                listener.exitTweetImage(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTweetImage" ):
                return visitor.visitTweetImage(self)
            else:
                return visitor.visitChildren(self)




    def tweetImage(self):

        localctx = dslParser.TweetImageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_tweetImage)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 122
            self.match(dslParser.TWEET_IMAGE)
            self.state = 123
            self.tweet_required_parameter()
            self.state = 124
            self.match(dslParser.COMMA)
            self.state = 125
            self.tweet_image_required_parameter()
            self.state = 130
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dslParser.COMMA:
                self.state = 126
                self.match(dslParser.COMMA)
                self.state = 127
                self.tweet_optional_parameters()
                self.state = 132
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tweet_image_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMAGE_NAME(self):
            return self.getToken(dslParser.IMAGE_NAME, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_tweet_image_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweet_image_required_parameter" ):
                listener.enterTweet_image_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweet_image_required_parameter" ):
                listener.exitTweet_image_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTweet_image_required_parameter" ):
                return visitor.visitTweet_image_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def tweet_image_required_parameter(self):

        localctx = dslParser.Tweet_image_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_tweet_image_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            self.match(dslParser.IMAGE_NAME)
            self.state = 134
            self.match(dslParser.COLON)
            self.state = 135
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPLY(self):
            return self.getToken(dslParser.REPLY, 0)

        def reply_required_parameters(self):
            return self.getTypedRuleContext(dslParser.Reply_required_parametersContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def tweet_image_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Tweet_image_required_parameterContext,0)


        def tweet_optional_parameters(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.Tweet_optional_parametersContext)
            else:
                return self.getTypedRuleContext(dslParser.Tweet_optional_parametersContext,i)


        def getRuleIndex(self):
            return dslParser.RULE_reply

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReply" ):
                listener.enterReply(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReply" ):
                listener.exitReply(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReply" ):
                return visitor.visitReply(self)
            else:
                return visitor.visitChildren(self)




    def reply(self):

        localctx = dslParser.ReplyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_reply)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            self.match(dslParser.REPLY)
            self.state = 138
            self.reply_required_parameters()
            self.state = 141
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.state = 139
                self.match(dslParser.COMMA)
                self.state = 140
                self.tweet_image_required_parameter()


            self.state = 147
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dslParser.COMMA:
                self.state = 143
                self.match(dslParser.COMMA)
                self.state = 144
                self.tweet_optional_parameters()
                self.state = 149
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reply_required_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPLY_ID(self):
            return self.getToken(dslParser.REPLY_ID, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COLON)
            else:
                return self.getToken(dslParser.COLON, i)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def STATUS(self):
            return self.getToken(dslParser.STATUS, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_reply_required_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReply_required_parameters" ):
                listener.enterReply_required_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReply_required_parameters" ):
                listener.exitReply_required_parameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReply_required_parameters" ):
                return visitor.visitReply_required_parameters(self)
            else:
                return visitor.visitChildren(self)




    def reply_required_parameters(self):

        localctx = dslParser.Reply_required_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_reply_required_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 150
            self.match(dslParser.REPLY_ID)
            self.state = 151
            self.match(dslParser.COLON)
            self.state = 152
            self.number()
            self.state = 153
            self.match(dslParser.COMMA)
            self.state = 154
            self.match(dslParser.STATUS)
            self.state = 155
            self.match(dslParser.COLON)
            self.state = 156
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RetweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETWEET(self):
            return self.getToken(dslParser.RETWEET, 0)

        def retweet_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Retweet_required_parameterContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_retweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRetweet" ):
                listener.enterRetweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRetweet" ):
                listener.exitRetweet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRetweet" ):
                return visitor.visitRetweet(self)
            else:
                return visitor.visitChildren(self)




    def retweet(self):

        localctx = dslParser.RetweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_retweet)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self.match(dslParser.RETWEET)
            self.state = 159
            self.retweet_required_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Retweet_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(dslParser.ID, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_retweet_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRetweet_required_parameter" ):
                listener.enterRetweet_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRetweet_required_parameter" ):
                listener.exitRetweet_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRetweet_required_parameter" ):
                return visitor.visitRetweet_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def retweet_required_parameter(self):

        localctx = dslParser.Retweet_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_retweet_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 161
            self.match(dslParser.ID)
            self.state = 162
            self.match(dslParser.COLON)
            self.state = 163
            self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FavouriteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FAVOURITE(self):
            return self.getToken(dslParser.FAVOURITE, 0)

        def favourite_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Favourite_required_parameterContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_favourite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFavourite" ):
                listener.enterFavourite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFavourite" ):
                listener.exitFavourite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFavourite" ):
                return visitor.visitFavourite(self)
            else:
                return visitor.visitChildren(self)




    def favourite(self):

        localctx = dslParser.FavouriteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_favourite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 165
            self.match(dslParser.FAVOURITE)
            self.state = 166
            self.favourite_required_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Favourite_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(dslParser.ID, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_favourite_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFavourite_required_parameter" ):
                listener.enterFavourite_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFavourite_required_parameter" ):
                listener.exitFavourite_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFavourite_required_parameter" ):
                return visitor.visitFavourite_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def favourite_required_parameter(self):

        localctx = dslParser.Favourite_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_favourite_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.match(dslParser.ID)
            self.state = 169
            self.match(dslParser.COLON)
            self.state = 170
            self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScheduleTweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCHEDULE(self):
            return self.getToken(dslParser.SCHEDULE, 0)

        def schedule_tweet_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Schedule_tweet_required_parameterContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_scheduleTweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScheduleTweet" ):
                listener.enterScheduleTweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScheduleTweet" ):
                listener.exitScheduleTweet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScheduleTweet" ):
                return visitor.visitScheduleTweet(self)
            else:
                return visitor.visitChildren(self)




    def scheduleTweet(self):

        localctx = dslParser.ScheduleTweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_scheduleTweet)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self.match(dslParser.SCHEDULE)
            self.state = 173
            self.schedule_tweet_required_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Schedule_tweet_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def date_time_parameter(self):
            return self.getTypedRuleContext(dslParser.Date_time_parameterContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def tweet(self):
            return self.getTypedRuleContext(dslParser.TweetContext,0)


        def tweetImage(self):
            return self.getTypedRuleContext(dslParser.TweetImageContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_schedule_tweet_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchedule_tweet_required_parameter" ):
                listener.enterSchedule_tweet_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchedule_tweet_required_parameter" ):
                listener.exitSchedule_tweet_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSchedule_tweet_required_parameter" ):
                return visitor.visitSchedule_tweet_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def schedule_tweet_required_parameter(self):

        localctx = dslParser.Schedule_tweet_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_schedule_tweet_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 175
            self.date_time_parameter()
            self.state = 176
            self.match(dslParser.COMMA)
            self.state = 179
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dslParser.TWEET]:
                self.state = 177
                self.tweet()
                pass
            elif token in [dslParser.TWEET_IMAGE]:
                self.state = 178
                self.tweetImage()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Date_time_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def minute(self):
            return self.getTypedRuleContext(dslParser.MinuteContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def hour(self):
            return self.getTypedRuleContext(dslParser.HourContext,0)


        def day_of_month(self):
            return self.getTypedRuleContext(dslParser.Day_of_monthContext,0)


        def month(self):
            return self.getTypedRuleContext(dslParser.MonthContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_date_time_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate_time_parameter" ):
                listener.enterDate_time_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate_time_parameter" ):
                listener.exitDate_time_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDate_time_parameter" ):
                return visitor.visitDate_time_parameter(self)
            else:
                return visitor.visitChildren(self)




    def date_time_parameter(self):

        localctx = dslParser.Date_time_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_date_time_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            self.minute()
            self.state = 182
            self.match(dslParser.COMMA)
            self.state = 183
            self.hour()
            self.state = 184
            self.match(dslParser.COMMA)
            self.state = 185
            self.day_of_month()
            self.state = 186
            self.match(dslParser.COMMA)
            self.state = 187
            self.month()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinuteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUTE(self):
            return self.getToken(dslParser.MINUTE, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def numeric_minute(self):
            return self.getTypedRuleContext(dslParser.Numeric_minuteContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_minute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinute" ):
                listener.enterMinute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinute" ):
                listener.exitMinute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMinute" ):
                return visitor.visitMinute(self)
            else:
                return visitor.visitChildren(self)




    def minute(self):

        localctx = dslParser.MinuteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_minute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 189
            self.match(dslParser.MINUTE)
            self.state = 190
            self.match(dslParser.COLON)
            self.state = 191
            self.numeric_minute()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HourContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HOUR(self):
            return self.getToken(dslParser.HOUR, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def numeric_hour(self):
            return self.getTypedRuleContext(dslParser.Numeric_hourContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_hour

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHour" ):
                listener.enterHour(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHour" ):
                listener.exitHour(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHour" ):
                return visitor.visitHour(self)
            else:
                return visitor.visitChildren(self)




    def hour(self):

        localctx = dslParser.HourContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_hour)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(dslParser.HOUR)
            self.state = 194
            self.match(dslParser.COLON)
            self.state = 195
            self.numeric_hour()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Day_of_monthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAY_OF_MONTH(self):
            return self.getToken(dslParser.DAY_OF_MONTH, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def numeric_day(self):
            return self.getTypedRuleContext(dslParser.Numeric_dayContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_day_of_month

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDay_of_month" ):
                listener.enterDay_of_month(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDay_of_month" ):
                listener.exitDay_of_month(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDay_of_month" ):
                return visitor.visitDay_of_month(self)
            else:
                return visitor.visitChildren(self)




    def day_of_month(self):

        localctx = dslParser.Day_of_monthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_day_of_month)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.match(dslParser.DAY_OF_MONTH)
            self.state = 198
            self.match(dslParser.COLON)
            self.state = 199
            self.numeric_day()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MonthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MONTH(self):
            return self.getToken(dslParser.MONTH, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def numeric_month(self):
            return self.getTypedRuleContext(dslParser.Numeric_monthContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_month

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMonth" ):
                listener.enterMonth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMonth" ):
                listener.exitMonth(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMonth" ):
                return visitor.visitMonth(self)
            else:
                return visitor.visitChildren(self)




    def month(self):

        localctx = dslParser.MonthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_month)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self.match(dslParser.MONTH)
            self.state = 202
            self.match(dslParser.COLON)
            self.state = 203
            self.numeric_month()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_monthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_1(self):
            return self.getToken(dslParser.INT_1, 0)

        def INT_2(self):
            return self.getToken(dslParser.INT_2, 0)

        def INT_3(self):
            return self.getToken(dslParser.INT_3, 0)

        def INT_4(self):
            return self.getToken(dslParser.INT_4, 0)

        def INT_5(self):
            return self.getToken(dslParser.INT_5, 0)

        def INT_6(self):
            return self.getToken(dslParser.INT_6, 0)

        def INT_7(self):
            return self.getToken(dslParser.INT_7, 0)

        def INT_8(self):
            return self.getToken(dslParser.INT_8, 0)

        def INT_9(self):
            return self.getToken(dslParser.INT_9, 0)

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_month

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_month" ):
                listener.enterNumeric_month(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_month" ):
                listener.exitNumeric_month(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_month" ):
                return visitor.visitNumeric_month(self)
            else:
                return visitor.visitChildren(self)




    def numeric_month(self):

        localctx = dslParser.Numeric_monthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_numeric_month)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 205
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << dslParser.INT_1) | (1 << dslParser.INT_2) | (1 << dslParser.INT_3) | (1 << dslParser.INT_4) | (1 << dslParser.INT_5) | (1 << dslParser.INT_6) | (1 << dslParser.INT_7) | (1 << dslParser.INT_8) | (1 << dslParser.INT_9) | (1 << dslParser.INT_01) | (1 << dslParser.INT_02) | (1 << dslParser.INT_03) | (1 << dslParser.INT_04) | (1 << dslParser.INT_05) | (1 << dslParser.INT_06) | (1 << dslParser.INT_07) | (1 << dslParser.INT_08) | (1 << dslParser.INT_09) | (1 << dslParser.INT_10) | (1 << dslParser.INT_11) | (1 << dslParser.INT_12))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_dayContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_1(self):
            return self.getToken(dslParser.INT_1, 0)

        def INT_2(self):
            return self.getToken(dslParser.INT_2, 0)

        def INT_3(self):
            return self.getToken(dslParser.INT_3, 0)

        def INT_4(self):
            return self.getToken(dslParser.INT_4, 0)

        def INT_5(self):
            return self.getToken(dslParser.INT_5, 0)

        def INT_6(self):
            return self.getToken(dslParser.INT_6, 0)

        def INT_7(self):
            return self.getToken(dslParser.INT_7, 0)

        def INT_8(self):
            return self.getToken(dslParser.INT_8, 0)

        def INT_9(self):
            return self.getToken(dslParser.INT_9, 0)

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def INT_13(self):
            return self.getToken(dslParser.INT_13, 0)

        def INT_14(self):
            return self.getToken(dslParser.INT_14, 0)

        def INT_15(self):
            return self.getToken(dslParser.INT_15, 0)

        def INT_16(self):
            return self.getToken(dslParser.INT_16, 0)

        def INT_17(self):
            return self.getToken(dslParser.INT_17, 0)

        def INT_18(self):
            return self.getToken(dslParser.INT_18, 0)

        def INT_19(self):
            return self.getToken(dslParser.INT_19, 0)

        def INT_20(self):
            return self.getToken(dslParser.INT_20, 0)

        def INT_21(self):
            return self.getToken(dslParser.INT_21, 0)

        def INT_22(self):
            return self.getToken(dslParser.INT_22, 0)

        def INT_23(self):
            return self.getToken(dslParser.INT_23, 0)

        def INT_24(self):
            return self.getToken(dslParser.INT_24, 0)

        def INT_25(self):
            return self.getToken(dslParser.INT_25, 0)

        def INT_26(self):
            return self.getToken(dslParser.INT_26, 0)

        def INT_27(self):
            return self.getToken(dslParser.INT_27, 0)

        def INT_28(self):
            return self.getToken(dslParser.INT_28, 0)

        def INT_29(self):
            return self.getToken(dslParser.INT_29, 0)

        def INT_30(self):
            return self.getToken(dslParser.INT_30, 0)

        def INT_31(self):
            return self.getToken(dslParser.INT_31, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_day

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_day" ):
                listener.enterNumeric_day(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_day" ):
                listener.exitNumeric_day(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_day" ):
                return visitor.visitNumeric_day(self)
            else:
                return visitor.visitChildren(self)




    def numeric_day(self):

        localctx = dslParser.Numeric_dayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_numeric_day)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 207
            _la = self._input.LA(1)
            if not(((((_la - 42)) & ~0x3f) == 0 and ((1 << (_la - 42)) & ((1 << (dslParser.INT_1 - 42)) | (1 << (dslParser.INT_2 - 42)) | (1 << (dslParser.INT_3 - 42)) | (1 << (dslParser.INT_4 - 42)) | (1 << (dslParser.INT_5 - 42)) | (1 << (dslParser.INT_6 - 42)) | (1 << (dslParser.INT_7 - 42)) | (1 << (dslParser.INT_8 - 42)) | (1 << (dslParser.INT_9 - 42)) | (1 << (dslParser.INT_01 - 42)) | (1 << (dslParser.INT_02 - 42)) | (1 << (dslParser.INT_03 - 42)) | (1 << (dslParser.INT_04 - 42)) | (1 << (dslParser.INT_05 - 42)) | (1 << (dslParser.INT_06 - 42)) | (1 << (dslParser.INT_07 - 42)) | (1 << (dslParser.INT_08 - 42)) | (1 << (dslParser.INT_09 - 42)) | (1 << (dslParser.INT_10 - 42)) | (1 << (dslParser.INT_11 - 42)) | (1 << (dslParser.INT_12 - 42)) | (1 << (dslParser.INT_13 - 42)) | (1 << (dslParser.INT_14 - 42)) | (1 << (dslParser.INT_15 - 42)) | (1 << (dslParser.INT_16 - 42)) | (1 << (dslParser.INT_17 - 42)) | (1 << (dslParser.INT_18 - 42)) | (1 << (dslParser.INT_19 - 42)) | (1 << (dslParser.INT_20 - 42)) | (1 << (dslParser.INT_21 - 42)) | (1 << (dslParser.INT_22 - 42)) | (1 << (dslParser.INT_23 - 42)) | (1 << (dslParser.INT_24 - 42)) | (1 << (dslParser.INT_25 - 42)) | (1 << (dslParser.INT_26 - 42)) | (1 << (dslParser.INT_27 - 42)) | (1 << (dslParser.INT_28 - 42)) | (1 << (dslParser.INT_29 - 42)) | (1 << (dslParser.INT_30 - 42)) | (1 << (dslParser.INT_31 - 42)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_hourContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_1(self):
            return self.getToken(dslParser.INT_1, 0)

        def INT_2(self):
            return self.getToken(dslParser.INT_2, 0)

        def INT_3(self):
            return self.getToken(dslParser.INT_3, 0)

        def INT_4(self):
            return self.getToken(dslParser.INT_4, 0)

        def INT_5(self):
            return self.getToken(dslParser.INT_5, 0)

        def INT_6(self):
            return self.getToken(dslParser.INT_6, 0)

        def INT_7(self):
            return self.getToken(dslParser.INT_7, 0)

        def INT_8(self):
            return self.getToken(dslParser.INT_8, 0)

        def INT_9(self):
            return self.getToken(dslParser.INT_9, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def INT_13(self):
            return self.getToken(dslParser.INT_13, 0)

        def INT_14(self):
            return self.getToken(dslParser.INT_14, 0)

        def INT_15(self):
            return self.getToken(dslParser.INT_15, 0)

        def INT_16(self):
            return self.getToken(dslParser.INT_16, 0)

        def INT_17(self):
            return self.getToken(dslParser.INT_17, 0)

        def INT_18(self):
            return self.getToken(dslParser.INT_18, 0)

        def INT_19(self):
            return self.getToken(dslParser.INT_19, 0)

        def INT_20(self):
            return self.getToken(dslParser.INT_20, 0)

        def INT_21(self):
            return self.getToken(dslParser.INT_21, 0)

        def INT_22(self):
            return self.getToken(dslParser.INT_22, 0)

        def INT_23(self):
            return self.getToken(dslParser.INT_23, 0)

        def INT_24(self):
            return self.getToken(dslParser.INT_24, 0)

        def INT_00(self):
            return self.getToken(dslParser.INT_00, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_hour

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_hour" ):
                listener.enterNumeric_hour(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_hour" ):
                listener.exitNumeric_hour(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_hour" ):
                return visitor.visitNumeric_hour(self)
            else:
                return visitor.visitChildren(self)




    def numeric_hour(self):

        localctx = dslParser.Numeric_hourContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_numeric_hour)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            _la = self._input.LA(1)
            if not(((((_la - 42)) & ~0x3f) == 0 and ((1 << (_la - 42)) & ((1 << (dslParser.INT_1 - 42)) | (1 << (dslParser.INT_2 - 42)) | (1 << (dslParser.INT_3 - 42)) | (1 << (dslParser.INT_4 - 42)) | (1 << (dslParser.INT_5 - 42)) | (1 << (dslParser.INT_6 - 42)) | (1 << (dslParser.INT_7 - 42)) | (1 << (dslParser.INT_8 - 42)) | (1 << (dslParser.INT_9 - 42)) | (1 << (dslParser.INT_00 - 42)) | (1 << (dslParser.INT_01 - 42)) | (1 << (dslParser.INT_02 - 42)) | (1 << (dslParser.INT_03 - 42)) | (1 << (dslParser.INT_04 - 42)) | (1 << (dslParser.INT_05 - 42)) | (1 << (dslParser.INT_06 - 42)) | (1 << (dslParser.INT_07 - 42)) | (1 << (dslParser.INT_08 - 42)) | (1 << (dslParser.INT_09 - 42)) | (1 << (dslParser.INT_10 - 42)) | (1 << (dslParser.INT_11 - 42)) | (1 << (dslParser.INT_12 - 42)) | (1 << (dslParser.INT_13 - 42)) | (1 << (dslParser.INT_14 - 42)) | (1 << (dslParser.INT_15 - 42)) | (1 << (dslParser.INT_16 - 42)) | (1 << (dslParser.INT_17 - 42)) | (1 << (dslParser.INT_18 - 42)) | (1 << (dslParser.INT_19 - 42)) | (1 << (dslParser.INT_20 - 42)) | (1 << (dslParser.INT_21 - 42)) | (1 << (dslParser.INT_22 - 42)) | (1 << (dslParser.INT_23 - 42)) | (1 << (dslParser.INT_24 - 42)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_minuteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_1(self):
            return self.getToken(dslParser.INT_1, 0)

        def INT_2(self):
            return self.getToken(dslParser.INT_2, 0)

        def INT_3(self):
            return self.getToken(dslParser.INT_3, 0)

        def INT_4(self):
            return self.getToken(dslParser.INT_4, 0)

        def INT_5(self):
            return self.getToken(dslParser.INT_5, 0)

        def INT_6(self):
            return self.getToken(dslParser.INT_6, 0)

        def INT_7(self):
            return self.getToken(dslParser.INT_7, 0)

        def INT_8(self):
            return self.getToken(dslParser.INT_8, 0)

        def INT_9(self):
            return self.getToken(dslParser.INT_9, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def INT_13(self):
            return self.getToken(dslParser.INT_13, 0)

        def INT_14(self):
            return self.getToken(dslParser.INT_14, 0)

        def INT_15(self):
            return self.getToken(dslParser.INT_15, 0)

        def INT_16(self):
            return self.getToken(dslParser.INT_16, 0)

        def INT_17(self):
            return self.getToken(dslParser.INT_17, 0)

        def INT_18(self):
            return self.getToken(dslParser.INT_18, 0)

        def INT_19(self):
            return self.getToken(dslParser.INT_19, 0)

        def INT_20(self):
            return self.getToken(dslParser.INT_20, 0)

        def INT_21(self):
            return self.getToken(dslParser.INT_21, 0)

        def INT_22(self):
            return self.getToken(dslParser.INT_22, 0)

        def INT_23(self):
            return self.getToken(dslParser.INT_23, 0)

        def INT_24(self):
            return self.getToken(dslParser.INT_24, 0)

        def INT_25(self):
            return self.getToken(dslParser.INT_25, 0)

        def INT_26(self):
            return self.getToken(dslParser.INT_26, 0)

        def INT_27(self):
            return self.getToken(dslParser.INT_27, 0)

        def INT_28(self):
            return self.getToken(dslParser.INT_28, 0)

        def INT_29(self):
            return self.getToken(dslParser.INT_29, 0)

        def INT_30(self):
            return self.getToken(dslParser.INT_30, 0)

        def INT_31(self):
            return self.getToken(dslParser.INT_31, 0)

        def INT_32(self):
            return self.getToken(dslParser.INT_32, 0)

        def INT_33(self):
            return self.getToken(dslParser.INT_33, 0)

        def INT_34(self):
            return self.getToken(dslParser.INT_34, 0)

        def INT_35(self):
            return self.getToken(dslParser.INT_35, 0)

        def INT_36(self):
            return self.getToken(dslParser.INT_36, 0)

        def INT_37(self):
            return self.getToken(dslParser.INT_37, 0)

        def INT_38(self):
            return self.getToken(dslParser.INT_38, 0)

        def INT_39(self):
            return self.getToken(dslParser.INT_39, 0)

        def INT_40(self):
            return self.getToken(dslParser.INT_40, 0)

        def INT_41(self):
            return self.getToken(dslParser.INT_41, 0)

        def INT_42(self):
            return self.getToken(dslParser.INT_42, 0)

        def INT_43(self):
            return self.getToken(dslParser.INT_43, 0)

        def INT_44(self):
            return self.getToken(dslParser.INT_44, 0)

        def INT_45(self):
            return self.getToken(dslParser.INT_45, 0)

        def INT_46(self):
            return self.getToken(dslParser.INT_46, 0)

        def INT_47(self):
            return self.getToken(dslParser.INT_47, 0)

        def INT_48(self):
            return self.getToken(dslParser.INT_48, 0)

        def INT_49(self):
            return self.getToken(dslParser.INT_49, 0)

        def INT_50(self):
            return self.getToken(dslParser.INT_50, 0)

        def INT_51(self):
            return self.getToken(dslParser.INT_51, 0)

        def INT_52(self):
            return self.getToken(dslParser.INT_52, 0)

        def INT_53(self):
            return self.getToken(dslParser.INT_53, 0)

        def INT_54(self):
            return self.getToken(dslParser.INT_54, 0)

        def INT_55(self):
            return self.getToken(dslParser.INT_55, 0)

        def INT_56(self):
            return self.getToken(dslParser.INT_56, 0)

        def INT_57(self):
            return self.getToken(dslParser.INT_57, 0)

        def INT_58(self):
            return self.getToken(dslParser.INT_58, 0)

        def INT_59(self):
            return self.getToken(dslParser.INT_59, 0)

        def INT_00(self):
            return self.getToken(dslParser.INT_00, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_minute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_minute" ):
                listener.enterNumeric_minute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_minute" ):
                listener.exitNumeric_minute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_minute" ):
                return visitor.visitNumeric_minute(self)
            else:
                return visitor.visitChildren(self)




    def numeric_minute(self):

        localctx = dslParser.Numeric_minuteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_numeric_minute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << dslParser.INT_1) | (1 << dslParser.INT_2) | (1 << dslParser.INT_3) | (1 << dslParser.INT_4) | (1 << dslParser.INT_5) | (1 << dslParser.INT_6) | (1 << dslParser.INT_7) | (1 << dslParser.INT_8) | (1 << dslParser.INT_9) | (1 << dslParser.INT_00) | (1 << dslParser.INT_01) | (1 << dslParser.INT_02) | (1 << dslParser.INT_03) | (1 << dslParser.INT_04) | (1 << dslParser.INT_05) | (1 << dslParser.INT_06) | (1 << dslParser.INT_07) | (1 << dslParser.INT_08) | (1 << dslParser.INT_09) | (1 << dslParser.INT_10) | (1 << dslParser.INT_11) | (1 << dslParser.INT_12))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (dslParser.INT_13 - 64)) | (1 << (dslParser.INT_14 - 64)) | (1 << (dslParser.INT_15 - 64)) | (1 << (dslParser.INT_16 - 64)) | (1 << (dslParser.INT_17 - 64)) | (1 << (dslParser.INT_18 - 64)) | (1 << (dslParser.INT_19 - 64)) | (1 << (dslParser.INT_20 - 64)) | (1 << (dslParser.INT_21 - 64)) | (1 << (dslParser.INT_22 - 64)) | (1 << (dslParser.INT_23 - 64)) | (1 << (dslParser.INT_24 - 64)) | (1 << (dslParser.INT_25 - 64)) | (1 << (dslParser.INT_26 - 64)) | (1 << (dslParser.INT_27 - 64)) | (1 << (dslParser.INT_28 - 64)) | (1 << (dslParser.INT_29 - 64)) | (1 << (dslParser.INT_30 - 64)) | (1 << (dslParser.INT_31 - 64)) | (1 << (dslParser.INT_32 - 64)) | (1 << (dslParser.INT_33 - 64)) | (1 << (dslParser.INT_34 - 64)) | (1 << (dslParser.INT_35 - 64)) | (1 << (dslParser.INT_36 - 64)) | (1 << (dslParser.INT_37 - 64)) | (1 << (dslParser.INT_38 - 64)) | (1 << (dslParser.INT_39 - 64)) | (1 << (dslParser.INT_40 - 64)) | (1 << (dslParser.INT_41 - 64)) | (1 << (dslParser.INT_42 - 64)) | (1 << (dslParser.INT_43 - 64)) | (1 << (dslParser.INT_44 - 64)) | (1 << (dslParser.INT_45 - 64)) | (1 << (dslParser.INT_46 - 64)) | (1 << (dslParser.INT_47 - 64)) | (1 << (dslParser.INT_48 - 64)) | (1 << (dslParser.INT_49 - 64)) | (1 << (dslParser.INT_50 - 64)) | (1 << (dslParser.INT_51 - 64)) | (1 << (dslParser.INT_52 - 64)) | (1 << (dslParser.INT_53 - 64)) | (1 << (dslParser.INT_54 - 64)) | (1 << (dslParser.INT_55 - 64)) | (1 << (dslParser.INT_56 - 64)) | (1 << (dslParser.INT_57 - 64)) | (1 << (dslParser.INT_58 - 64)) | (1 << (dslParser.INT_59 - 64)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DirectMessageContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIRECT_MESSAGE(self):
            return self.getToken(dslParser.DIRECT_MESSAGE, 0)

        def direct_message_required_parameters(self):
            return self.getTypedRuleContext(dslParser.Direct_message_required_parametersContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_directMessage

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirectMessage" ):
                listener.enterDirectMessage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirectMessage" ):
                listener.exitDirectMessage(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirectMessage" ):
                return visitor.visitDirectMessage(self)
            else:
                return visitor.visitChildren(self)




    def directMessage(self):

        localctx = dslParser.DirectMessageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_directMessage)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self.match(dslParser.DIRECT_MESSAGE)
            self.state = 214
            self.direct_message_required_parameters()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Direct_message_required_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RECIPIENT_ID(self):
            return self.getToken(dslParser.RECIPIENT_ID, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COLON)
            else:
                return self.getToken(dslParser.COLON, i)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def TEXT(self):
            return self.getToken(dslParser.TEXT, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_direct_message_required_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirect_message_required_parameters" ):
                listener.enterDirect_message_required_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirect_message_required_parameters" ):
                listener.exitDirect_message_required_parameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirect_message_required_parameters" ):
                return visitor.visitDirect_message_required_parameters(self)
            else:
                return visitor.visitChildren(self)




    def direct_message_required_parameters(self):

        localctx = dslParser.Direct_message_required_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_direct_message_required_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 216
            self.match(dslParser.RECIPIENT_ID)
            self.state = 217
            self.match(dslParser.COLON)
            self.state = 218
            self.number()
            self.state = 219
            self.match(dslParser.COMMA)
            self.state = 220
            self.match(dslParser.TEXT)
            self.state = 221
            self.match(dslParser.COLON)
            self.state = 222
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutoFavouriteRetweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AUTO_FAV_RETWEET(self):
            return self.getToken(dslParser.AUTO_FAV_RETWEET, 0)

        def keyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.KeywordContext)
            else:
                return self.getTypedRuleContext(dslParser.KeywordContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def getRuleIndex(self):
            return dslParser.RULE_autoFavouriteRetweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutoFavouriteRetweet" ):
                listener.enterAutoFavouriteRetweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutoFavouriteRetweet" ):
                listener.exitAutoFavouriteRetweet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAutoFavouriteRetweet" ):
                return visitor.visitAutoFavouriteRetweet(self)
            else:
                return visitor.visitChildren(self)




    def autoFavouriteRetweet(self):

        localctx = dslParser.AutoFavouriteRetweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_autoFavouriteRetweet)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 224
            self.match(dslParser.AUTO_FAV_RETWEET)
            self.state = 225
            self.keyword()
            self.state = 230
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dslParser.COMMA:
                self.state = 226
                self.match(dslParser.COMMA)
                self.state = 227
                self.keyword()
                self.state = 232
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutoFollowFollowersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOLLOWALL(self):
            return self.getToken(dslParser.FOLLOWALL, 0)

        def getRuleIndex(self):
            return dslParser.RULE_autoFollowFollowers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutoFollowFollowers" ):
                listener.enterAutoFollowFollowers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutoFollowFollowers" ):
                listener.exitAutoFollowFollowers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAutoFollowFollowers" ):
                return visitor.visitAutoFollowFollowers(self)
            else:
                return visitor.visitChildren(self)




    def autoFollowFollowers(self):

        localctx = dslParser.AutoFollowFollowersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_autoFollowFollowers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            self.match(dslParser.FOLLOWALL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutoReplyMentionsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AUTOMATE_REPLY_MENTIONS(self):
            return self.getToken(dslParser.AUTOMATE_REPLY_MENTIONS, 0)

        def automateReplyParameter(self):
            return self.getTypedRuleContext(dslParser.AutomateReplyParameterContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def keyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.KeywordContext)
            else:
                return self.getTypedRuleContext(dslParser.KeywordContext,i)


        def getRuleIndex(self):
            return dslParser.RULE_autoReplyMentions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutoReplyMentions" ):
                listener.enterAutoReplyMentions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutoReplyMentions" ):
                listener.exitAutoReplyMentions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAutoReplyMentions" ):
                return visitor.visitAutoReplyMentions(self)
            else:
                return visitor.visitChildren(self)




    def autoReplyMentions(self):

        localctx = dslParser.AutoReplyMentionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_autoReplyMentions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 235
            self.match(dslParser.AUTOMATE_REPLY_MENTIONS)
            self.state = 236
            self.automateReplyParameter()
            self.state = 239 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 237
                self.match(dslParser.COMMA)
                self.state = 238
                self.keyword()
                self.state = 241 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==dslParser.COMMA):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutomateReplyParameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AUTOMATE_TIME(self):
            return self.getToken(dslParser.AUTOMATE_TIME, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COLON)
            else:
                return self.getToken(dslParser.COLON, i)

        def numeric_minute(self):
            return self.getTypedRuleContext(dslParser.Numeric_minuteContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def RESPONSE(self):
            return self.getToken(dslParser.RESPONSE, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_automateReplyParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutomateReplyParameter" ):
                listener.enterAutomateReplyParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutomateReplyParameter" ):
                listener.exitAutomateReplyParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAutomateReplyParameter" ):
                return visitor.visitAutomateReplyParameter(self)
            else:
                return visitor.visitChildren(self)




    def automateReplyParameter(self):

        localctx = dslParser.AutomateReplyParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_automateReplyParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 243
            self.match(dslParser.AUTOMATE_TIME)
            self.state = 244
            self.match(dslParser.COLON)
            self.state = 245
            self.numeric_minute()
            self.state = 246
            self.match(dslParser.COMMA)
            self.state = 247
            self.match(dslParser.RESPONSE)
            self.state = 248
            self.match(dslParser.COLON)
            self.state = 249
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeywordContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEYWORD(self):
            return self.getToken(dslParser.KEYWORD, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_keyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyword" ):
                listener.enterKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyword" ):
                listener.exitKeyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeyword" ):
                return visitor.visitKeyword(self)
            else:
                return visitor.visitChildren(self)




    def keyword(self):

        localctx = dslParser.KeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_keyword)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 251
            self.match(dslParser.KEYWORD)
            self.state = 252
            self.match(dslParser.COLON)
            self.state = 253
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringValueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def StringLiteral(self):
            return self.getToken(dslParser.StringLiteral, 0)

        def getRuleIndex(self):
            return dslParser.RULE_stringValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringValue" ):
                listener.enterStringValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringValue" ):
                listener.exitStringValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringValue" ):
                return visitor.visitStringValue(self)
            else:
                return visitor.visitChildren(self)




    def stringValue(self):

        localctx = dslParser.StringValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_stringValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 255
            self.match(dslParser.StringLiteral)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unsigned_number(self):
            return self.getTypedRuleContext(dslParser.Unsigned_numberContext,0)


        def unary_operator(self):
            return self.getTypedRuleContext(dslParser.Unary_operatorContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)




    def number(self):

        localctx = dslParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 258
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dslParser.T__0 or _la==dslParser.T__1:
                self.state = 257
                self.unary_operator()


            self.state = 260
            self.unsigned_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unary_operatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return dslParser.RULE_unary_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnary_operator" ):
                listener.enterUnary_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnary_operator" ):
                listener.exitUnary_operator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnary_operator" ):
                return visitor.visitUnary_operator(self)
            else:
                return visitor.visitChildren(self)




    def unary_operator(self):

        localctx = dslParser.Unary_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_unary_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 262
            _la = self._input.LA(1)
            if not(_la==dslParser.T__0 or _la==dslParser.T__1):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unsigned_numberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNSIGNED_INT(self):
            return self.getToken(dslParser.UNSIGNED_INT, 0)

        def UNSIGNED_FLOAT(self):
            return self.getToken(dslParser.UNSIGNED_FLOAT, 0)

        def getRuleIndex(self):
            return dslParser.RULE_unsigned_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnsigned_number" ):
                listener.enterUnsigned_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnsigned_number" ):
                listener.exitUnsigned_number(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnsigned_number" ):
                return visitor.visitUnsigned_number(self)
            else:
                return visitor.visitChildren(self)




    def unsigned_number(self):

        localctx = dslParser.Unsigned_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_unsigned_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            _la = self._input.LA(1)
            if not(_la==dslParser.UNSIGNED_INT or _la==dslParser.UNSIGNED_FLOAT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(dslParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(dslParser.FALSE, 0)

        def getRuleIndex(self):
            return dslParser.RULE_boolean

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolean" ):
                listener.enterBoolean(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolean" ):
                listener.exitBoolean(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolean" ):
                return visitor.visitBoolean(self)
            else:
                return visitor.visitChildren(self)




    def boolean(self):

        localctx = dslParser.BooleanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_boolean)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 266
            _la = self._input.LA(1)
            if not(_la==dslParser.TRUE or _la==dslParser.FALSE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





