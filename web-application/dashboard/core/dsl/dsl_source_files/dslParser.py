# Generated from dsl.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3o")
        buf.write("\u00fb\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\3\2\3\2\3\2")
        buf.write("\3\2\3\2\7\2N\n\2\f\2\16\2Q\13\2\3\3\3\3\3\4\3\4\3\4\3")
        buf.write("\4\3\4\3\4\3\4\3\4\3\4\5\4^\n\4\3\5\3\5\3\5\3\5\7\5d\n")
        buf.write("\5\f\5\16\5g\13\5\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\5\7|\n\7\3\b")
        buf.write("\3\b\3\b\3\b\7\b\u0082\n\b\f\b\16\b\u0085\13\b\3\t\3\t")
        buf.write("\3\t\3\t\3\t\3\t\3\t\3\t\3\n\3\n\3\n\3\13\3\13\3\13\3")
        buf.write("\13\3\f\3\f\3\f\3\r\3\r\3\r\3\r\3\16\3\16\3\16\3\17\3")
        buf.write("\17\3\17\3\17\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20")
        buf.write("\3\21\3\21\3\21\3\21\3\22\3\22\3\22\3\22\3\23\3\23\3\23")
        buf.write("\3\23\3\24\3\24\3\24\3\24\3\25\3\25\3\26\3\26\3\27\3\27")
        buf.write("\3\30\3\30\3\31\3\31\3\31\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\33\3\33\3\33\3\33\7\33\u00d3\n\33\f\33\16")
        buf.write("\33\u00d6\13\33\3\34\3\34\3\35\3\35\3\35\3\35\6\35\u00de")
        buf.write("\n\35\r\35\16\35\u00df\3\36\3\36\3\36\3\36\3\36\3\36\3")
        buf.write("\36\3\36\3\37\3\37\3\37\3\37\3 \3 \3!\5!\u00f1\n!\3!\3")
        buf.write("!\3\"\3\"\3#\3#\3$\3$\3$\2\2%\2\4\6\b\n\f\16\20\22\24")
        buf.write("\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDF\2\t\4\2)")
        buf.write("\61\63>\4\2)\61\63Q\3\2\62J\3\2\62m\3\2\3\4\3\2no\3\2")
        buf.write("\b\t\2\u00e9\2H\3\2\2\2\4R\3\2\2\2\6]\3\2\2\2\b_\3\2\2")
        buf.write("\2\nh\3\2\2\2\f{\3\2\2\2\16}\3\2\2\2\20\u0086\3\2\2\2")
        buf.write("\22\u008e\3\2\2\2\24\u0091\3\2\2\2\26\u0095\3\2\2\2\30")
        buf.write("\u0098\3\2\2\2\32\u009c\3\2\2\2\34\u009f\3\2\2\2\36\u00a3")
        buf.write("\3\2\2\2 \u00ab\3\2\2\2\"\u00af\3\2\2\2$\u00b3\3\2\2\2")
        buf.write("&\u00b7\3\2\2\2(\u00bb\3\2\2\2*\u00bd\3\2\2\2,\u00bf\3")
        buf.write("\2\2\2.\u00c1\3\2\2\2\60\u00c3\3\2\2\2\62\u00c6\3\2\2")
        buf.write("\2\64\u00ce\3\2\2\2\66\u00d7\3\2\2\28\u00d9\3\2\2\2:\u00e1")
        buf.write("\3\2\2\2<\u00e9\3\2\2\2>\u00ed\3\2\2\2@\u00f0\3\2\2\2")
        buf.write("B\u00f4\3\2\2\2D\u00f6\3\2\2\2F\u00f8\3\2\2\2HI\5\4\3")
        buf.write("\2IO\7\33\2\2JK\5\4\3\2KL\7\33\2\2LN\3\2\2\2MJ\3\2\2\2")
        buf.write("NQ\3\2\2\2OM\3\2\2\2OP\3\2\2\2P\3\3\2\2\2QO\3\2\2\2RS")
        buf.write("\5\6\4\2S\5\3\2\2\2T^\5\b\5\2U^\5\16\b\2V^\5\22\n\2W^")
        buf.write("\5\26\f\2X^\5\32\16\2Y^\5\60\31\2Z^\5\64\33\2[^\5\66\34")
        buf.write("\2\\^\58\35\2]T\3\2\2\2]U\3\2\2\2]V\3\2\2\2]W\3\2\2\2")
        buf.write("]X\3\2\2\2]Y\3\2\2\2]Z\3\2\2\2][\3\2\2\2]\\\3\2\2\2^\7")
        buf.write("\3\2\2\2_`\7\13\2\2`e\5\n\6\2ab\7\32\2\2bd\5\f\7\2ca\3")
        buf.write("\2\2\2dg\3\2\2\2ec\3\2\2\2ef\3\2\2\2f\t\3\2\2\2ge\3\2")
        buf.write("\2\2hi\7\r\2\2ij\7\34\2\2jk\5> \2k\13\3\2\2\2lm\7\16\2")
        buf.write("\2mn\7\34\2\2n|\5F$\2op\7\7\2\2pq\7\34\2\2q|\5@!\2rs\7")
        buf.write("\17\2\2st\7\34\2\2t|\5@!\2uv\7\20\2\2vw\7\34\2\2w|\5>")
        buf.write(" \2xy\7\21\2\2yz\7\34\2\2z|\5F$\2{l\3\2\2\2{o\3\2\2\2")
        buf.write("{r\3\2\2\2{u\3\2\2\2{x\3\2\2\2|\r\3\2\2\2}~\7\22\2\2~")
        buf.write("\u0083\5\20\t\2\177\u0080\7\32\2\2\u0080\u0082\5\f\7\2")
        buf.write("\u0081\177\3\2\2\2\u0082\u0085\3\2\2\2\u0083\u0081\3\2")
        buf.write("\2\2\u0083\u0084\3\2\2\2\u0084\17\3\2\2\2\u0085\u0083")
        buf.write("\3\2\2\2\u0086\u0087\7\f\2\2\u0087\u0088\7\34\2\2\u0088")
        buf.write("\u0089\5@!\2\u0089\u008a\7\32\2\2\u008a\u008b\7\r\2\2")
        buf.write("\u008b\u008c\7\34\2\2\u008c\u008d\5> \2\u008d\21\3\2\2")
        buf.write("\2\u008e\u008f\7\23\2\2\u008f\u0090\5\24\13\2\u0090\23")
        buf.write("\3\2\2\2\u0091\u0092\7\n\2\2\u0092\u0093\7\34\2\2\u0093")
        buf.write("\u0094\5@!\2\u0094\25\3\2\2\2\u0095\u0096\7\25\2\2\u0096")
        buf.write("\u0097\5\30\r\2\u0097\27\3\2\2\2\u0098\u0099\7\n\2\2\u0099")
        buf.write("\u009a\7\34\2\2\u009a\u009b\5@!\2\u009b\31\3\2\2\2\u009c")
        buf.write("\u009d\7\26\2\2\u009d\u009e\5\34\17\2\u009e\33\3\2\2\2")
        buf.write("\u009f\u00a0\5\36\20\2\u00a0\u00a1\7\32\2\2\u00a1\u00a2")
        buf.write("\5\b\5\2\u00a2\35\3\2\2\2\u00a3\u00a4\5 \21\2\u00a4\u00a5")
        buf.write("\7\32\2\2\u00a5\u00a6\5\"\22\2\u00a6\u00a7\7\32\2\2\u00a7")
        buf.write("\u00a8\5$\23\2\u00a8\u00a9\7\32\2\2\u00a9\u00aa\5&\24")
        buf.write("\2\u00aa\37\3\2\2\2\u00ab\u00ac\7 \2\2\u00ac\u00ad\7\34")
        buf.write("\2\2\u00ad\u00ae\5.\30\2\u00ae!\3\2\2\2\u00af\u00b0\7")
        buf.write("!\2\2\u00b0\u00b1\7\34\2\2\u00b1\u00b2\5,\27\2\u00b2#")
        buf.write("\3\2\2\2\u00b3\u00b4\7&\2\2\u00b4\u00b5\7\34\2\2\u00b5")
        buf.write("\u00b6\5*\26\2\u00b6%\3\2\2\2\u00b7\u00b8\7\"\2\2\u00b8")
        buf.write("\u00b9\7\34\2\2\u00b9\u00ba\5(\25\2\u00ba\'\3\2\2\2\u00bb")
        buf.write("\u00bc\t\2\2\2\u00bc)\3\2\2\2\u00bd\u00be\t\3\2\2\u00be")
        buf.write("+\3\2\2\2\u00bf\u00c0\t\4\2\2\u00c0-\3\2\2\2\u00c1\u00c2")
        buf.write("\t\5\2\2\u00c2/\3\2\2\2\u00c3\u00c4\7\24\2\2\u00c4\u00c5")
        buf.write("\5\62\32\2\u00c5\61\3\2\2\2\u00c6\u00c7\7\n\2\2\u00c7")
        buf.write("\u00c8\7\34\2\2\u00c8\u00c9\5@!\2\u00c9\u00ca\7\32\2\2")
        buf.write("\u00ca\u00cb\7\31\2\2\u00cb\u00cc\7\34\2\2\u00cc\u00cd")
        buf.write("\5> \2\u00cd\63\3\2\2\2\u00ce\u00cf\7\'\2\2\u00cf\u00d4")
        buf.write("\5<\37\2\u00d0\u00d1\7\32\2\2\u00d1\u00d3\5<\37\2\u00d2")
        buf.write("\u00d0\3\2\2\2\u00d3\u00d6\3\2\2\2\u00d4\u00d2\3\2\2\2")
        buf.write("\u00d4\u00d5\3\2\2\2\u00d5\65\3\2\2\2\u00d6\u00d4\3\2")
        buf.write("\2\2\u00d7\u00d8\7\36\2\2\u00d8\67\3\2\2\2\u00d9\u00da")
        buf.write("\7$\2\2\u00da\u00dd\5:\36\2\u00db\u00dc\7\32\2\2\u00dc")
        buf.write("\u00de\5<\37\2\u00dd\u00db\3\2\2\2\u00de\u00df\3\2\2\2")
        buf.write("\u00df\u00dd\3\2\2\2\u00df\u00e0\3\2\2\2\u00e09\3\2\2")
        buf.write("\2\u00e1\u00e2\7\37\2\2\u00e2\u00e3\7\34\2\2\u00e3\u00e4")
        buf.write("\5@!\2\u00e4\u00e5\7\32\2\2\u00e5\u00e6\7#\2\2\u00e6\u00e7")
        buf.write("\7\34\2\2\u00e7\u00e8\5> \2\u00e8;\3\2\2\2\u00e9\u00ea")
        buf.write("\7\35\2\2\u00ea\u00eb\7\34\2\2\u00eb\u00ec\5> \2\u00ec")
        buf.write("=\3\2\2\2\u00ed\u00ee\7\5\2\2\u00ee?\3\2\2\2\u00ef\u00f1")
        buf.write("\5B\"\2\u00f0\u00ef\3\2\2\2\u00f0\u00f1\3\2\2\2\u00f1")
        buf.write("\u00f2\3\2\2\2\u00f2\u00f3\5D#\2\u00f3A\3\2\2\2\u00f4")
        buf.write("\u00f5\t\6\2\2\u00f5C\3\2\2\2\u00f6\u00f7\t\7\2\2\u00f7")
        buf.write("E\3\2\2\2\u00f8\u00f9\t\b\2\2\u00f9G\3\2\2\2\nO]e{\u0083")
        buf.write("\u00d4\u00df\u00f0")
        return buf.getvalue()


class dslParser ( Parser ):

    grammarFileName = "dsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'+'", "'-'", "<INVALID>", "<INVALID>", 
                     "'lat'", "'True'", "'False'", "'id'", "'tweet'", "'in_reply_to_status_id'", 
                     "'status'", "'possibly_sensitive'", "'long'", "'place_id'", 
                     "'display_coordinates'", "'reply'", "'retweet'", "'direct_message'", 
                     "'favourite'", "'schedule'", "'date'", "'time'", "'text'", 
                     "','", "';'", "':'", "'keyword'", "'follow_all_followers'", 
                     "'automate_time_minutes'", "'minute'", "'hour'", "'month'", 
                     "'response'", "'automate_reply_to_mentions'", "<INVALID>", 
                     "'day_of_month'", "'automate_favourites_retweets'", 
                     "'0'", "'1'", "'2'", "'3'", "'4'", "'5'", "'6'", "'7'", 
                     "'8'", "'9'", "'00'", "'01'", "'02'", "'03'", "'04'", 
                     "'05'", "'06'", "'07'", "'08'", "'09'", "'10'", "'11'", 
                     "'12'", "'13'", "'14'", "'15'", "'16'", "'17'", "'18'", 
                     "'19'", "'20'", "'21'", "'22'", "'23'", "'24'", "'25'", 
                     "'26'", "'27'", "'28'", "'29'", "'30'", "'31'", "'32'", 
                     "'33'", "'34'", "'35'", "'36'", "'37'", "'38'", "'39'", 
                     "'40'", "'41'", "'42'", "'43'", "'44'", "'45'", "'46'", 
                     "'47'", "'48'", "'49'", "'50'", "'51'", "'52'", "'53'", 
                     "'54'", "'55'", "'56'", "'57'", "'58'", "'59'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "StringLiteral", 
                      "UnterminatedStringLiteral", "LAT", "TRUE", "FALSE", 
                      "ID", "TWEET", "REPLY_ID", "STATUS", "POSSIBLY_SENSITIVE", 
                      "LONG", "PLACE_ID", "DISPLAY_COORDINATES", "REPLY", 
                      "RETWEET", "DIRECT_MESSAGE", "FAVOURITE", "SCHEDULE", 
                      "DATE", "TIME", "TEXT", "COMMA", "SEMICOLON", "COLON", 
                      "KEYWORD", "FOLLOWALL", "AUTOMATE_TIME", "MINUTE", 
                      "HOUR", "MONTH", "RESPONSE", "AUTOMATE_REPLY_MENTIONS", 
                      "WS", "DAY_OF_MONTH", "AUTO_FAV_RETWEET", "INT_0", 
                      "INT_1", "INT_2", "INT_3", "INT_4", "INT_5", "INT_6", 
                      "INT_7", "INT_8", "INT_9", "INT_00", "INT_01", "INT_02", 
                      "INT_03", "INT_04", "INT_05", "INT_06", "INT_07", 
                      "INT_08", "INT_09", "INT_10", "INT_11", "INT_12", 
                      "INT_13", "INT_14", "INT_15", "INT_16", "INT_17", 
                      "INT_18", "INT_19", "INT_20", "INT_21", "INT_22", 
                      "INT_23", "INT_24", "INT_25", "INT_26", "INT_27", 
                      "INT_28", "INT_29", "INT_30", "INT_31", "INT_32", 
                      "INT_33", "INT_34", "INT_35", "INT_36", "INT_37", 
                      "INT_38", "INT_39", "INT_40", "INT_41", "INT_42", 
                      "INT_43", "INT_44", "INT_45", "INT_46", "INT_47", 
                      "INT_48", "INT_49", "INT_50", "INT_51", "INT_52", 
                      "INT_53", "INT_54", "INT_55", "INT_56", "INT_57", 
                      "INT_58", "INT_59", "UNSIGNED_INT", "UNSIGNED_FLOAT" ]

    RULE_twitbot = 0
    RULE_stat = 1
    RULE_action = 2
    RULE_tweet = 3
    RULE_tweet_required_parameter = 4
    RULE_tweet_optional_parameters = 5
    RULE_reply = 6
    RULE_reply_required_parameters = 7
    RULE_retweet = 8
    RULE_retweet_required_parameter = 9
    RULE_favourite = 10
    RULE_favourite_required_parameter = 11
    RULE_scheduleTweet = 12
    RULE_schedule_tweet_required_parameter = 13
    RULE_date_time_parameter = 14
    RULE_minute = 15
    RULE_hour = 16
    RULE_day_of_month = 17
    RULE_month = 18
    RULE_numeric_month = 19
    RULE_numeric_day = 20
    RULE_numeric_hour = 21
    RULE_numeric_minute = 22
    RULE_directMessage = 23
    RULE_direct_message_required_parameters = 24
    RULE_autoFavouriteRetweet = 25
    RULE_autoFollowFollowers = 26
    RULE_autoReplyMentions = 27
    RULE_automateReplyParameter = 28
    RULE_keyword = 29
    RULE_stringValue = 30
    RULE_number = 31
    RULE_unary_operator = 32
    RULE_unsigned_number = 33
    RULE_boolean = 34

    ruleNames =  [ "twitbot", "stat", "action", "tweet", "tweet_required_parameter", 
                   "tweet_optional_parameters", "reply", "reply_required_parameters", 
                   "retweet", "retweet_required_parameter", "favourite", 
                   "favourite_required_parameter", "scheduleTweet", "schedule_tweet_required_parameter", 
                   "date_time_parameter", "minute", "hour", "day_of_month", 
                   "month", "numeric_month", "numeric_day", "numeric_hour", 
                   "numeric_minute", "directMessage", "direct_message_required_parameters", 
                   "autoFavouriteRetweet", "autoFollowFollowers", "autoReplyMentions", 
                   "automateReplyParameter", "keyword", "stringValue", "number", 
                   "unary_operator", "unsigned_number", "boolean" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    StringLiteral=3
    UnterminatedStringLiteral=4
    LAT=5
    TRUE=6
    FALSE=7
    ID=8
    TWEET=9
    REPLY_ID=10
    STATUS=11
    POSSIBLY_SENSITIVE=12
    LONG=13
    PLACE_ID=14
    DISPLAY_COORDINATES=15
    REPLY=16
    RETWEET=17
    DIRECT_MESSAGE=18
    FAVOURITE=19
    SCHEDULE=20
    DATE=21
    TIME=22
    TEXT=23
    COMMA=24
    SEMICOLON=25
    COLON=26
    KEYWORD=27
    FOLLOWALL=28
    AUTOMATE_TIME=29
    MINUTE=30
    HOUR=31
    MONTH=32
    RESPONSE=33
    AUTOMATE_REPLY_MENTIONS=34
    WS=35
    DAY_OF_MONTH=36
    AUTO_FAV_RETWEET=37
    INT_0=38
    INT_1=39
    INT_2=40
    INT_3=41
    INT_4=42
    INT_5=43
    INT_6=44
    INT_7=45
    INT_8=46
    INT_9=47
    INT_00=48
    INT_01=49
    INT_02=50
    INT_03=51
    INT_04=52
    INT_05=53
    INT_06=54
    INT_07=55
    INT_08=56
    INT_09=57
    INT_10=58
    INT_11=59
    INT_12=60
    INT_13=61
    INT_14=62
    INT_15=63
    INT_16=64
    INT_17=65
    INT_18=66
    INT_19=67
    INT_20=68
    INT_21=69
    INT_22=70
    INT_23=71
    INT_24=72
    INT_25=73
    INT_26=74
    INT_27=75
    INT_28=76
    INT_29=77
    INT_30=78
    INT_31=79
    INT_32=80
    INT_33=81
    INT_34=82
    INT_35=83
    INT_36=84
    INT_37=85
    INT_38=86
    INT_39=87
    INT_40=88
    INT_41=89
    INT_42=90
    INT_43=91
    INT_44=92
    INT_45=93
    INT_46=94
    INT_47=95
    INT_48=96
    INT_49=97
    INT_50=98
    INT_51=99
    INT_52=100
    INT_53=101
    INT_54=102
    INT_55=103
    INT_56=104
    INT_57=105
    INT_58=106
    INT_59=107
    UNSIGNED_INT=108
    UNSIGNED_FLOAT=109

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class TwitbotContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.StatContext)
            else:
                return self.getTypedRuleContext(dslParser.StatContext,i)


        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.SEMICOLON)
            else:
                return self.getToken(dslParser.SEMICOLON, i)

        def getRuleIndex(self):
            return dslParser.RULE_twitbot

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTwitbot" ):
                listener.enterTwitbot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTwitbot" ):
                listener.exitTwitbot(self)




    def twitbot(self):

        localctx = dslParser.TwitbotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_twitbot)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 70
            self.stat()
            self.state = 71
            self.match(dslParser.SEMICOLON)
            self.state = 77
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << dslParser.TWEET) | (1 << dslParser.REPLY) | (1 << dslParser.RETWEET) | (1 << dslParser.DIRECT_MESSAGE) | (1 << dslParser.FAVOURITE) | (1 << dslParser.SCHEDULE) | (1 << dslParser.FOLLOWALL) | (1 << dslParser.AUTOMATE_REPLY_MENTIONS) | (1 << dslParser.AUTO_FAV_RETWEET))) != 0):
                self.state = 72
                self.stat()
                self.state = 73
                self.match(dslParser.SEMICOLON)
                self.state = 79
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action(self):
            return self.getTypedRuleContext(dslParser.ActionContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_stat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat" ):
                listener.enterStat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat" ):
                listener.exitStat(self)




    def stat(self):

        localctx = dslParser.StatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_stat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 80
            self.action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tweet(self):
            return self.getTypedRuleContext(dslParser.TweetContext,0)


        def reply(self):
            return self.getTypedRuleContext(dslParser.ReplyContext,0)


        def retweet(self):
            return self.getTypedRuleContext(dslParser.RetweetContext,0)


        def favourite(self):
            return self.getTypedRuleContext(dslParser.FavouriteContext,0)


        def scheduleTweet(self):
            return self.getTypedRuleContext(dslParser.ScheduleTweetContext,0)


        def directMessage(self):
            return self.getTypedRuleContext(dslParser.DirectMessageContext,0)


        def autoFavouriteRetweet(self):
            return self.getTypedRuleContext(dslParser.AutoFavouriteRetweetContext,0)


        def autoFollowFollowers(self):
            return self.getTypedRuleContext(dslParser.AutoFollowFollowersContext,0)


        def autoReplyMentions(self):
            return self.getTypedRuleContext(dslParser.AutoReplyMentionsContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)




    def action(self):

        localctx = dslParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_action)
        try:
            self.state = 91
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dslParser.TWEET]:
                self.enterOuterAlt(localctx, 1)
                self.state = 82
                self.tweet()
                pass
            elif token in [dslParser.REPLY]:
                self.enterOuterAlt(localctx, 2)
                self.state = 83
                self.reply()
                pass
            elif token in [dslParser.RETWEET]:
                self.enterOuterAlt(localctx, 3)
                self.state = 84
                self.retweet()
                pass
            elif token in [dslParser.FAVOURITE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 85
                self.favourite()
                pass
            elif token in [dslParser.SCHEDULE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 86
                self.scheduleTweet()
                pass
            elif token in [dslParser.DIRECT_MESSAGE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 87
                self.directMessage()
                pass
            elif token in [dslParser.AUTO_FAV_RETWEET]:
                self.enterOuterAlt(localctx, 7)
                self.state = 88
                self.autoFavouriteRetweet()
                pass
            elif token in [dslParser.FOLLOWALL]:
                self.enterOuterAlt(localctx, 8)
                self.state = 89
                self.autoFollowFollowers()
                pass
            elif token in [dslParser.AUTOMATE_REPLY_MENTIONS]:
                self.enterOuterAlt(localctx, 9)
                self.state = 90
                self.autoReplyMentions()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TWEET(self):
            return self.getToken(dslParser.TWEET, 0)

        def tweet_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Tweet_required_parameterContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def tweet_optional_parameters(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.Tweet_optional_parametersContext)
            else:
                return self.getTypedRuleContext(dslParser.Tweet_optional_parametersContext,i)


        def getRuleIndex(self):
            return dslParser.RULE_tweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweet" ):
                listener.enterTweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweet" ):
                listener.exitTweet(self)




    def tweet(self):

        localctx = dslParser.TweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_tweet)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 93
            self.match(dslParser.TWEET)
            self.state = 94
            self.tweet_required_parameter()
            self.state = 99
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dslParser.COMMA:
                self.state = 95
                self.match(dslParser.COMMA)
                self.state = 96
                self.tweet_optional_parameters()
                self.state = 101
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tweet_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STATUS(self):
            return self.getToken(dslParser.STATUS, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_tweet_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweet_required_parameter" ):
                listener.enterTweet_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweet_required_parameter" ):
                listener.exitTweet_required_parameter(self)




    def tweet_required_parameter(self):

        localctx = dslParser.Tweet_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_tweet_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 102
            self.match(dslParser.STATUS)
            self.state = 103
            self.match(dslParser.COLON)
            self.state = 104
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tweet_optional_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POSSIBLY_SENSITIVE(self):
            return self.getToken(dslParser.POSSIBLY_SENSITIVE, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def boolean(self):
            return self.getTypedRuleContext(dslParser.BooleanContext,0)


        def LAT(self):
            return self.getToken(dslParser.LAT, 0)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def LONG(self):
            return self.getToken(dslParser.LONG, 0)

        def PLACE_ID(self):
            return self.getToken(dslParser.PLACE_ID, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def DISPLAY_COORDINATES(self):
            return self.getToken(dslParser.DISPLAY_COORDINATES, 0)

        def getRuleIndex(self):
            return dslParser.RULE_tweet_optional_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweet_optional_parameters" ):
                listener.enterTweet_optional_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweet_optional_parameters" ):
                listener.exitTweet_optional_parameters(self)




    def tweet_optional_parameters(self):

        localctx = dslParser.Tweet_optional_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_tweet_optional_parameters)
        try:
            self.state = 121
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dslParser.POSSIBLY_SENSITIVE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 106
                self.match(dslParser.POSSIBLY_SENSITIVE)
                self.state = 107
                self.match(dslParser.COLON)
                self.state = 108
                self.boolean()
                pass
            elif token in [dslParser.LAT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 109
                self.match(dslParser.LAT)
                self.state = 110
                self.match(dslParser.COLON)
                self.state = 111
                self.number()
                pass
            elif token in [dslParser.LONG]:
                self.enterOuterAlt(localctx, 3)
                self.state = 112
                self.match(dslParser.LONG)
                self.state = 113
                self.match(dslParser.COLON)
                self.state = 114
                self.number()
                pass
            elif token in [dslParser.PLACE_ID]:
                self.enterOuterAlt(localctx, 4)
                self.state = 115
                self.match(dslParser.PLACE_ID)
                self.state = 116
                self.match(dslParser.COLON)
                self.state = 117
                self.stringValue()
                pass
            elif token in [dslParser.DISPLAY_COORDINATES]:
                self.enterOuterAlt(localctx, 5)
                self.state = 118
                self.match(dslParser.DISPLAY_COORDINATES)
                self.state = 119
                self.match(dslParser.COLON)
                self.state = 120
                self.boolean()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPLY(self):
            return self.getToken(dslParser.REPLY, 0)

        def reply_required_parameters(self):
            return self.getTypedRuleContext(dslParser.Reply_required_parametersContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def tweet_optional_parameters(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.Tweet_optional_parametersContext)
            else:
                return self.getTypedRuleContext(dslParser.Tweet_optional_parametersContext,i)


        def getRuleIndex(self):
            return dslParser.RULE_reply

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReply" ):
                listener.enterReply(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReply" ):
                listener.exitReply(self)




    def reply(self):

        localctx = dslParser.ReplyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_reply)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self.match(dslParser.REPLY)
            self.state = 124
            self.reply_required_parameters()
            self.state = 129
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dslParser.COMMA:
                self.state = 125
                self.match(dslParser.COMMA)
                self.state = 126
                self.tweet_optional_parameters()
                self.state = 131
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reply_required_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPLY_ID(self):
            return self.getToken(dslParser.REPLY_ID, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COLON)
            else:
                return self.getToken(dslParser.COLON, i)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def STATUS(self):
            return self.getToken(dslParser.STATUS, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_reply_required_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReply_required_parameters" ):
                listener.enterReply_required_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReply_required_parameters" ):
                listener.exitReply_required_parameters(self)




    def reply_required_parameters(self):

        localctx = dslParser.Reply_required_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_reply_required_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self.match(dslParser.REPLY_ID)
            self.state = 133
            self.match(dslParser.COLON)
            self.state = 134
            self.number()
            self.state = 135
            self.match(dslParser.COMMA)
            self.state = 136
            self.match(dslParser.STATUS)
            self.state = 137
            self.match(dslParser.COLON)
            self.state = 138
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RetweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETWEET(self):
            return self.getToken(dslParser.RETWEET, 0)

        def retweet_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Retweet_required_parameterContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_retweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRetweet" ):
                listener.enterRetweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRetweet" ):
                listener.exitRetweet(self)




    def retweet(self):

        localctx = dslParser.RetweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_retweet)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self.match(dslParser.RETWEET)
            self.state = 141
            self.retweet_required_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Retweet_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(dslParser.ID, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_retweet_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRetweet_required_parameter" ):
                listener.enterRetweet_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRetweet_required_parameter" ):
                listener.exitRetweet_required_parameter(self)




    def retweet_required_parameter(self):

        localctx = dslParser.Retweet_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_retweet_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            self.match(dslParser.ID)
            self.state = 144
            self.match(dslParser.COLON)
            self.state = 145
            self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FavouriteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FAVOURITE(self):
            return self.getToken(dslParser.FAVOURITE, 0)

        def favourite_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Favourite_required_parameterContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_favourite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFavourite" ):
                listener.enterFavourite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFavourite" ):
                listener.exitFavourite(self)




    def favourite(self):

        localctx = dslParser.FavouriteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_favourite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 147
            self.match(dslParser.FAVOURITE)
            self.state = 148
            self.favourite_required_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Favourite_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(dslParser.ID, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_favourite_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFavourite_required_parameter" ):
                listener.enterFavourite_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFavourite_required_parameter" ):
                listener.exitFavourite_required_parameter(self)




    def favourite_required_parameter(self):

        localctx = dslParser.Favourite_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_favourite_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 150
            self.match(dslParser.ID)
            self.state = 151
            self.match(dslParser.COLON)
            self.state = 152
            self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScheduleTweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCHEDULE(self):
            return self.getToken(dslParser.SCHEDULE, 0)

        def schedule_tweet_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Schedule_tweet_required_parameterContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_scheduleTweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScheduleTweet" ):
                listener.enterScheduleTweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScheduleTweet" ):
                listener.exitScheduleTweet(self)




    def scheduleTweet(self):

        localctx = dslParser.ScheduleTweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_scheduleTweet)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.match(dslParser.SCHEDULE)
            self.state = 155
            self.schedule_tweet_required_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Schedule_tweet_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def date_time_parameter(self):
            return self.getTypedRuleContext(dslParser.Date_time_parameterContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def tweet(self):
            return self.getTypedRuleContext(dslParser.TweetContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_schedule_tweet_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchedule_tweet_required_parameter" ):
                listener.enterSchedule_tweet_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchedule_tweet_required_parameter" ):
                listener.exitSchedule_tweet_required_parameter(self)




    def schedule_tweet_required_parameter(self):

        localctx = dslParser.Schedule_tweet_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_schedule_tweet_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 157
            self.date_time_parameter()
            self.state = 158
            self.match(dslParser.COMMA)
            self.state = 159
            self.tweet()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Date_time_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def minute(self):
            return self.getTypedRuleContext(dslParser.MinuteContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def hour(self):
            return self.getTypedRuleContext(dslParser.HourContext,0)


        def day_of_month(self):
            return self.getTypedRuleContext(dslParser.Day_of_monthContext,0)


        def month(self):
            return self.getTypedRuleContext(dslParser.MonthContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_date_time_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate_time_parameter" ):
                listener.enterDate_time_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate_time_parameter" ):
                listener.exitDate_time_parameter(self)




    def date_time_parameter(self):

        localctx = dslParser.Date_time_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_date_time_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 161
            self.minute()
            self.state = 162
            self.match(dslParser.COMMA)
            self.state = 163
            self.hour()
            self.state = 164
            self.match(dslParser.COMMA)
            self.state = 165
            self.day_of_month()
            self.state = 166
            self.match(dslParser.COMMA)
            self.state = 167
            self.month()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MinuteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUTE(self):
            return self.getToken(dslParser.MINUTE, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def numeric_minute(self):
            return self.getTypedRuleContext(dslParser.Numeric_minuteContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_minute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMinute" ):
                listener.enterMinute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMinute" ):
                listener.exitMinute(self)




    def minute(self):

        localctx = dslParser.MinuteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_minute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 169
            self.match(dslParser.MINUTE)
            self.state = 170
            self.match(dslParser.COLON)
            self.state = 171
            self.numeric_minute()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HourContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HOUR(self):
            return self.getToken(dslParser.HOUR, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def numeric_hour(self):
            return self.getTypedRuleContext(dslParser.Numeric_hourContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_hour

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHour" ):
                listener.enterHour(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHour" ):
                listener.exitHour(self)




    def hour(self):

        localctx = dslParser.HourContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_hour)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self.match(dslParser.HOUR)
            self.state = 174
            self.match(dslParser.COLON)
            self.state = 175
            self.numeric_hour()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Day_of_monthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DAY_OF_MONTH(self):
            return self.getToken(dslParser.DAY_OF_MONTH, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def numeric_day(self):
            return self.getTypedRuleContext(dslParser.Numeric_dayContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_day_of_month

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDay_of_month" ):
                listener.enterDay_of_month(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDay_of_month" ):
                listener.exitDay_of_month(self)




    def day_of_month(self):

        localctx = dslParser.Day_of_monthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_day_of_month)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            self.match(dslParser.DAY_OF_MONTH)
            self.state = 178
            self.match(dslParser.COLON)
            self.state = 179
            self.numeric_day()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MonthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MONTH(self):
            return self.getToken(dslParser.MONTH, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def numeric_month(self):
            return self.getTypedRuleContext(dslParser.Numeric_monthContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_month

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMonth" ):
                listener.enterMonth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMonth" ):
                listener.exitMonth(self)




    def month(self):

        localctx = dslParser.MonthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_month)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            self.match(dslParser.MONTH)
            self.state = 182
            self.match(dslParser.COLON)
            self.state = 183
            self.numeric_month()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_monthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_1(self):
            return self.getToken(dslParser.INT_1, 0)

        def INT_2(self):
            return self.getToken(dslParser.INT_2, 0)

        def INT_3(self):
            return self.getToken(dslParser.INT_3, 0)

        def INT_4(self):
            return self.getToken(dslParser.INT_4, 0)

        def INT_5(self):
            return self.getToken(dslParser.INT_5, 0)

        def INT_6(self):
            return self.getToken(dslParser.INT_6, 0)

        def INT_7(self):
            return self.getToken(dslParser.INT_7, 0)

        def INT_8(self):
            return self.getToken(dslParser.INT_8, 0)

        def INT_9(self):
            return self.getToken(dslParser.INT_9, 0)

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_month

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_month" ):
                listener.enterNumeric_month(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_month" ):
                listener.exitNumeric_month(self)




    def numeric_month(self):

        localctx = dslParser.Numeric_monthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_numeric_month)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << dslParser.INT_1) | (1 << dslParser.INT_2) | (1 << dslParser.INT_3) | (1 << dslParser.INT_4) | (1 << dslParser.INT_5) | (1 << dslParser.INT_6) | (1 << dslParser.INT_7) | (1 << dslParser.INT_8) | (1 << dslParser.INT_9) | (1 << dslParser.INT_01) | (1 << dslParser.INT_02) | (1 << dslParser.INT_03) | (1 << dslParser.INT_04) | (1 << dslParser.INT_05) | (1 << dslParser.INT_06) | (1 << dslParser.INT_07) | (1 << dslParser.INT_08) | (1 << dslParser.INT_09) | (1 << dslParser.INT_10) | (1 << dslParser.INT_11) | (1 << dslParser.INT_12))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_dayContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_1(self):
            return self.getToken(dslParser.INT_1, 0)

        def INT_2(self):
            return self.getToken(dslParser.INT_2, 0)

        def INT_3(self):
            return self.getToken(dslParser.INT_3, 0)

        def INT_4(self):
            return self.getToken(dslParser.INT_4, 0)

        def INT_5(self):
            return self.getToken(dslParser.INT_5, 0)

        def INT_6(self):
            return self.getToken(dslParser.INT_6, 0)

        def INT_7(self):
            return self.getToken(dslParser.INT_7, 0)

        def INT_8(self):
            return self.getToken(dslParser.INT_8, 0)

        def INT_9(self):
            return self.getToken(dslParser.INT_9, 0)

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def INT_13(self):
            return self.getToken(dslParser.INT_13, 0)

        def INT_14(self):
            return self.getToken(dslParser.INT_14, 0)

        def INT_15(self):
            return self.getToken(dslParser.INT_15, 0)

        def INT_16(self):
            return self.getToken(dslParser.INT_16, 0)

        def INT_17(self):
            return self.getToken(dslParser.INT_17, 0)

        def INT_18(self):
            return self.getToken(dslParser.INT_18, 0)

        def INT_19(self):
            return self.getToken(dslParser.INT_19, 0)

        def INT_20(self):
            return self.getToken(dslParser.INT_20, 0)

        def INT_21(self):
            return self.getToken(dslParser.INT_21, 0)

        def INT_22(self):
            return self.getToken(dslParser.INT_22, 0)

        def INT_23(self):
            return self.getToken(dslParser.INT_23, 0)

        def INT_24(self):
            return self.getToken(dslParser.INT_24, 0)

        def INT_25(self):
            return self.getToken(dslParser.INT_25, 0)

        def INT_26(self):
            return self.getToken(dslParser.INT_26, 0)

        def INT_27(self):
            return self.getToken(dslParser.INT_27, 0)

        def INT_28(self):
            return self.getToken(dslParser.INT_28, 0)

        def INT_29(self):
            return self.getToken(dslParser.INT_29, 0)

        def INT_30(self):
            return self.getToken(dslParser.INT_30, 0)

        def INT_31(self):
            return self.getToken(dslParser.INT_31, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_day

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_day" ):
                listener.enterNumeric_day(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_day" ):
                listener.exitNumeric_day(self)




    def numeric_day(self):

        localctx = dslParser.Numeric_dayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_numeric_day)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 187
            _la = self._input.LA(1)
            if not(((((_la - 39)) & ~0x3f) == 0 and ((1 << (_la - 39)) & ((1 << (dslParser.INT_1 - 39)) | (1 << (dslParser.INT_2 - 39)) | (1 << (dslParser.INT_3 - 39)) | (1 << (dslParser.INT_4 - 39)) | (1 << (dslParser.INT_5 - 39)) | (1 << (dslParser.INT_6 - 39)) | (1 << (dslParser.INT_7 - 39)) | (1 << (dslParser.INT_8 - 39)) | (1 << (dslParser.INT_9 - 39)) | (1 << (dslParser.INT_01 - 39)) | (1 << (dslParser.INT_02 - 39)) | (1 << (dslParser.INT_03 - 39)) | (1 << (dslParser.INT_04 - 39)) | (1 << (dslParser.INT_05 - 39)) | (1 << (dslParser.INT_06 - 39)) | (1 << (dslParser.INT_07 - 39)) | (1 << (dslParser.INT_08 - 39)) | (1 << (dslParser.INT_09 - 39)) | (1 << (dslParser.INT_10 - 39)) | (1 << (dslParser.INT_11 - 39)) | (1 << (dslParser.INT_12 - 39)) | (1 << (dslParser.INT_13 - 39)) | (1 << (dslParser.INT_14 - 39)) | (1 << (dslParser.INT_15 - 39)) | (1 << (dslParser.INT_16 - 39)) | (1 << (dslParser.INT_17 - 39)) | (1 << (dslParser.INT_18 - 39)) | (1 << (dslParser.INT_19 - 39)) | (1 << (dslParser.INT_20 - 39)) | (1 << (dslParser.INT_21 - 39)) | (1 << (dslParser.INT_22 - 39)) | (1 << (dslParser.INT_23 - 39)) | (1 << (dslParser.INT_24 - 39)) | (1 << (dslParser.INT_25 - 39)) | (1 << (dslParser.INT_26 - 39)) | (1 << (dslParser.INT_27 - 39)) | (1 << (dslParser.INT_28 - 39)) | (1 << (dslParser.INT_29 - 39)) | (1 << (dslParser.INT_30 - 39)) | (1 << (dslParser.INT_31 - 39)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_hourContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def INT_13(self):
            return self.getToken(dslParser.INT_13, 0)

        def INT_14(self):
            return self.getToken(dslParser.INT_14, 0)

        def INT_15(self):
            return self.getToken(dslParser.INT_15, 0)

        def INT_16(self):
            return self.getToken(dslParser.INT_16, 0)

        def INT_17(self):
            return self.getToken(dslParser.INT_17, 0)

        def INT_18(self):
            return self.getToken(dslParser.INT_18, 0)

        def INT_19(self):
            return self.getToken(dslParser.INT_19, 0)

        def INT_20(self):
            return self.getToken(dslParser.INT_20, 0)

        def INT_21(self):
            return self.getToken(dslParser.INT_21, 0)

        def INT_22(self):
            return self.getToken(dslParser.INT_22, 0)

        def INT_23(self):
            return self.getToken(dslParser.INT_23, 0)

        def INT_24(self):
            return self.getToken(dslParser.INT_24, 0)

        def INT_00(self):
            return self.getToken(dslParser.INT_00, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_hour

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_hour" ):
                listener.enterNumeric_hour(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_hour" ):
                listener.exitNumeric_hour(self)




    def numeric_hour(self):

        localctx = dslParser.Numeric_hourContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_numeric_hour)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 189
            _la = self._input.LA(1)
            if not(((((_la - 48)) & ~0x3f) == 0 and ((1 << (_la - 48)) & ((1 << (dslParser.INT_00 - 48)) | (1 << (dslParser.INT_01 - 48)) | (1 << (dslParser.INT_02 - 48)) | (1 << (dslParser.INT_03 - 48)) | (1 << (dslParser.INT_04 - 48)) | (1 << (dslParser.INT_05 - 48)) | (1 << (dslParser.INT_06 - 48)) | (1 << (dslParser.INT_07 - 48)) | (1 << (dslParser.INT_08 - 48)) | (1 << (dslParser.INT_09 - 48)) | (1 << (dslParser.INT_10 - 48)) | (1 << (dslParser.INT_11 - 48)) | (1 << (dslParser.INT_12 - 48)) | (1 << (dslParser.INT_13 - 48)) | (1 << (dslParser.INT_14 - 48)) | (1 << (dslParser.INT_15 - 48)) | (1 << (dslParser.INT_16 - 48)) | (1 << (dslParser.INT_17 - 48)) | (1 << (dslParser.INT_18 - 48)) | (1 << (dslParser.INT_19 - 48)) | (1 << (dslParser.INT_20 - 48)) | (1 << (dslParser.INT_21 - 48)) | (1 << (dslParser.INT_22 - 48)) | (1 << (dslParser.INT_23 - 48)) | (1 << (dslParser.INT_24 - 48)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_minuteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def INT_13(self):
            return self.getToken(dslParser.INT_13, 0)

        def INT_14(self):
            return self.getToken(dslParser.INT_14, 0)

        def INT_15(self):
            return self.getToken(dslParser.INT_15, 0)

        def INT_16(self):
            return self.getToken(dslParser.INT_16, 0)

        def INT_17(self):
            return self.getToken(dslParser.INT_17, 0)

        def INT_18(self):
            return self.getToken(dslParser.INT_18, 0)

        def INT_19(self):
            return self.getToken(dslParser.INT_19, 0)

        def INT_20(self):
            return self.getToken(dslParser.INT_20, 0)

        def INT_21(self):
            return self.getToken(dslParser.INT_21, 0)

        def INT_22(self):
            return self.getToken(dslParser.INT_22, 0)

        def INT_23(self):
            return self.getToken(dslParser.INT_23, 0)

        def INT_24(self):
            return self.getToken(dslParser.INT_24, 0)

        def INT_25(self):
            return self.getToken(dslParser.INT_25, 0)

        def INT_26(self):
            return self.getToken(dslParser.INT_26, 0)

        def INT_27(self):
            return self.getToken(dslParser.INT_27, 0)

        def INT_28(self):
            return self.getToken(dslParser.INT_28, 0)

        def INT_29(self):
            return self.getToken(dslParser.INT_29, 0)

        def INT_30(self):
            return self.getToken(dslParser.INT_30, 0)

        def INT_31(self):
            return self.getToken(dslParser.INT_31, 0)

        def INT_32(self):
            return self.getToken(dslParser.INT_32, 0)

        def INT_33(self):
            return self.getToken(dslParser.INT_33, 0)

        def INT_34(self):
            return self.getToken(dslParser.INT_34, 0)

        def INT_35(self):
            return self.getToken(dslParser.INT_35, 0)

        def INT_36(self):
            return self.getToken(dslParser.INT_36, 0)

        def INT_37(self):
            return self.getToken(dslParser.INT_37, 0)

        def INT_38(self):
            return self.getToken(dslParser.INT_38, 0)

        def INT_39(self):
            return self.getToken(dslParser.INT_39, 0)

        def INT_40(self):
            return self.getToken(dslParser.INT_40, 0)

        def INT_41(self):
            return self.getToken(dslParser.INT_41, 0)

        def INT_42(self):
            return self.getToken(dslParser.INT_42, 0)

        def INT_43(self):
            return self.getToken(dslParser.INT_43, 0)

        def INT_44(self):
            return self.getToken(dslParser.INT_44, 0)

        def INT_45(self):
            return self.getToken(dslParser.INT_45, 0)

        def INT_46(self):
            return self.getToken(dslParser.INT_46, 0)

        def INT_47(self):
            return self.getToken(dslParser.INT_47, 0)

        def INT_48(self):
            return self.getToken(dslParser.INT_48, 0)

        def INT_49(self):
            return self.getToken(dslParser.INT_49, 0)

        def INT_50(self):
            return self.getToken(dslParser.INT_50, 0)

        def INT_51(self):
            return self.getToken(dslParser.INT_51, 0)

        def INT_52(self):
            return self.getToken(dslParser.INT_52, 0)

        def INT_53(self):
            return self.getToken(dslParser.INT_53, 0)

        def INT_54(self):
            return self.getToken(dslParser.INT_54, 0)

        def INT_55(self):
            return self.getToken(dslParser.INT_55, 0)

        def INT_56(self):
            return self.getToken(dslParser.INT_56, 0)

        def INT_57(self):
            return self.getToken(dslParser.INT_57, 0)

        def INT_58(self):
            return self.getToken(dslParser.INT_58, 0)

        def INT_59(self):
            return self.getToken(dslParser.INT_59, 0)

        def INT_00(self):
            return self.getToken(dslParser.INT_00, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_minute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_minute" ):
                listener.enterNumeric_minute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_minute" ):
                listener.exitNumeric_minute(self)




    def numeric_minute(self):

        localctx = dslParser.Numeric_minuteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_numeric_minute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            _la = self._input.LA(1)
            if not(((((_la - 48)) & ~0x3f) == 0 and ((1 << (_la - 48)) & ((1 << (dslParser.INT_00 - 48)) | (1 << (dslParser.INT_01 - 48)) | (1 << (dslParser.INT_02 - 48)) | (1 << (dslParser.INT_03 - 48)) | (1 << (dslParser.INT_04 - 48)) | (1 << (dslParser.INT_05 - 48)) | (1 << (dslParser.INT_06 - 48)) | (1 << (dslParser.INT_07 - 48)) | (1 << (dslParser.INT_08 - 48)) | (1 << (dslParser.INT_09 - 48)) | (1 << (dslParser.INT_10 - 48)) | (1 << (dslParser.INT_11 - 48)) | (1 << (dslParser.INT_12 - 48)) | (1 << (dslParser.INT_13 - 48)) | (1 << (dslParser.INT_14 - 48)) | (1 << (dslParser.INT_15 - 48)) | (1 << (dslParser.INT_16 - 48)) | (1 << (dslParser.INT_17 - 48)) | (1 << (dslParser.INT_18 - 48)) | (1 << (dslParser.INT_19 - 48)) | (1 << (dslParser.INT_20 - 48)) | (1 << (dslParser.INT_21 - 48)) | (1 << (dslParser.INT_22 - 48)) | (1 << (dslParser.INT_23 - 48)) | (1 << (dslParser.INT_24 - 48)) | (1 << (dslParser.INT_25 - 48)) | (1 << (dslParser.INT_26 - 48)) | (1 << (dslParser.INT_27 - 48)) | (1 << (dslParser.INT_28 - 48)) | (1 << (dslParser.INT_29 - 48)) | (1 << (dslParser.INT_30 - 48)) | (1 << (dslParser.INT_31 - 48)) | (1 << (dslParser.INT_32 - 48)) | (1 << (dslParser.INT_33 - 48)) | (1 << (dslParser.INT_34 - 48)) | (1 << (dslParser.INT_35 - 48)) | (1 << (dslParser.INT_36 - 48)) | (1 << (dslParser.INT_37 - 48)) | (1 << (dslParser.INT_38 - 48)) | (1 << (dslParser.INT_39 - 48)) | (1 << (dslParser.INT_40 - 48)) | (1 << (dslParser.INT_41 - 48)) | (1 << (dslParser.INT_42 - 48)) | (1 << (dslParser.INT_43 - 48)) | (1 << (dslParser.INT_44 - 48)) | (1 << (dslParser.INT_45 - 48)) | (1 << (dslParser.INT_46 - 48)) | (1 << (dslParser.INT_47 - 48)) | (1 << (dslParser.INT_48 - 48)) | (1 << (dslParser.INT_49 - 48)) | (1 << (dslParser.INT_50 - 48)) | (1 << (dslParser.INT_51 - 48)) | (1 << (dslParser.INT_52 - 48)) | (1 << (dslParser.INT_53 - 48)) | (1 << (dslParser.INT_54 - 48)) | (1 << (dslParser.INT_55 - 48)) | (1 << (dslParser.INT_56 - 48)) | (1 << (dslParser.INT_57 - 48)) | (1 << (dslParser.INT_58 - 48)) | (1 << (dslParser.INT_59 - 48)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DirectMessageContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIRECT_MESSAGE(self):
            return self.getToken(dslParser.DIRECT_MESSAGE, 0)

        def direct_message_required_parameters(self):
            return self.getTypedRuleContext(dslParser.Direct_message_required_parametersContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_directMessage

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirectMessage" ):
                listener.enterDirectMessage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirectMessage" ):
                listener.exitDirectMessage(self)




    def directMessage(self):

        localctx = dslParser.DirectMessageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_directMessage)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(dslParser.DIRECT_MESSAGE)
            self.state = 194
            self.direct_message_required_parameters()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Direct_message_required_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(dslParser.ID, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COLON)
            else:
                return self.getToken(dslParser.COLON, i)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def TEXT(self):
            return self.getToken(dslParser.TEXT, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_direct_message_required_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirect_message_required_parameters" ):
                listener.enterDirect_message_required_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirect_message_required_parameters" ):
                listener.exitDirect_message_required_parameters(self)




    def direct_message_required_parameters(self):

        localctx = dslParser.Direct_message_required_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_direct_message_required_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196
            self.match(dslParser.ID)
            self.state = 197
            self.match(dslParser.COLON)
            self.state = 198
            self.number()
            self.state = 199
            self.match(dslParser.COMMA)
            self.state = 200
            self.match(dslParser.TEXT)
            self.state = 201
            self.match(dslParser.COLON)
            self.state = 202
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutoFavouriteRetweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AUTO_FAV_RETWEET(self):
            return self.getToken(dslParser.AUTO_FAV_RETWEET, 0)

        def keyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.KeywordContext)
            else:
                return self.getTypedRuleContext(dslParser.KeywordContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def getRuleIndex(self):
            return dslParser.RULE_autoFavouriteRetweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutoFavouriteRetweet" ):
                listener.enterAutoFavouriteRetweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutoFavouriteRetweet" ):
                listener.exitAutoFavouriteRetweet(self)




    def autoFavouriteRetweet(self):

        localctx = dslParser.AutoFavouriteRetweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_autoFavouriteRetweet)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 204
            self.match(dslParser.AUTO_FAV_RETWEET)
            self.state = 205
            self.keyword()
            self.state = 210
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dslParser.COMMA:
                self.state = 206
                self.match(dslParser.COMMA)
                self.state = 207
                self.keyword()
                self.state = 212
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutoFollowFollowersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOLLOWALL(self):
            return self.getToken(dslParser.FOLLOWALL, 0)

        def getRuleIndex(self):
            return dslParser.RULE_autoFollowFollowers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutoFollowFollowers" ):
                listener.enterAutoFollowFollowers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutoFollowFollowers" ):
                listener.exitAutoFollowFollowers(self)




    def autoFollowFollowers(self):

        localctx = dslParser.AutoFollowFollowersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_autoFollowFollowers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self.match(dslParser.FOLLOWALL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutoReplyMentionsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AUTOMATE_REPLY_MENTIONS(self):
            return self.getToken(dslParser.AUTOMATE_REPLY_MENTIONS, 0)

        def automateReplyParameter(self):
            return self.getTypedRuleContext(dslParser.AutomateReplyParameterContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def keyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.KeywordContext)
            else:
                return self.getTypedRuleContext(dslParser.KeywordContext,i)


        def getRuleIndex(self):
            return dslParser.RULE_autoReplyMentions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutoReplyMentions" ):
                listener.enterAutoReplyMentions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutoReplyMentions" ):
                listener.exitAutoReplyMentions(self)




    def autoReplyMentions(self):

        localctx = dslParser.AutoReplyMentionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_autoReplyMentions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 215
            self.match(dslParser.AUTOMATE_REPLY_MENTIONS)
            self.state = 216
            self.automateReplyParameter()
            self.state = 219 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 217
                self.match(dslParser.COMMA)
                self.state = 218
                self.keyword()
                self.state = 221 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==dslParser.COMMA):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutomateReplyParameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AUTOMATE_TIME(self):
            return self.getToken(dslParser.AUTOMATE_TIME, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COLON)
            else:
                return self.getToken(dslParser.COLON, i)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def RESPONSE(self):
            return self.getToken(dslParser.RESPONSE, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_automateReplyParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutomateReplyParameter" ):
                listener.enterAutomateReplyParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutomateReplyParameter" ):
                listener.exitAutomateReplyParameter(self)




    def automateReplyParameter(self):

        localctx = dslParser.AutomateReplyParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_automateReplyParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 223
            self.match(dslParser.AUTOMATE_TIME)
            self.state = 224
            self.match(dslParser.COLON)
            self.state = 225
            self.number()
            self.state = 226
            self.match(dslParser.COMMA)
            self.state = 227
            self.match(dslParser.RESPONSE)
            self.state = 228
            self.match(dslParser.COLON)
            self.state = 229
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeywordContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEYWORD(self):
            return self.getToken(dslParser.KEYWORD, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_keyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyword" ):
                listener.enterKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyword" ):
                listener.exitKeyword(self)




    def keyword(self):

        localctx = dslParser.KeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_keyword)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            self.match(dslParser.KEYWORD)
            self.state = 232
            self.match(dslParser.COLON)
            self.state = 233
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringValueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def StringLiteral(self):
            return self.getToken(dslParser.StringLiteral, 0)

        def getRuleIndex(self):
            return dslParser.RULE_stringValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringValue" ):
                listener.enterStringValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringValue" ):
                listener.exitStringValue(self)




    def stringValue(self):

        localctx = dslParser.StringValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_stringValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 235
            self.match(dslParser.StringLiteral)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unsigned_number(self):
            return self.getTypedRuleContext(dslParser.Unsigned_numberContext,0)


        def unary_operator(self):
            return self.getTypedRuleContext(dslParser.Unary_operatorContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)




    def number(self):

        localctx = dslParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 238
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dslParser.T__0 or _la==dslParser.T__1:
                self.state = 237
                self.unary_operator()


            self.state = 240
            self.unsigned_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unary_operatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return dslParser.RULE_unary_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnary_operator" ):
                listener.enterUnary_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnary_operator" ):
                listener.exitUnary_operator(self)




    def unary_operator(self):

        localctx = dslParser.Unary_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_unary_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 242
            _la = self._input.LA(1)
            if not(_la==dslParser.T__0 or _la==dslParser.T__1):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unsigned_numberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNSIGNED_INT(self):
            return self.getToken(dslParser.UNSIGNED_INT, 0)

        def UNSIGNED_FLOAT(self):
            return self.getToken(dslParser.UNSIGNED_FLOAT, 0)

        def getRuleIndex(self):
            return dslParser.RULE_unsigned_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnsigned_number" ):
                listener.enterUnsigned_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnsigned_number" ):
                listener.exitUnsigned_number(self)




    def unsigned_number(self):

        localctx = dslParser.Unsigned_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_unsigned_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 244
            _la = self._input.LA(1)
            if not(_la==dslParser.UNSIGNED_INT or _la==dslParser.UNSIGNED_FLOAT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(dslParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(dslParser.FALSE, 0)

        def getRuleIndex(self):
            return dslParser.RULE_boolean

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolean" ):
                listener.enterBoolean(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolean" ):
                listener.exitBoolean(self)




    def boolean(self):

        localctx = dslParser.BooleanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_boolean)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 246
            _la = self._input.LA(1)
            if not(_la==dslParser.TRUE or _la==dslParser.FALSE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





