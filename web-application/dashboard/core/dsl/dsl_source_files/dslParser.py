# Generated from dsl.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3k")
        buf.write("\u00fc\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\3\2\3\2\3\2\3\2\3\2\7\2V\n\2\f\2\16\2")
        buf.write("Y\13\2\3\3\3\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4")
        buf.write("f\n\4\3\5\3\5\3\5\3\5\7\5l\n\5\f\5\16\5o\13\5\3\6\3\6")
        buf.write("\3\6\3\6\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3")
        buf.write("\7\3\7\3\7\3\7\5\7\u0084\n\7\3\b\3\b\3\b\3\b\7\b\u008a")
        buf.write("\n\b\f\b\16\b\u008d\13\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3")
        buf.write("\t\3\n\3\n\3\n\3\13\3\13\3\13\3\13\3\f\3\f\3\f\3\r\3\r")
        buf.write("\3\r\3\r\3\16\3\16\3\16\3\17\3\17\3\17\3\17\3\20\3\20")
        buf.write("\3\20\3\20\3\20\3\20\3\20\3\20\3\21\3\21\3\22\3\22\3\22")
        buf.write("\3\22\3\23\3\23\3\23\3\23\3\24\3\24\3\25\3\25\3\26\3\26")
        buf.write("\3\27\3\27\3\30\3\30\3\31\3\31\3\32\3\32\3\32\3\32\3\33")
        buf.write("\3\33\3\34\3\34\3\35\3\35\3\36\3\36\3\36\3\37\3\37\3\37")
        buf.write("\3\37\3\37\3\37\3\37\3\37\3 \6 \u00e0\n \r \16 \u00e1")
        buf.write("\3!\3!\3\"\6\"\u00e7\n\"\r\"\16\"\u00e8\3#\3#\3#\3#\3")
        buf.write("$\3$\3%\5%\u00f2\n%\3%\3%\3&\3&\3\'\3\'\3(\3(\3(\2\2)")
        buf.write("\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62")
        buf.write("\64\668:<>@BDFHJLN\2\t\4\2\'/\61<\4\2\'/\61O\3\2\60H\3")
        buf.write("\2\60k\3\2\3\4\3\2\7\b\3\2\n\13\2\u00e6\2P\3\2\2\2\4Z")
        buf.write("\3\2\2\2\6e\3\2\2\2\bg\3\2\2\2\np\3\2\2\2\f\u0083\3\2")
        buf.write("\2\2\16\u0085\3\2\2\2\20\u008e\3\2\2\2\22\u0096\3\2\2")
        buf.write("\2\24\u0099\3\2\2\2\26\u009d\3\2\2\2\30\u00a0\3\2\2\2")
        buf.write("\32\u00a4\3\2\2\2\34\u00a7\3\2\2\2\36\u00ab\3\2\2\2 \u00b3")
        buf.write("\3\2\2\2\"\u00b5\3\2\2\2$\u00b9\3\2\2\2&\u00bd\3\2\2\2")
        buf.write("(\u00bf\3\2\2\2*\u00c1\3\2\2\2,\u00c3\3\2\2\2.\u00c5\3")
        buf.write("\2\2\2\60\u00c7\3\2\2\2\62\u00c9\3\2\2\2\64\u00cd\3\2")
        buf.write("\2\2\66\u00cf\3\2\2\28\u00d1\3\2\2\2:\u00d3\3\2\2\2<\u00d6")
        buf.write("\3\2\2\2>\u00df\3\2\2\2@\u00e3\3\2\2\2B\u00e6\3\2\2\2")
        buf.write("D\u00ea\3\2\2\2F\u00ee\3\2\2\2H\u00f1\3\2\2\2J\u00f5\3")
        buf.write("\2\2\2L\u00f7\3\2\2\2N\u00f9\3\2\2\2PQ\5\4\3\2QW\7\35")
        buf.write("\2\2RS\5\4\3\2ST\7\35\2\2TV\3\2\2\2UR\3\2\2\2VY\3\2\2")
        buf.write("\2WU\3\2\2\2WX\3\2\2\2X\3\3\2\2\2YW\3\2\2\2Z[\5\6\4\2")
        buf.write("[\5\3\2\2\2\\f\5\b\5\2]f\5\16\b\2^f\5\22\n\2_f\5\26\f")
        buf.write("\2`f\5\32\16\2af\5:\36\2bf\5> \2cf\5@!\2df\5B\"\2e\\\3")
        buf.write("\2\2\2e]\3\2\2\2e^\3\2\2\2e_\3\2\2\2e`\3\2\2\2ea\3\2\2")
        buf.write("\2eb\3\2\2\2ec\3\2\2\2ed\3\2\2\2f\7\3\2\2\2gh\7\r\2\2")
        buf.write("hm\5\n\6\2ij\7\34\2\2jl\5\f\7\2ki\3\2\2\2lo\3\2\2\2mk")
        buf.write("\3\2\2\2mn\3\2\2\2n\t\3\2\2\2om\3\2\2\2pq\7\17\2\2qr\7")
        buf.write("\36\2\2rs\5F$\2s\13\3\2\2\2tu\7\20\2\2uv\7\36\2\2v\u0084")
        buf.write("\5N(\2wx\7\t\2\2xy\7\36\2\2y\u0084\5H%\2z{\7\21\2\2{|")
        buf.write("\7\36\2\2|\u0084\5H%\2}~\7\22\2\2~\177\7\36\2\2\177\u0084")
        buf.write("\5F$\2\u0080\u0081\7\23\2\2\u0081\u0082\7\36\2\2\u0082")
        buf.write("\u0084\5N(\2\u0083t\3\2\2\2\u0083w\3\2\2\2\u0083z\3\2")
        buf.write("\2\2\u0083}\3\2\2\2\u0083\u0080\3\2\2\2\u0084\r\3\2\2")
        buf.write("\2\u0085\u0086\7\24\2\2\u0086\u008b\5\20\t\2\u0087\u0088")
        buf.write("\7\34\2\2\u0088\u008a\5\f\7\2\u0089\u0087\3\2\2\2\u008a")
        buf.write("\u008d\3\2\2\2\u008b\u0089\3\2\2\2\u008b\u008c\3\2\2\2")
        buf.write("\u008c\17\3\2\2\2\u008d\u008b\3\2\2\2\u008e\u008f\7\16")
        buf.write("\2\2\u008f\u0090\7\36\2\2\u0090\u0091\5H%\2\u0091\u0092")
        buf.write("\7\34\2\2\u0092\u0093\7\17\2\2\u0093\u0094\7\36\2\2\u0094")
        buf.write("\u0095\5F$\2\u0095\21\3\2\2\2\u0096\u0097\7\25\2\2\u0097")
        buf.write("\u0098\5\24\13\2\u0098\23\3\2\2\2\u0099\u009a\7\f\2\2")
        buf.write("\u009a\u009b\7\36\2\2\u009b\u009c\5H%\2\u009c\25\3\2\2")
        buf.write("\2\u009d\u009e\7\27\2\2\u009e\u009f\5\30\r\2\u009f\27")
        buf.write("\3\2\2\2\u00a0\u00a1\7\f\2\2\u00a1\u00a2\7\36\2\2\u00a2")
        buf.write("\u00a3\5H%\2\u00a3\31\3\2\2\2\u00a4\u00a5\7\30\2\2\u00a5")
        buf.write("\u00a6\5\34\17\2\u00a6\33\3\2\2\2\u00a7\u00a8\5\36\20")
        buf.write("\2\u00a8\u00a9\7\34\2\2\u00a9\u00aa\5\b\5\2\u00aa\35\3")
        buf.write("\2\2\2\u00ab\u00ac\7\31\2\2\u00ac\u00ad\7\36\2\2\u00ad")
        buf.write("\u00ae\5 \21\2\u00ae\u00af\7\34\2\2\u00af\u00b0\7\32\2")
        buf.write("\2\u00b0\u00b1\7\36\2\2\u00b1\u00b2\5\60\31\2\u00b2\37")
        buf.write("\3\2\2\2\u00b3\u00b4\5\"\22\2\u00b4!\3\2\2\2\u00b5\u00b6")
        buf.write("\5$\23\2\u00b6\u00b7\5.\30\2\u00b7\u00b8\5,\27\2\u00b8")
        buf.write("#\3\2\2\2\u00b9\u00ba\5*\26\2\u00ba\u00bb\5.\30\2\u00bb")
        buf.write("\u00bc\5&\24\2\u00bc%\3\2\2\2\u00bd\u00be\5(\25\2\u00be")
        buf.write("\'\3\2\2\2\u00bf\u00c0\t\2\2\2\u00c0)\3\2\2\2\u00c1\u00c2")
        buf.write("\t\3\2\2\u00c2+\3\2\2\2\u00c3\u00c4\7$\2\2\u00c4-\3\2")
        buf.write("\2\2\u00c5\u00c6\7\"\2\2\u00c6/\3\2\2\2\u00c7\u00c8\5")
        buf.write("\62\32\2\u00c8\61\3\2\2\2\u00c9\u00ca\5\66\34\2\u00ca")
        buf.write("\u00cb\5\64\33\2\u00cb\u00cc\58\35\2\u00cc\63\3\2\2\2")
        buf.write("\u00cd\u00ce\7#\2\2\u00ce\65\3\2\2\2\u00cf\u00d0\t\4\2")
        buf.write("\2\u00d0\67\3\2\2\2\u00d1\u00d2\t\5\2\2\u00d29\3\2\2\2")
        buf.write("\u00d3\u00d4\7\26\2\2\u00d4\u00d5\5<\37\2\u00d5;\3\2\2")
        buf.write("\2\u00d6\u00d7\7\f\2\2\u00d7\u00d8\7\36\2\2\u00d8\u00d9")
        buf.write("\5H%\2\u00d9\u00da\7\34\2\2\u00da\u00db\7\33\2\2\u00db")
        buf.write("\u00dc\7\36\2\2\u00dc\u00dd\5F$\2\u00dd=\3\2\2\2\u00de")
        buf.write("\u00e0\5D#\2\u00df\u00de\3\2\2\2\u00e0\u00e1\3\2\2\2\u00e1")
        buf.write("\u00df\3\2\2\2\u00e1\u00e2\3\2\2\2\u00e2?\3\2\2\2\u00e3")
        buf.write("\u00e4\7 \2\2\u00e4A\3\2\2\2\u00e5\u00e7\5D#\2\u00e6\u00e5")
        buf.write("\3\2\2\2\u00e7\u00e8\3\2\2\2\u00e8\u00e6\3\2\2\2\u00e8")
        buf.write("\u00e9\3\2\2\2\u00e9C\3\2\2\2\u00ea\u00eb\7\37\2\2\u00eb")
        buf.write("\u00ec\7\36\2\2\u00ec\u00ed\5F$\2\u00edE\3\2\2\2\u00ee")
        buf.write("\u00ef\7\5\2\2\u00efG\3\2\2\2\u00f0\u00f2\5J&\2\u00f1")
        buf.write("\u00f0\3\2\2\2\u00f1\u00f2\3\2\2\2\u00f2\u00f3\3\2\2\2")
        buf.write("\u00f3\u00f4\5L\'\2\u00f4I\3\2\2\2\u00f5\u00f6\t\6\2\2")
        buf.write("\u00f6K\3\2\2\2\u00f7\u00f8\t\7\2\2\u00f8M\3\2\2\2\u00f9")
        buf.write("\u00fa\t\b\2\2\u00faO\3\2\2\2\nWem\u0083\u008b\u00e1\u00e8")
        buf.write("\u00f1")
        return buf.getvalue()


class dslParser ( Parser ):

    grammarFileName = "dsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'+'", "'-'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'lat'", "'True'", "'False'", 
                     "'id'", "'tweet'", "'in_reply_to_status_id'", "'status'", 
                     "'possibly_sensitive'", "'long'", "'place_id'", "'display_coordinates'", 
                     "'reply'", "'retweet'", "'direct_message'", "'favourite'", 
                     "'schedule'", "'date'", "'time'", "'text'", "','", 
                     "';'", "':'", "'keyword'", "'follow_all_followers'", 
                     "<INVALID>", "'/'", "'.'", "<INVALID>", "<INVALID>", 
                     "'0'", "'1'", "'2'", "'3'", "'4'", "'5'", "'6'", "'7'", 
                     "'8'", "'9'", "'00'", "'01'", "'02'", "'03'", "'04'", 
                     "'05'", "'06'", "'07'", "'08'", "'09'", "'10'", "'11'", 
                     "'12'", "'13'", "'14'", "'15'", "'16'", "'17'", "'18'", 
                     "'19'", "'20'", "'21'", "'22'", "'23'", "'24'", "'25'", 
                     "'26'", "'27'", "'28'", "'29'", "'30'", "'31'", "'32'", 
                     "'33'", "'34'", "'35'", "'36'", "'37'", "'38'", "'39'", 
                     "'40'", "'41'", "'42'", "'43'", "'44'", "'45'", "'46'", 
                     "'47'", "'48'", "'49'", "'50'", "'51'", "'52'", "'53'", 
                     "'54'", "'55'", "'56'", "'57'", "'58'", "'59'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "StringLiteral", 
                      "UnterminatedStringLiteral", "UNSIGNED_INT", "UNSIGNED_FLOAT", 
                      "LAT", "TRUE", "FALSE", "ID", "TWEET", "REPLY_ID", 
                      "STATUS", "POSSIBLY_SENSITIVE", "LONG", "PLACE_ID", 
                      "DISPLAY_COORDINATES", "REPLY", "RETWEET", "DIRECT_MESSAGE", 
                      "FAVOURITE", "SCHEDULE", "DATE", "TIME", "TEXT", "COMMA", 
                      "SEMICOLON", "COLON", "KEYWORD", "FOLLOWALL", "WS", 
                      "SLASH", "DOT", "FOUR_DIGIT", "DIGIT", "INT_0", "INT_1", 
                      "INT_2", "INT_3", "INT_4", "INT_5", "INT_6", "INT_7", 
                      "INT_8", "INT_9", "INT_00", "INT_01", "INT_02", "INT_03", 
                      "INT_04", "INT_05", "INT_06", "INT_07", "INT_08", 
                      "INT_09", "INT_10", "INT_11", "INT_12", "INT_13", 
                      "INT_14", "INT_15", "INT_16", "INT_17", "INT_18", 
                      "INT_19", "INT_20", "INT_21", "INT_22", "INT_23", 
                      "INT_24", "INT_25", "INT_26", "INT_27", "INT_28", 
                      "INT_29", "INT_30", "INT_31", "INT_32", "INT_33", 
                      "INT_34", "INT_35", "INT_36", "INT_37", "INT_38", 
                      "INT_39", "INT_40", "INT_41", "INT_42", "INT_43", 
                      "INT_44", "INT_45", "INT_46", "INT_47", "INT_48", 
                      "INT_49", "INT_50", "INT_51", "INT_52", "INT_53", 
                      "INT_54", "INT_55", "INT_56", "INT_57", "INT_58", 
                      "INT_59" ]

    RULE_twitbot = 0
    RULE_stat = 1
    RULE_action = 2
    RULE_tweet = 3
    RULE_tweet_required_parameter = 4
    RULE_tweet_optional_parameters = 5
    RULE_reply = 6
    RULE_reply_required_parameters = 7
    RULE_retweet = 8
    RULE_retweet_required_parameter = 9
    RULE_favourite = 10
    RULE_favourite_required_parameter = 11
    RULE_scheduleTweet = 12
    RULE_schedule_tweet_required_parameter = 13
    RULE_date_time_parameter = 14
    RULE_date = 15
    RULE_day_month_year = 16
    RULE_day_month = 17
    RULE_month = 18
    RULE_numeric_month = 19
    RULE_numeric_day = 20
    RULE_year = 21
    RULE_date_separator = 22
    RULE_time = 23
    RULE_hour_minute = 24
    RULE_time_separator = 25
    RULE_numeric_hour = 26
    RULE_numeric_minute = 27
    RULE_directMessage = 28
    RULE_direct_message_required_parameters = 29
    RULE_autoFavouriteRetweet = 30
    RULE_autoFollowFollowers = 31
    RULE_autoReplyMentions = 32
    RULE_keywords = 33
    RULE_stringValue = 34
    RULE_number = 35
    RULE_unary_operator = 36
    RULE_unsigned_number = 37
    RULE_boolean = 38

    ruleNames =  [ "twitbot", "stat", "action", "tweet", "tweet_required_parameter", 
                   "tweet_optional_parameters", "reply", "reply_required_parameters", 
                   "retweet", "retweet_required_parameter", "favourite", 
                   "favourite_required_parameter", "scheduleTweet", "schedule_tweet_required_parameter", 
                   "date_time_parameter", "date", "day_month_year", "day_month", 
                   "month", "numeric_month", "numeric_day", "year", "date_separator", 
                   "time", "hour_minute", "time_separator", "numeric_hour", 
                   "numeric_minute", "directMessage", "direct_message_required_parameters", 
                   "autoFavouriteRetweet", "autoFollowFollowers", "autoReplyMentions", 
                   "keywords", "stringValue", "number", "unary_operator", 
                   "unsigned_number", "boolean" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    StringLiteral=3
    UnterminatedStringLiteral=4
    UNSIGNED_INT=5
    UNSIGNED_FLOAT=6
    LAT=7
    TRUE=8
    FALSE=9
    ID=10
    TWEET=11
    REPLY_ID=12
    STATUS=13
    POSSIBLY_SENSITIVE=14
    LONG=15
    PLACE_ID=16
    DISPLAY_COORDINATES=17
    REPLY=18
    RETWEET=19
    DIRECT_MESSAGE=20
    FAVOURITE=21
    SCHEDULE=22
    DATE=23
    TIME=24
    TEXT=25
    COMMA=26
    SEMICOLON=27
    COLON=28
    KEYWORD=29
    FOLLOWALL=30
    WS=31
    SLASH=32
    DOT=33
    FOUR_DIGIT=34
    DIGIT=35
    INT_0=36
    INT_1=37
    INT_2=38
    INT_3=39
    INT_4=40
    INT_5=41
    INT_6=42
    INT_7=43
    INT_8=44
    INT_9=45
    INT_00=46
    INT_01=47
    INT_02=48
    INT_03=49
    INT_04=50
    INT_05=51
    INT_06=52
    INT_07=53
    INT_08=54
    INT_09=55
    INT_10=56
    INT_11=57
    INT_12=58
    INT_13=59
    INT_14=60
    INT_15=61
    INT_16=62
    INT_17=63
    INT_18=64
    INT_19=65
    INT_20=66
    INT_21=67
    INT_22=68
    INT_23=69
    INT_24=70
    INT_25=71
    INT_26=72
    INT_27=73
    INT_28=74
    INT_29=75
    INT_30=76
    INT_31=77
    INT_32=78
    INT_33=79
    INT_34=80
    INT_35=81
    INT_36=82
    INT_37=83
    INT_38=84
    INT_39=85
    INT_40=86
    INT_41=87
    INT_42=88
    INT_43=89
    INT_44=90
    INT_45=91
    INT_46=92
    INT_47=93
    INT_48=94
    INT_49=95
    INT_50=96
    INT_51=97
    INT_52=98
    INT_53=99
    INT_54=100
    INT_55=101
    INT_56=102
    INT_57=103
    INT_58=104
    INT_59=105

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class TwitbotContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.StatContext)
            else:
                return self.getTypedRuleContext(dslParser.StatContext,i)


        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.SEMICOLON)
            else:
                return self.getToken(dslParser.SEMICOLON, i)

        def getRuleIndex(self):
            return dslParser.RULE_twitbot

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTwitbot" ):
                listener.enterTwitbot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTwitbot" ):
                listener.exitTwitbot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTwitbot" ):
                return visitor.visitTwitbot(self)
            else:
                return visitor.visitChildren(self)




    def twitbot(self):

        localctx = dslParser.TwitbotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_twitbot)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 78
            self.stat()
            self.state = 79
            self.match(dslParser.SEMICOLON)
            self.state = 85
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << dslParser.TWEET) | (1 << dslParser.REPLY) | (1 << dslParser.RETWEET) | (1 << dslParser.DIRECT_MESSAGE) | (1 << dslParser.FAVOURITE) | (1 << dslParser.SCHEDULE) | (1 << dslParser.KEYWORD) | (1 << dslParser.FOLLOWALL))) != 0):
                self.state = 80
                self.stat()
                self.state = 81
                self.match(dslParser.SEMICOLON)
                self.state = 87
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action(self):
            return self.getTypedRuleContext(dslParser.ActionContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_stat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat" ):
                listener.enterStat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat" ):
                listener.exitStat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat" ):
                return visitor.visitStat(self)
            else:
                return visitor.visitChildren(self)




    def stat(self):

        localctx = dslParser.StatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_stat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 88
            self.action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tweet(self):
            return self.getTypedRuleContext(dslParser.TweetContext,0)


        def reply(self):
            return self.getTypedRuleContext(dslParser.ReplyContext,0)


        def retweet(self):
            return self.getTypedRuleContext(dslParser.RetweetContext,0)


        def favourite(self):
            return self.getTypedRuleContext(dslParser.FavouriteContext,0)


        def scheduleTweet(self):
            return self.getTypedRuleContext(dslParser.ScheduleTweetContext,0)


        def directMessage(self):
            return self.getTypedRuleContext(dslParser.DirectMessageContext,0)


        def autoFavouriteRetweet(self):
            return self.getTypedRuleContext(dslParser.AutoFavouriteRetweetContext,0)


        def autoFollowFollowers(self):
            return self.getTypedRuleContext(dslParser.AutoFollowFollowersContext,0)


        def autoReplyMentions(self):
            return self.getTypedRuleContext(dslParser.AutoReplyMentionsContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction" ):
                return visitor.visitAction(self)
            else:
                return visitor.visitChildren(self)




    def action(self):

        localctx = dslParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_action)
        try:
            self.state = 99
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 90
                self.tweet()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 91
                self.reply()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 92
                self.retweet()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 93
                self.favourite()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 94
                self.scheduleTweet()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 95
                self.directMessage()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 96
                self.autoFavouriteRetweet()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 97
                self.autoFollowFollowers()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 98
                self.autoReplyMentions()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TWEET(self):
            return self.getToken(dslParser.TWEET, 0)

        def tweet_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Tweet_required_parameterContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def tweet_optional_parameters(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.Tweet_optional_parametersContext)
            else:
                return self.getTypedRuleContext(dslParser.Tweet_optional_parametersContext,i)


        def getRuleIndex(self):
            return dslParser.RULE_tweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweet" ):
                listener.enterTweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweet" ):
                listener.exitTweet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTweet" ):
                return visitor.visitTweet(self)
            else:
                return visitor.visitChildren(self)




    def tweet(self):

        localctx = dslParser.TweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_tweet)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self.match(dslParser.TWEET)
            self.state = 102
            self.tweet_required_parameter()
            self.state = 107
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dslParser.COMMA:
                self.state = 103
                self.match(dslParser.COMMA)
                self.state = 104
                self.tweet_optional_parameters()
                self.state = 109
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tweet_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STATUS(self):
            return self.getToken(dslParser.STATUS, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_tweet_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweet_required_parameter" ):
                listener.enterTweet_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweet_required_parameter" ):
                listener.exitTweet_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTweet_required_parameter" ):
                return visitor.visitTweet_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def tweet_required_parameter(self):

        localctx = dslParser.Tweet_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_tweet_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 110
            self.match(dslParser.STATUS)
            self.state = 111
            self.match(dslParser.COLON)
            self.state = 112
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tweet_optional_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POSSIBLY_SENSITIVE(self):
            return self.getToken(dslParser.POSSIBLY_SENSITIVE, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def boolean(self):
            return self.getTypedRuleContext(dslParser.BooleanContext,0)


        def LAT(self):
            return self.getToken(dslParser.LAT, 0)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def LONG(self):
            return self.getToken(dslParser.LONG, 0)

        def PLACE_ID(self):
            return self.getToken(dslParser.PLACE_ID, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def DISPLAY_COORDINATES(self):
            return self.getToken(dslParser.DISPLAY_COORDINATES, 0)

        def getRuleIndex(self):
            return dslParser.RULE_tweet_optional_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweet_optional_parameters" ):
                listener.enterTweet_optional_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweet_optional_parameters" ):
                listener.exitTweet_optional_parameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTweet_optional_parameters" ):
                return visitor.visitTweet_optional_parameters(self)
            else:
                return visitor.visitChildren(self)




    def tweet_optional_parameters(self):

        localctx = dslParser.Tweet_optional_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_tweet_optional_parameters)
        try:
            self.state = 129
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dslParser.POSSIBLY_SENSITIVE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 114
                self.match(dslParser.POSSIBLY_SENSITIVE)
                self.state = 115
                self.match(dslParser.COLON)
                self.state = 116
                self.boolean()
                pass
            elif token in [dslParser.LAT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 117
                self.match(dslParser.LAT)
                self.state = 118
                self.match(dslParser.COLON)
                self.state = 119
                self.number()
                pass
            elif token in [dslParser.LONG]:
                self.enterOuterAlt(localctx, 3)
                self.state = 120
                self.match(dslParser.LONG)
                self.state = 121
                self.match(dslParser.COLON)
                self.state = 122
                self.number()
                pass
            elif token in [dslParser.PLACE_ID]:
                self.enterOuterAlt(localctx, 4)
                self.state = 123
                self.match(dslParser.PLACE_ID)
                self.state = 124
                self.match(dslParser.COLON)
                self.state = 125
                self.stringValue()
                pass
            elif token in [dslParser.DISPLAY_COORDINATES]:
                self.enterOuterAlt(localctx, 5)
                self.state = 126
                self.match(dslParser.DISPLAY_COORDINATES)
                self.state = 127
                self.match(dslParser.COLON)
                self.state = 128
                self.boolean()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPLY(self):
            return self.getToken(dslParser.REPLY, 0)

        def reply_required_parameters(self):
            return self.getTypedRuleContext(dslParser.Reply_required_parametersContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def tweet_optional_parameters(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.Tweet_optional_parametersContext)
            else:
                return self.getTypedRuleContext(dslParser.Tweet_optional_parametersContext,i)


        def getRuleIndex(self):
            return dslParser.RULE_reply

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReply" ):
                listener.enterReply(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReply" ):
                listener.exitReply(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReply" ):
                return visitor.visitReply(self)
            else:
                return visitor.visitChildren(self)




    def reply(self):

        localctx = dslParser.ReplyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_reply)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 131
            self.match(dslParser.REPLY)
            self.state = 132
            self.reply_required_parameters()
            self.state = 137
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dslParser.COMMA:
                self.state = 133
                self.match(dslParser.COMMA)
                self.state = 134
                self.tweet_optional_parameters()
                self.state = 139
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reply_required_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPLY_ID(self):
            return self.getToken(dslParser.REPLY_ID, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COLON)
            else:
                return self.getToken(dslParser.COLON, i)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def STATUS(self):
            return self.getToken(dslParser.STATUS, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_reply_required_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReply_required_parameters" ):
                listener.enterReply_required_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReply_required_parameters" ):
                listener.exitReply_required_parameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReply_required_parameters" ):
                return visitor.visitReply_required_parameters(self)
            else:
                return visitor.visitChildren(self)




    def reply_required_parameters(self):

        localctx = dslParser.Reply_required_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_reply_required_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self.match(dslParser.REPLY_ID)
            self.state = 141
            self.match(dslParser.COLON)
            self.state = 142
            self.number()
            self.state = 143
            self.match(dslParser.COMMA)
            self.state = 144
            self.match(dslParser.STATUS)
            self.state = 145
            self.match(dslParser.COLON)
            self.state = 146
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RetweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETWEET(self):
            return self.getToken(dslParser.RETWEET, 0)

        def retweet_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Retweet_required_parameterContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_retweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRetweet" ):
                listener.enterRetweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRetweet" ):
                listener.exitRetweet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRetweet" ):
                return visitor.visitRetweet(self)
            else:
                return visitor.visitChildren(self)




    def retweet(self):

        localctx = dslParser.RetweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_retweet)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 148
            self.match(dslParser.RETWEET)
            self.state = 149
            self.retweet_required_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Retweet_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(dslParser.ID, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_retweet_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRetweet_required_parameter" ):
                listener.enterRetweet_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRetweet_required_parameter" ):
                listener.exitRetweet_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRetweet_required_parameter" ):
                return visitor.visitRetweet_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def retweet_required_parameter(self):

        localctx = dslParser.Retweet_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_retweet_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            self.match(dslParser.ID)
            self.state = 152
            self.match(dslParser.COLON)
            self.state = 153
            self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FavouriteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FAVOURITE(self):
            return self.getToken(dslParser.FAVOURITE, 0)

        def favourite_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Favourite_required_parameterContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_favourite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFavourite" ):
                listener.enterFavourite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFavourite" ):
                listener.exitFavourite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFavourite" ):
                return visitor.visitFavourite(self)
            else:
                return visitor.visitChildren(self)




    def favourite(self):

        localctx = dslParser.FavouriteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_favourite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 155
            self.match(dslParser.FAVOURITE)
            self.state = 156
            self.favourite_required_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Favourite_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(dslParser.ID, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_favourite_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFavourite_required_parameter" ):
                listener.enterFavourite_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFavourite_required_parameter" ):
                listener.exitFavourite_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFavourite_required_parameter" ):
                return visitor.visitFavourite_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def favourite_required_parameter(self):

        localctx = dslParser.Favourite_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_favourite_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self.match(dslParser.ID)
            self.state = 159
            self.match(dslParser.COLON)
            self.state = 160
            self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScheduleTweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCHEDULE(self):
            return self.getToken(dslParser.SCHEDULE, 0)

        def schedule_tweet_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Schedule_tweet_required_parameterContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_scheduleTweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScheduleTweet" ):
                listener.enterScheduleTweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScheduleTweet" ):
                listener.exitScheduleTweet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScheduleTweet" ):
                return visitor.visitScheduleTweet(self)
            else:
                return visitor.visitChildren(self)




    def scheduleTweet(self):

        localctx = dslParser.ScheduleTweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_scheduleTweet)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            self.match(dslParser.SCHEDULE)
            self.state = 163
            self.schedule_tweet_required_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Schedule_tweet_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def date_time_parameter(self):
            return self.getTypedRuleContext(dslParser.Date_time_parameterContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def tweet(self):
            return self.getTypedRuleContext(dslParser.TweetContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_schedule_tweet_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchedule_tweet_required_parameter" ):
                listener.enterSchedule_tweet_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchedule_tweet_required_parameter" ):
                listener.exitSchedule_tweet_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSchedule_tweet_required_parameter" ):
                return visitor.visitSchedule_tweet_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def schedule_tweet_required_parameter(self):

        localctx = dslParser.Schedule_tweet_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_schedule_tweet_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 165
            self.date_time_parameter()
            self.state = 166
            self.match(dslParser.COMMA)
            self.state = 167
            self.tweet()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Date_time_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE(self):
            return self.getToken(dslParser.DATE, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COLON)
            else:
                return self.getToken(dslParser.COLON, i)

        def date(self):
            return self.getTypedRuleContext(dslParser.DateContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def TIME(self):
            return self.getToken(dslParser.TIME, 0)

        def time(self):
            return self.getTypedRuleContext(dslParser.TimeContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_date_time_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate_time_parameter" ):
                listener.enterDate_time_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate_time_parameter" ):
                listener.exitDate_time_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDate_time_parameter" ):
                return visitor.visitDate_time_parameter(self)
            else:
                return visitor.visitChildren(self)




    def date_time_parameter(self):

        localctx = dslParser.Date_time_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_date_time_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 169
            self.match(dslParser.DATE)
            self.state = 170
            self.match(dslParser.COLON)
            self.state = 171
            self.date()
            self.state = 172
            self.match(dslParser.COMMA)
            self.state = 173
            self.match(dslParser.TIME)
            self.state = 174
            self.match(dslParser.COLON)
            self.state = 175
            self.time()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def day_month_year(self):
            return self.getTypedRuleContext(dslParser.Day_month_yearContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDate" ):
                return visitor.visitDate(self)
            else:
                return visitor.visitChildren(self)




    def date(self):

        localctx = dslParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 177
            self.day_month_year()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Day_month_yearContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def day_month(self):
            return self.getTypedRuleContext(dslParser.Day_monthContext,0)


        def date_separator(self):
            return self.getTypedRuleContext(dslParser.Date_separatorContext,0)


        def year(self):
            return self.getTypedRuleContext(dslParser.YearContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_day_month_year

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDay_month_year" ):
                listener.enterDay_month_year(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDay_month_year" ):
                listener.exitDay_month_year(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDay_month_year" ):
                return visitor.visitDay_month_year(self)
            else:
                return visitor.visitChildren(self)




    def day_month_year(self):

        localctx = dslParser.Day_month_yearContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_day_month_year)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            self.day_month()
            self.state = 180
            self.date_separator()
            self.state = 181
            self.year()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Day_monthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeric_day(self):
            return self.getTypedRuleContext(dslParser.Numeric_dayContext,0)


        def date_separator(self):
            return self.getTypedRuleContext(dslParser.Date_separatorContext,0)


        def month(self):
            return self.getTypedRuleContext(dslParser.MonthContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_day_month

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDay_month" ):
                listener.enterDay_month(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDay_month" ):
                listener.exitDay_month(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDay_month" ):
                return visitor.visitDay_month(self)
            else:
                return visitor.visitChildren(self)




    def day_month(self):

        localctx = dslParser.Day_monthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_day_month)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            self.numeric_day()
            self.state = 184
            self.date_separator()
            self.state = 185
            self.month()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MonthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeric_month(self):
            return self.getTypedRuleContext(dslParser.Numeric_monthContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_month

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMonth" ):
                listener.enterMonth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMonth" ):
                listener.exitMonth(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMonth" ):
                return visitor.visitMonth(self)
            else:
                return visitor.visitChildren(self)




    def month(self):

        localctx = dslParser.MonthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_month)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 187
            self.numeric_month()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_monthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_1(self):
            return self.getToken(dslParser.INT_1, 0)

        def INT_2(self):
            return self.getToken(dslParser.INT_2, 0)

        def INT_3(self):
            return self.getToken(dslParser.INT_3, 0)

        def INT_4(self):
            return self.getToken(dslParser.INT_4, 0)

        def INT_5(self):
            return self.getToken(dslParser.INT_5, 0)

        def INT_6(self):
            return self.getToken(dslParser.INT_6, 0)

        def INT_7(self):
            return self.getToken(dslParser.INT_7, 0)

        def INT_8(self):
            return self.getToken(dslParser.INT_8, 0)

        def INT_9(self):
            return self.getToken(dslParser.INT_9, 0)

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_month

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_month" ):
                listener.enterNumeric_month(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_month" ):
                listener.exitNumeric_month(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_month" ):
                return visitor.visitNumeric_month(self)
            else:
                return visitor.visitChildren(self)




    def numeric_month(self):

        localctx = dslParser.Numeric_monthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_numeric_month)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 189
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << dslParser.INT_1) | (1 << dslParser.INT_2) | (1 << dslParser.INT_3) | (1 << dslParser.INT_4) | (1 << dslParser.INT_5) | (1 << dslParser.INT_6) | (1 << dslParser.INT_7) | (1 << dslParser.INT_8) | (1 << dslParser.INT_9) | (1 << dslParser.INT_01) | (1 << dslParser.INT_02) | (1 << dslParser.INT_03) | (1 << dslParser.INT_04) | (1 << dslParser.INT_05) | (1 << dslParser.INT_06) | (1 << dslParser.INT_07) | (1 << dslParser.INT_08) | (1 << dslParser.INT_09) | (1 << dslParser.INT_10) | (1 << dslParser.INT_11) | (1 << dslParser.INT_12))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_dayContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_1(self):
            return self.getToken(dslParser.INT_1, 0)

        def INT_2(self):
            return self.getToken(dslParser.INT_2, 0)

        def INT_3(self):
            return self.getToken(dslParser.INT_3, 0)

        def INT_4(self):
            return self.getToken(dslParser.INT_4, 0)

        def INT_5(self):
            return self.getToken(dslParser.INT_5, 0)

        def INT_6(self):
            return self.getToken(dslParser.INT_6, 0)

        def INT_7(self):
            return self.getToken(dslParser.INT_7, 0)

        def INT_8(self):
            return self.getToken(dslParser.INT_8, 0)

        def INT_9(self):
            return self.getToken(dslParser.INT_9, 0)

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def INT_13(self):
            return self.getToken(dslParser.INT_13, 0)

        def INT_14(self):
            return self.getToken(dslParser.INT_14, 0)

        def INT_15(self):
            return self.getToken(dslParser.INT_15, 0)

        def INT_16(self):
            return self.getToken(dslParser.INT_16, 0)

        def INT_17(self):
            return self.getToken(dslParser.INT_17, 0)

        def INT_18(self):
            return self.getToken(dslParser.INT_18, 0)

        def INT_19(self):
            return self.getToken(dslParser.INT_19, 0)

        def INT_20(self):
            return self.getToken(dslParser.INT_20, 0)

        def INT_21(self):
            return self.getToken(dslParser.INT_21, 0)

        def INT_22(self):
            return self.getToken(dslParser.INT_22, 0)

        def INT_23(self):
            return self.getToken(dslParser.INT_23, 0)

        def INT_24(self):
            return self.getToken(dslParser.INT_24, 0)

        def INT_25(self):
            return self.getToken(dslParser.INT_25, 0)

        def INT_26(self):
            return self.getToken(dslParser.INT_26, 0)

        def INT_27(self):
            return self.getToken(dslParser.INT_27, 0)

        def INT_28(self):
            return self.getToken(dslParser.INT_28, 0)

        def INT_29(self):
            return self.getToken(dslParser.INT_29, 0)

        def INT_30(self):
            return self.getToken(dslParser.INT_30, 0)

        def INT_31(self):
            return self.getToken(dslParser.INT_31, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_day

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_day" ):
                listener.enterNumeric_day(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_day" ):
                listener.exitNumeric_day(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_day" ):
                return visitor.visitNumeric_day(self)
            else:
                return visitor.visitChildren(self)




    def numeric_day(self):

        localctx = dslParser.Numeric_dayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_numeric_day)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            _la = self._input.LA(1)
            if not(((((_la - 37)) & ~0x3f) == 0 and ((1 << (_la - 37)) & ((1 << (dslParser.INT_1 - 37)) | (1 << (dslParser.INT_2 - 37)) | (1 << (dslParser.INT_3 - 37)) | (1 << (dslParser.INT_4 - 37)) | (1 << (dslParser.INT_5 - 37)) | (1 << (dslParser.INT_6 - 37)) | (1 << (dslParser.INT_7 - 37)) | (1 << (dslParser.INT_8 - 37)) | (1 << (dslParser.INT_9 - 37)) | (1 << (dslParser.INT_01 - 37)) | (1 << (dslParser.INT_02 - 37)) | (1 << (dslParser.INT_03 - 37)) | (1 << (dslParser.INT_04 - 37)) | (1 << (dslParser.INT_05 - 37)) | (1 << (dslParser.INT_06 - 37)) | (1 << (dslParser.INT_07 - 37)) | (1 << (dslParser.INT_08 - 37)) | (1 << (dslParser.INT_09 - 37)) | (1 << (dslParser.INT_10 - 37)) | (1 << (dslParser.INT_11 - 37)) | (1 << (dslParser.INT_12 - 37)) | (1 << (dslParser.INT_13 - 37)) | (1 << (dslParser.INT_14 - 37)) | (1 << (dslParser.INT_15 - 37)) | (1 << (dslParser.INT_16 - 37)) | (1 << (dslParser.INT_17 - 37)) | (1 << (dslParser.INT_18 - 37)) | (1 << (dslParser.INT_19 - 37)) | (1 << (dslParser.INT_20 - 37)) | (1 << (dslParser.INT_21 - 37)) | (1 << (dslParser.INT_22 - 37)) | (1 << (dslParser.INT_23 - 37)) | (1 << (dslParser.INT_24 - 37)) | (1 << (dslParser.INT_25 - 37)) | (1 << (dslParser.INT_26 - 37)) | (1 << (dslParser.INT_27 - 37)) | (1 << (dslParser.INT_28 - 37)) | (1 << (dslParser.INT_29 - 37)) | (1 << (dslParser.INT_30 - 37)) | (1 << (dslParser.INT_31 - 37)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YearContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOUR_DIGIT(self):
            return self.getToken(dslParser.FOUR_DIGIT, 0)

        def getRuleIndex(self):
            return dslParser.RULE_year

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYear" ):
                listener.enterYear(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYear" ):
                listener.exitYear(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYear" ):
                return visitor.visitYear(self)
            else:
                return visitor.visitChildren(self)




    def year(self):

        localctx = dslParser.YearContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_year)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(dslParser.FOUR_DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Date_separatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SLASH(self):
            return self.getToken(dslParser.SLASH, 0)

        def getRuleIndex(self):
            return dslParser.RULE_date_separator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate_separator" ):
                listener.enterDate_separator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate_separator" ):
                listener.exitDate_separator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDate_separator" ):
                return visitor.visitDate_separator(self)
            else:
                return visitor.visitChildren(self)




    def date_separator(self):

        localctx = dslParser.Date_separatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_date_separator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            self.match(dslParser.SLASH)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def hour_minute(self):
            return self.getTypedRuleContext(dslParser.Hour_minuteContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_time

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime" ):
                listener.enterTime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime" ):
                listener.exitTime(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime" ):
                return visitor.visitTime(self)
            else:
                return visitor.visitChildren(self)




    def time(self):

        localctx = dslParser.TimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_time)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.hour_minute()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Hour_minuteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeric_hour(self):
            return self.getTypedRuleContext(dslParser.Numeric_hourContext,0)


        def time_separator(self):
            return self.getTypedRuleContext(dslParser.Time_separatorContext,0)


        def numeric_minute(self):
            return self.getTypedRuleContext(dslParser.Numeric_minuteContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_hour_minute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHour_minute" ):
                listener.enterHour_minute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHour_minute" ):
                listener.exitHour_minute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHour_minute" ):
                return visitor.visitHour_minute(self)
            else:
                return visitor.visitChildren(self)




    def hour_minute(self):

        localctx = dslParser.Hour_minuteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_hour_minute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            self.numeric_hour()
            self.state = 200
            self.time_separator()
            self.state = 201
            self.numeric_minute()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Time_separatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOT(self):
            return self.getToken(dslParser.DOT, 0)

        def getRuleIndex(self):
            return dslParser.RULE_time_separator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_separator" ):
                listener.enterTime_separator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_separator" ):
                listener.exitTime_separator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime_separator" ):
                return visitor.visitTime_separator(self)
            else:
                return visitor.visitChildren(self)




    def time_separator(self):

        localctx = dslParser.Time_separatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_time_separator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            self.match(dslParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_hourContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def INT_13(self):
            return self.getToken(dslParser.INT_13, 0)

        def INT_14(self):
            return self.getToken(dslParser.INT_14, 0)

        def INT_15(self):
            return self.getToken(dslParser.INT_15, 0)

        def INT_16(self):
            return self.getToken(dslParser.INT_16, 0)

        def INT_17(self):
            return self.getToken(dslParser.INT_17, 0)

        def INT_18(self):
            return self.getToken(dslParser.INT_18, 0)

        def INT_19(self):
            return self.getToken(dslParser.INT_19, 0)

        def INT_20(self):
            return self.getToken(dslParser.INT_20, 0)

        def INT_21(self):
            return self.getToken(dslParser.INT_21, 0)

        def INT_22(self):
            return self.getToken(dslParser.INT_22, 0)

        def INT_23(self):
            return self.getToken(dslParser.INT_23, 0)

        def INT_24(self):
            return self.getToken(dslParser.INT_24, 0)

        def INT_00(self):
            return self.getToken(dslParser.INT_00, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_hour

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_hour" ):
                listener.enterNumeric_hour(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_hour" ):
                listener.exitNumeric_hour(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_hour" ):
                return visitor.visitNumeric_hour(self)
            else:
                return visitor.visitChildren(self)




    def numeric_hour(self):

        localctx = dslParser.Numeric_hourContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_numeric_hour)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 205
            _la = self._input.LA(1)
            if not(((((_la - 46)) & ~0x3f) == 0 and ((1 << (_la - 46)) & ((1 << (dslParser.INT_00 - 46)) | (1 << (dslParser.INT_01 - 46)) | (1 << (dslParser.INT_02 - 46)) | (1 << (dslParser.INT_03 - 46)) | (1 << (dslParser.INT_04 - 46)) | (1 << (dslParser.INT_05 - 46)) | (1 << (dslParser.INT_06 - 46)) | (1 << (dslParser.INT_07 - 46)) | (1 << (dslParser.INT_08 - 46)) | (1 << (dslParser.INT_09 - 46)) | (1 << (dslParser.INT_10 - 46)) | (1 << (dslParser.INT_11 - 46)) | (1 << (dslParser.INT_12 - 46)) | (1 << (dslParser.INT_13 - 46)) | (1 << (dslParser.INT_14 - 46)) | (1 << (dslParser.INT_15 - 46)) | (1 << (dslParser.INT_16 - 46)) | (1 << (dslParser.INT_17 - 46)) | (1 << (dslParser.INT_18 - 46)) | (1 << (dslParser.INT_19 - 46)) | (1 << (dslParser.INT_20 - 46)) | (1 << (dslParser.INT_21 - 46)) | (1 << (dslParser.INT_22 - 46)) | (1 << (dslParser.INT_23 - 46)) | (1 << (dslParser.INT_24 - 46)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_minuteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def INT_13(self):
            return self.getToken(dslParser.INT_13, 0)

        def INT_14(self):
            return self.getToken(dslParser.INT_14, 0)

        def INT_15(self):
            return self.getToken(dslParser.INT_15, 0)

        def INT_16(self):
            return self.getToken(dslParser.INT_16, 0)

        def INT_17(self):
            return self.getToken(dslParser.INT_17, 0)

        def INT_18(self):
            return self.getToken(dslParser.INT_18, 0)

        def INT_19(self):
            return self.getToken(dslParser.INT_19, 0)

        def INT_20(self):
            return self.getToken(dslParser.INT_20, 0)

        def INT_21(self):
            return self.getToken(dslParser.INT_21, 0)

        def INT_22(self):
            return self.getToken(dslParser.INT_22, 0)

        def INT_23(self):
            return self.getToken(dslParser.INT_23, 0)

        def INT_24(self):
            return self.getToken(dslParser.INT_24, 0)

        def INT_25(self):
            return self.getToken(dslParser.INT_25, 0)

        def INT_26(self):
            return self.getToken(dslParser.INT_26, 0)

        def INT_27(self):
            return self.getToken(dslParser.INT_27, 0)

        def INT_28(self):
            return self.getToken(dslParser.INT_28, 0)

        def INT_29(self):
            return self.getToken(dslParser.INT_29, 0)

        def INT_30(self):
            return self.getToken(dslParser.INT_30, 0)

        def INT_31(self):
            return self.getToken(dslParser.INT_31, 0)

        def INT_32(self):
            return self.getToken(dslParser.INT_32, 0)

        def INT_33(self):
            return self.getToken(dslParser.INT_33, 0)

        def INT_34(self):
            return self.getToken(dslParser.INT_34, 0)

        def INT_35(self):
            return self.getToken(dslParser.INT_35, 0)

        def INT_36(self):
            return self.getToken(dslParser.INT_36, 0)

        def INT_37(self):
            return self.getToken(dslParser.INT_37, 0)

        def INT_38(self):
            return self.getToken(dslParser.INT_38, 0)

        def INT_39(self):
            return self.getToken(dslParser.INT_39, 0)

        def INT_40(self):
            return self.getToken(dslParser.INT_40, 0)

        def INT_41(self):
            return self.getToken(dslParser.INT_41, 0)

        def INT_42(self):
            return self.getToken(dslParser.INT_42, 0)

        def INT_43(self):
            return self.getToken(dslParser.INT_43, 0)

        def INT_44(self):
            return self.getToken(dslParser.INT_44, 0)

        def INT_45(self):
            return self.getToken(dslParser.INT_45, 0)

        def INT_46(self):
            return self.getToken(dslParser.INT_46, 0)

        def INT_47(self):
            return self.getToken(dslParser.INT_47, 0)

        def INT_48(self):
            return self.getToken(dslParser.INT_48, 0)

        def INT_49(self):
            return self.getToken(dslParser.INT_49, 0)

        def INT_50(self):
            return self.getToken(dslParser.INT_50, 0)

        def INT_51(self):
            return self.getToken(dslParser.INT_51, 0)

        def INT_52(self):
            return self.getToken(dslParser.INT_52, 0)

        def INT_53(self):
            return self.getToken(dslParser.INT_53, 0)

        def INT_54(self):
            return self.getToken(dslParser.INT_54, 0)

        def INT_55(self):
            return self.getToken(dslParser.INT_55, 0)

        def INT_56(self):
            return self.getToken(dslParser.INT_56, 0)

        def INT_57(self):
            return self.getToken(dslParser.INT_57, 0)

        def INT_58(self):
            return self.getToken(dslParser.INT_58, 0)

        def INT_59(self):
            return self.getToken(dslParser.INT_59, 0)

        def INT_00(self):
            return self.getToken(dslParser.INT_00, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_minute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_minute" ):
                listener.enterNumeric_minute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_minute" ):
                listener.exitNumeric_minute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_minute" ):
                return visitor.visitNumeric_minute(self)
            else:
                return visitor.visitChildren(self)




    def numeric_minute(self):

        localctx = dslParser.Numeric_minuteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_numeric_minute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 207
            _la = self._input.LA(1)
            if not(((((_la - 46)) & ~0x3f) == 0 and ((1 << (_la - 46)) & ((1 << (dslParser.INT_00 - 46)) | (1 << (dslParser.INT_01 - 46)) | (1 << (dslParser.INT_02 - 46)) | (1 << (dslParser.INT_03 - 46)) | (1 << (dslParser.INT_04 - 46)) | (1 << (dslParser.INT_05 - 46)) | (1 << (dslParser.INT_06 - 46)) | (1 << (dslParser.INT_07 - 46)) | (1 << (dslParser.INT_08 - 46)) | (1 << (dslParser.INT_09 - 46)) | (1 << (dslParser.INT_10 - 46)) | (1 << (dslParser.INT_11 - 46)) | (1 << (dslParser.INT_12 - 46)) | (1 << (dslParser.INT_13 - 46)) | (1 << (dslParser.INT_14 - 46)) | (1 << (dslParser.INT_15 - 46)) | (1 << (dslParser.INT_16 - 46)) | (1 << (dslParser.INT_17 - 46)) | (1 << (dslParser.INT_18 - 46)) | (1 << (dslParser.INT_19 - 46)) | (1 << (dslParser.INT_20 - 46)) | (1 << (dslParser.INT_21 - 46)) | (1 << (dslParser.INT_22 - 46)) | (1 << (dslParser.INT_23 - 46)) | (1 << (dslParser.INT_24 - 46)) | (1 << (dslParser.INT_25 - 46)) | (1 << (dslParser.INT_26 - 46)) | (1 << (dslParser.INT_27 - 46)) | (1 << (dslParser.INT_28 - 46)) | (1 << (dslParser.INT_29 - 46)) | (1 << (dslParser.INT_30 - 46)) | (1 << (dslParser.INT_31 - 46)) | (1 << (dslParser.INT_32 - 46)) | (1 << (dslParser.INT_33 - 46)) | (1 << (dslParser.INT_34 - 46)) | (1 << (dslParser.INT_35 - 46)) | (1 << (dslParser.INT_36 - 46)) | (1 << (dslParser.INT_37 - 46)) | (1 << (dslParser.INT_38 - 46)) | (1 << (dslParser.INT_39 - 46)) | (1 << (dslParser.INT_40 - 46)) | (1 << (dslParser.INT_41 - 46)) | (1 << (dslParser.INT_42 - 46)) | (1 << (dslParser.INT_43 - 46)) | (1 << (dslParser.INT_44 - 46)) | (1 << (dslParser.INT_45 - 46)) | (1 << (dslParser.INT_46 - 46)) | (1 << (dslParser.INT_47 - 46)) | (1 << (dslParser.INT_48 - 46)) | (1 << (dslParser.INT_49 - 46)) | (1 << (dslParser.INT_50 - 46)) | (1 << (dslParser.INT_51 - 46)) | (1 << (dslParser.INT_52 - 46)) | (1 << (dslParser.INT_53 - 46)) | (1 << (dslParser.INT_54 - 46)) | (1 << (dslParser.INT_55 - 46)) | (1 << (dslParser.INT_56 - 46)) | (1 << (dslParser.INT_57 - 46)) | (1 << (dslParser.INT_58 - 46)) | (1 << (dslParser.INT_59 - 46)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DirectMessageContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIRECT_MESSAGE(self):
            return self.getToken(dslParser.DIRECT_MESSAGE, 0)

        def direct_message_required_parameters(self):
            return self.getTypedRuleContext(dslParser.Direct_message_required_parametersContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_directMessage

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirectMessage" ):
                listener.enterDirectMessage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirectMessage" ):
                listener.exitDirectMessage(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirectMessage" ):
                return visitor.visitDirectMessage(self)
            else:
                return visitor.visitChildren(self)




    def directMessage(self):

        localctx = dslParser.DirectMessageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_directMessage)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            self.match(dslParser.DIRECT_MESSAGE)
            self.state = 210
            self.direct_message_required_parameters()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Direct_message_required_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(dslParser.ID, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COLON)
            else:
                return self.getToken(dslParser.COLON, i)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def TEXT(self):
            return self.getToken(dslParser.TEXT, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_direct_message_required_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirect_message_required_parameters" ):
                listener.enterDirect_message_required_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirect_message_required_parameters" ):
                listener.exitDirect_message_required_parameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirect_message_required_parameters" ):
                return visitor.visitDirect_message_required_parameters(self)
            else:
                return visitor.visitChildren(self)




    def direct_message_required_parameters(self):

        localctx = dslParser.Direct_message_required_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_direct_message_required_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 212
            self.match(dslParser.ID)
            self.state = 213
            self.match(dslParser.COLON)
            self.state = 214
            self.number()
            self.state = 215
            self.match(dslParser.COMMA)
            self.state = 216
            self.match(dslParser.TEXT)
            self.state = 217
            self.match(dslParser.COLON)
            self.state = 218
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutoFavouriteRetweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def keywords(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.KeywordsContext)
            else:
                return self.getTypedRuleContext(dslParser.KeywordsContext,i)


        def getRuleIndex(self):
            return dslParser.RULE_autoFavouriteRetweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutoFavouriteRetweet" ):
                listener.enterAutoFavouriteRetweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutoFavouriteRetweet" ):
                listener.exitAutoFavouriteRetweet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAutoFavouriteRetweet" ):
                return visitor.visitAutoFavouriteRetweet(self)
            else:
                return visitor.visitChildren(self)




    def autoFavouriteRetweet(self):

        localctx = dslParser.AutoFavouriteRetweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_autoFavouriteRetweet)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 221 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 220
                self.keywords()
                self.state = 223 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==dslParser.KEYWORD):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutoFollowFollowersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOLLOWALL(self):
            return self.getToken(dslParser.FOLLOWALL, 0)

        def getRuleIndex(self):
            return dslParser.RULE_autoFollowFollowers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutoFollowFollowers" ):
                listener.enterAutoFollowFollowers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutoFollowFollowers" ):
                listener.exitAutoFollowFollowers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAutoFollowFollowers" ):
                return visitor.visitAutoFollowFollowers(self)
            else:
                return visitor.visitChildren(self)




    def autoFollowFollowers(self):

        localctx = dslParser.AutoFollowFollowersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_autoFollowFollowers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 225
            self.match(dslParser.FOLLOWALL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutoReplyMentionsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def keywords(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.KeywordsContext)
            else:
                return self.getTypedRuleContext(dslParser.KeywordsContext,i)


        def getRuleIndex(self):
            return dslParser.RULE_autoReplyMentions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutoReplyMentions" ):
                listener.enterAutoReplyMentions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutoReplyMentions" ):
                listener.exitAutoReplyMentions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAutoReplyMentions" ):
                return visitor.visitAutoReplyMentions(self)
            else:
                return visitor.visitChildren(self)




    def autoReplyMentions(self):

        localctx = dslParser.AutoReplyMentionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_autoReplyMentions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 228 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 227
                self.keywords()
                self.state = 230 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==dslParser.KEYWORD):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeywordsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEYWORD(self):
            return self.getToken(dslParser.KEYWORD, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_keywords

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeywords" ):
                listener.enterKeywords(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeywords" ):
                listener.exitKeywords(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeywords" ):
                return visitor.visitKeywords(self)
            else:
                return visitor.visitChildren(self)




    def keywords(self):

        localctx = dslParser.KeywordsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_keywords)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 232
            self.match(dslParser.KEYWORD)
            self.state = 233
            self.match(dslParser.COLON)
            self.state = 234
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringValueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def StringLiteral(self):
            return self.getToken(dslParser.StringLiteral, 0)

        def getRuleIndex(self):
            return dslParser.RULE_stringValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringValue" ):
                listener.enterStringValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringValue" ):
                listener.exitStringValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringValue" ):
                return visitor.visitStringValue(self)
            else:
                return visitor.visitChildren(self)




    def stringValue(self):

        localctx = dslParser.StringValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_stringValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 236
            self.match(dslParser.StringLiteral)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unsigned_number(self):
            return self.getTypedRuleContext(dslParser.Unsigned_numberContext,0)


        def unary_operator(self):
            return self.getTypedRuleContext(dslParser.Unary_operatorContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)




    def number(self):

        localctx = dslParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 239
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dslParser.T__0 or _la==dslParser.T__1:
                self.state = 238
                self.unary_operator()


            self.state = 241
            self.unsigned_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unary_operatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return dslParser.RULE_unary_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnary_operator" ):
                listener.enterUnary_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnary_operator" ):
                listener.exitUnary_operator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnary_operator" ):
                return visitor.visitUnary_operator(self)
            else:
                return visitor.visitChildren(self)




    def unary_operator(self):

        localctx = dslParser.Unary_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_unary_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 243
            _la = self._input.LA(1)
            if not(_la==dslParser.T__0 or _la==dslParser.T__1):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unsigned_numberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNSIGNED_INT(self):
            return self.getToken(dslParser.UNSIGNED_INT, 0)

        def UNSIGNED_FLOAT(self):
            return self.getToken(dslParser.UNSIGNED_FLOAT, 0)

        def getRuleIndex(self):
            return dslParser.RULE_unsigned_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnsigned_number" ):
                listener.enterUnsigned_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnsigned_number" ):
                listener.exitUnsigned_number(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnsigned_number" ):
                return visitor.visitUnsigned_number(self)
            else:
                return visitor.visitChildren(self)




    def unsigned_number(self):

        localctx = dslParser.Unsigned_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_unsigned_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 245
            _la = self._input.LA(1)
            if not(_la==dslParser.UNSIGNED_INT or _la==dslParser.UNSIGNED_FLOAT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(dslParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(dslParser.FALSE, 0)

        def getRuleIndex(self):
            return dslParser.RULE_boolean

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolean" ):
                listener.enterBoolean(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolean" ):
                listener.exitBoolean(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolean" ):
                return visitor.visitBoolean(self)
            else:
                return visitor.visitChildren(self)




    def boolean(self):

        localctx = dslParser.BooleanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_boolean)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 247
            _la = self._input.LA(1)
            if not(_la==dslParser.TRUE or _la==dslParser.FALSE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





