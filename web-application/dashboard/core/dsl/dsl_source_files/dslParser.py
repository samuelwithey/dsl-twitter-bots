# Generated from dsl.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3i")
        buf.write("\u00e1\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\3\2\3\2\3\2")
        buf.write("\3\2\3\2\7\2N\n\2\f\2\16\2Q\13\2\3\3\3\3\3\4\3\4\3\4\3")
        buf.write("\4\3\4\3\4\5\4[\n\4\3\5\3\5\3\5\3\5\7\5a\n\5\f\5\16\5")
        buf.write("d\13\5\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\7\3\7\3\7\3\7\3\7\3\7\5\7y\n\7\3\b\3\b\3\b\3\b")
        buf.write("\7\b\177\n\b\f\b\16\b\u0082\13\b\3\t\3\t\3\t\3\t\3\t\3")
        buf.write("\t\3\t\3\t\3\n\3\n\3\n\3\13\3\13\3\13\3\13\3\f\3\f\3\f")
        buf.write("\3\r\3\r\3\r\3\r\3\16\3\16\3\16\3\17\3\17\3\17\3\17\3")
        buf.write("\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\21\3\21\3\22")
        buf.write("\3\22\3\22\3\22\3\23\3\23\3\23\3\23\3\24\3\24\3\25\3\25")
        buf.write("\3\26\3\26\3\27\3\27\3\30\3\30\3\31\3\31\3\32\3\32\3\32")
        buf.write("\3\32\3\33\3\33\3\34\3\34\3\35\3\35\3\36\3\36\3\36\3\37")
        buf.write("\3\37\3\37\3\37\3\37\3\37\3\37\3\37\3 \3 \3!\5!\u00d7")
        buf.write("\n!\3!\3!\3\"\3\"\3#\3#\3$\3$\3$\2\2%\2\4\6\b\n\f\16\20")
        buf.write("\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<>@BDF\2\t")
        buf.write("\4\2%-/:\4\2%-/M\3\2.F\3\2.i\3\2\3\4\3\2\7\b\3\2\n\13")
        buf.write("\2\u00ca\2H\3\2\2\2\4R\3\2\2\2\6Z\3\2\2\2\b\\\3\2\2\2")
        buf.write("\ne\3\2\2\2\fx\3\2\2\2\16z\3\2\2\2\20\u0083\3\2\2\2\22")
        buf.write("\u008b\3\2\2\2\24\u008e\3\2\2\2\26\u0092\3\2\2\2\30\u0095")
        buf.write("\3\2\2\2\32\u0099\3\2\2\2\34\u009c\3\2\2\2\36\u00a0\3")
        buf.write("\2\2\2 \u00a8\3\2\2\2\"\u00aa\3\2\2\2$\u00ae\3\2\2\2&")
        buf.write("\u00b2\3\2\2\2(\u00b4\3\2\2\2*\u00b6\3\2\2\2,\u00b8\3")
        buf.write("\2\2\2.\u00ba\3\2\2\2\60\u00bc\3\2\2\2\62\u00be\3\2\2")
        buf.write("\2\64\u00c2\3\2\2\2\66\u00c4\3\2\2\28\u00c6\3\2\2\2:\u00c8")
        buf.write("\3\2\2\2<\u00cb\3\2\2\2>\u00d3\3\2\2\2@\u00d6\3\2\2\2")
        buf.write("B\u00da\3\2\2\2D\u00dc\3\2\2\2F\u00de\3\2\2\2HI\5\4\3")
        buf.write("\2IO\7\35\2\2JK\5\4\3\2KL\7\35\2\2LN\3\2\2\2MJ\3\2\2\2")
        buf.write("NQ\3\2\2\2OM\3\2\2\2OP\3\2\2\2P\3\3\2\2\2QO\3\2\2\2RS")
        buf.write("\5\6\4\2S\5\3\2\2\2T[\5\b\5\2U[\5\16\b\2V[\5\22\n\2W[")
        buf.write("\5\26\f\2X[\5\32\16\2Y[\5:\36\2ZT\3\2\2\2ZU\3\2\2\2ZV")
        buf.write("\3\2\2\2ZW\3\2\2\2ZX\3\2\2\2ZY\3\2\2\2[\7\3\2\2\2\\]\7")
        buf.write("\r\2\2]b\5\n\6\2^_\7\34\2\2_a\5\f\7\2`^\3\2\2\2ad\3\2")
        buf.write("\2\2b`\3\2\2\2bc\3\2\2\2c\t\3\2\2\2db\3\2\2\2ef\7\17\2")
        buf.write("\2fg\7\36\2\2gh\5> \2h\13\3\2\2\2ij\7\20\2\2jk\7\36\2")
        buf.write("\2ky\5F$\2lm\7\t\2\2mn\7\36\2\2ny\5@!\2op\7\21\2\2pq\7")
        buf.write("\36\2\2qy\5@!\2rs\7\22\2\2st\7\36\2\2ty\5> \2uv\7\23\2")
        buf.write("\2vw\7\36\2\2wy\5F$\2xi\3\2\2\2xl\3\2\2\2xo\3\2\2\2xr")
        buf.write("\3\2\2\2xu\3\2\2\2y\r\3\2\2\2z{\7\24\2\2{\u0080\5\20\t")
        buf.write("\2|}\7\34\2\2}\177\5\f\7\2~|\3\2\2\2\177\u0082\3\2\2\2")
        buf.write("\u0080~\3\2\2\2\u0080\u0081\3\2\2\2\u0081\17\3\2\2\2\u0082")
        buf.write("\u0080\3\2\2\2\u0083\u0084\7\16\2\2\u0084\u0085\7\36\2")
        buf.write("\2\u0085\u0086\5@!\2\u0086\u0087\7\34\2\2\u0087\u0088")
        buf.write("\7\17\2\2\u0088\u0089\7\36\2\2\u0089\u008a\5> \2\u008a")
        buf.write("\21\3\2\2\2\u008b\u008c\7\25\2\2\u008c\u008d\5\24\13\2")
        buf.write("\u008d\23\3\2\2\2\u008e\u008f\7\f\2\2\u008f\u0090\7\36")
        buf.write("\2\2\u0090\u0091\5@!\2\u0091\25\3\2\2\2\u0092\u0093\7")
        buf.write("\27\2\2\u0093\u0094\5\30\r\2\u0094\27\3\2\2\2\u0095\u0096")
        buf.write("\7\f\2\2\u0096\u0097\7\36\2\2\u0097\u0098\5@!\2\u0098")
        buf.write("\31\3\2\2\2\u0099\u009a\7\30\2\2\u009a\u009b\5\34\17\2")
        buf.write("\u009b\33\3\2\2\2\u009c\u009d\5\36\20\2\u009d\u009e\7")
        buf.write("\34\2\2\u009e\u009f\5\b\5\2\u009f\35\3\2\2\2\u00a0\u00a1")
        buf.write("\7\31\2\2\u00a1\u00a2\7\36\2\2\u00a2\u00a3\5 \21\2\u00a3")
        buf.write("\u00a4\7\34\2\2\u00a4\u00a5\7\32\2\2\u00a5\u00a6\7\36")
        buf.write("\2\2\u00a6\u00a7\5\60\31\2\u00a7\37\3\2\2\2\u00a8\u00a9")
        buf.write("\5\"\22\2\u00a9!\3\2\2\2\u00aa\u00ab\5$\23\2\u00ab\u00ac")
        buf.write("\5.\30\2\u00ac\u00ad\5,\27\2\u00ad#\3\2\2\2\u00ae\u00af")
        buf.write("\5*\26\2\u00af\u00b0\5.\30\2\u00b0\u00b1\5&\24\2\u00b1")
        buf.write("%\3\2\2\2\u00b2\u00b3\5(\25\2\u00b3\'\3\2\2\2\u00b4\u00b5")
        buf.write("\t\2\2\2\u00b5)\3\2\2\2\u00b6\u00b7\t\3\2\2\u00b7+\3\2")
        buf.write("\2\2\u00b8\u00b9\7\"\2\2\u00b9-\3\2\2\2\u00ba\u00bb\7")
        buf.write(" \2\2\u00bb/\3\2\2\2\u00bc\u00bd\5\62\32\2\u00bd\61\3")
        buf.write("\2\2\2\u00be\u00bf\5\66\34\2\u00bf\u00c0\5\64\33\2\u00c0")
        buf.write("\u00c1\58\35\2\u00c1\63\3\2\2\2\u00c2\u00c3\7!\2\2\u00c3")
        buf.write("\65\3\2\2\2\u00c4\u00c5\t\4\2\2\u00c5\67\3\2\2\2\u00c6")
        buf.write("\u00c7\t\5\2\2\u00c79\3\2\2\2\u00c8\u00c9\7\26\2\2\u00c9")
        buf.write("\u00ca\5<\37\2\u00ca;\3\2\2\2\u00cb\u00cc\7\f\2\2\u00cc")
        buf.write("\u00cd\7\36\2\2\u00cd\u00ce\5@!\2\u00ce\u00cf\7\34\2\2")
        buf.write("\u00cf\u00d0\7\33\2\2\u00d0\u00d1\7\36\2\2\u00d1\u00d2")
        buf.write("\5> \2\u00d2=\3\2\2\2\u00d3\u00d4\7\5\2\2\u00d4?\3\2\2")
        buf.write("\2\u00d5\u00d7\5B\"\2\u00d6\u00d5\3\2\2\2\u00d6\u00d7")
        buf.write("\3\2\2\2\u00d7\u00d8\3\2\2\2\u00d8\u00d9\5D#\2\u00d9A")
        buf.write("\3\2\2\2\u00da\u00db\t\6\2\2\u00dbC\3\2\2\2\u00dc\u00dd")
        buf.write("\t\7\2\2\u00ddE\3\2\2\2\u00de\u00df\t\b\2\2\u00dfG\3\2")
        buf.write("\2\2\bOZbx\u0080\u00d6")
        return buf.getvalue()


class dslParser ( Parser ):

    grammarFileName = "dsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'+'", "'-'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'lat'", "'True'", "'False'", 
                     "'id'", "'tweet'", "'in_reply_to_status_id'", "'status'", 
                     "'possibly_sensitive'", "'long'", "'place_id'", "'display_coordinates'", 
                     "'reply'", "'retweet'", "'direct_message'", "'favourite'", 
                     "'schedule'", "'date'", "'time'", "'text'", "','", 
                     "';'", "':'", "<INVALID>", "'/'", "'.'", "<INVALID>", 
                     "<INVALID>", "'0'", "'1'", "'2'", "'3'", "'4'", "'5'", 
                     "'6'", "'7'", "'8'", "'9'", "'00'", "'01'", "'02'", 
                     "'03'", "'04'", "'05'", "'06'", "'07'", "'08'", "'09'", 
                     "'10'", "'11'", "'12'", "'13'", "'14'", "'15'", "'16'", 
                     "'17'", "'18'", "'19'", "'20'", "'21'", "'22'", "'23'", 
                     "'24'", "'25'", "'26'", "'27'", "'28'", "'29'", "'30'", 
                     "'31'", "'32'", "'33'", "'34'", "'35'", "'36'", "'37'", 
                     "'38'", "'39'", "'40'", "'41'", "'42'", "'43'", "'44'", 
                     "'45'", "'46'", "'47'", "'48'", "'49'", "'50'", "'51'", 
                     "'52'", "'53'", "'54'", "'55'", "'56'", "'57'", "'58'", 
                     "'59'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "StringLiteral", 
                      "UnterminatedStringLiteral", "UNSIGNED_INT", "UNSIGNED_FLOAT", 
                      "LAT", "TRUE", "FALSE", "ID", "TWEET", "REPLY_ID", 
                      "STATUS", "POSSIBLY_SENSITIVE", "LONG", "PLACE_ID", 
                      "DISPLAY_COORDINATES", "REPLY", "RETWEET", "DIRECT_MESSAGE", 
                      "FAVOURITE", "SCHEDULE", "DATE", "TIME", "TEXT", "COMMA", 
                      "SEMICOLON", "COLON", "WS", "SLASH", "DOT", "FOUR_DIGIT", 
                      "DIGIT", "INT_0", "INT_1", "INT_2", "INT_3", "INT_4", 
                      "INT_5", "INT_6", "INT_7", "INT_8", "INT_9", "INT_00", 
                      "INT_01", "INT_02", "INT_03", "INT_04", "INT_05", 
                      "INT_06", "INT_07", "INT_08", "INT_09", "INT_10", 
                      "INT_11", "INT_12", "INT_13", "INT_14", "INT_15", 
                      "INT_16", "INT_17", "INT_18", "INT_19", "INT_20", 
                      "INT_21", "INT_22", "INT_23", "INT_24", "INT_25", 
                      "INT_26", "INT_27", "INT_28", "INT_29", "INT_30", 
                      "INT_31", "INT_32", "INT_33", "INT_34", "INT_35", 
                      "INT_36", "INT_37", "INT_38", "INT_39", "INT_40", 
                      "INT_41", "INT_42", "INT_43", "INT_44", "INT_45", 
                      "INT_46", "INT_47", "INT_48", "INT_49", "INT_50", 
                      "INT_51", "INT_52", "INT_53", "INT_54", "INT_55", 
                      "INT_56", "INT_57", "INT_58", "INT_59" ]

    RULE_twitbot = 0
    RULE_stat = 1
    RULE_action = 2
    RULE_tweet = 3
    RULE_tweet_required_parameter = 4
    RULE_tweet_optional_parameters = 5
    RULE_reply = 6
    RULE_reply_required_parameters = 7
    RULE_retweet = 8
    RULE_retweet_required_parameter = 9
    RULE_favourite = 10
    RULE_favourite_required_parameter = 11
    RULE_scheduleTweet = 12
    RULE_schedule_tweet_required_parameter = 13
    RULE_date_time_parameter = 14
    RULE_date = 15
    RULE_day_month_year = 16
    RULE_day_month = 17
    RULE_month = 18
    RULE_numeric_month = 19
    RULE_numeric_day = 20
    RULE_year = 21
    RULE_date_separator = 22
    RULE_time = 23
    RULE_hour_minute = 24
    RULE_time_separator = 25
    RULE_numeric_hour = 26
    RULE_numeric_minute = 27
    RULE_directMessage = 28
    RULE_direct_message_required_parameters = 29
    RULE_stringValue = 30
    RULE_number = 31
    RULE_unary_operator = 32
    RULE_unsigned_number = 33
    RULE_boolean = 34

    ruleNames =  [ "twitbot", "stat", "action", "tweet", "tweet_required_parameter", 
                   "tweet_optional_parameters", "reply", "reply_required_parameters", 
                   "retweet", "retweet_required_parameter", "favourite", 
                   "favourite_required_parameter", "scheduleTweet", "schedule_tweet_required_parameter", 
                   "date_time_parameter", "date", "day_month_year", "day_month", 
                   "month", "numeric_month", "numeric_day", "year", "date_separator", 
                   "time", "hour_minute", "time_separator", "numeric_hour", 
                   "numeric_minute", "directMessage", "direct_message_required_parameters", 
                   "stringValue", "number", "unary_operator", "unsigned_number", 
                   "boolean" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    StringLiteral=3
    UnterminatedStringLiteral=4
    UNSIGNED_INT=5
    UNSIGNED_FLOAT=6
    LAT=7
    TRUE=8
    FALSE=9
    ID=10
    TWEET=11
    REPLY_ID=12
    STATUS=13
    POSSIBLY_SENSITIVE=14
    LONG=15
    PLACE_ID=16
    DISPLAY_COORDINATES=17
    REPLY=18
    RETWEET=19
    DIRECT_MESSAGE=20
    FAVOURITE=21
    SCHEDULE=22
    DATE=23
    TIME=24
    TEXT=25
    COMMA=26
    SEMICOLON=27
    COLON=28
    WS=29
    SLASH=30
    DOT=31
    FOUR_DIGIT=32
    DIGIT=33
    INT_0=34
    INT_1=35
    INT_2=36
    INT_3=37
    INT_4=38
    INT_5=39
    INT_6=40
    INT_7=41
    INT_8=42
    INT_9=43
    INT_00=44
    INT_01=45
    INT_02=46
    INT_03=47
    INT_04=48
    INT_05=49
    INT_06=50
    INT_07=51
    INT_08=52
    INT_09=53
    INT_10=54
    INT_11=55
    INT_12=56
    INT_13=57
    INT_14=58
    INT_15=59
    INT_16=60
    INT_17=61
    INT_18=62
    INT_19=63
    INT_20=64
    INT_21=65
    INT_22=66
    INT_23=67
    INT_24=68
    INT_25=69
    INT_26=70
    INT_27=71
    INT_28=72
    INT_29=73
    INT_30=74
    INT_31=75
    INT_32=76
    INT_33=77
    INT_34=78
    INT_35=79
    INT_36=80
    INT_37=81
    INT_38=82
    INT_39=83
    INT_40=84
    INT_41=85
    INT_42=86
    INT_43=87
    INT_44=88
    INT_45=89
    INT_46=90
    INT_47=91
    INT_48=92
    INT_49=93
    INT_50=94
    INT_51=95
    INT_52=96
    INT_53=97
    INT_54=98
    INT_55=99
    INT_56=100
    INT_57=101
    INT_58=102
    INT_59=103

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class TwitbotContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.StatContext)
            else:
                return self.getTypedRuleContext(dslParser.StatContext,i)


        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.SEMICOLON)
            else:
                return self.getToken(dslParser.SEMICOLON, i)

        def getRuleIndex(self):
            return dslParser.RULE_twitbot

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTwitbot" ):
                listener.enterTwitbot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTwitbot" ):
                listener.exitTwitbot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTwitbot" ):
                return visitor.visitTwitbot(self)
            else:
                return visitor.visitChildren(self)




    def twitbot(self):

        localctx = dslParser.TwitbotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_twitbot)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 70
            self.stat()
            self.state = 71
            self.match(dslParser.SEMICOLON)
            self.state = 77
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << dslParser.TWEET) | (1 << dslParser.REPLY) | (1 << dslParser.RETWEET) | (1 << dslParser.DIRECT_MESSAGE) | (1 << dslParser.FAVOURITE) | (1 << dslParser.SCHEDULE))) != 0):
                self.state = 72
                self.stat()
                self.state = 73
                self.match(dslParser.SEMICOLON)
                self.state = 79
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action(self):
            return self.getTypedRuleContext(dslParser.ActionContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_stat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat" ):
                listener.enterStat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat" ):
                listener.exitStat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat" ):
                return visitor.visitStat(self)
            else:
                return visitor.visitChildren(self)




    def stat(self):

        localctx = dslParser.StatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_stat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 80
            self.action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tweet(self):
            return self.getTypedRuleContext(dslParser.TweetContext,0)


        def reply(self):
            return self.getTypedRuleContext(dslParser.ReplyContext,0)


        def retweet(self):
            return self.getTypedRuleContext(dslParser.RetweetContext,0)


        def favourite(self):
            return self.getTypedRuleContext(dslParser.FavouriteContext,0)


        def scheduleTweet(self):
            return self.getTypedRuleContext(dslParser.ScheduleTweetContext,0)


        def directMessage(self):
            return self.getTypedRuleContext(dslParser.DirectMessageContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction" ):
                return visitor.visitAction(self)
            else:
                return visitor.visitChildren(self)




    def action(self):

        localctx = dslParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_action)
        try:
            self.state = 88
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dslParser.TWEET]:
                self.enterOuterAlt(localctx, 1)
                self.state = 82
                self.tweet()
                pass
            elif token in [dslParser.REPLY]:
                self.enterOuterAlt(localctx, 2)
                self.state = 83
                self.reply()
                pass
            elif token in [dslParser.RETWEET]:
                self.enterOuterAlt(localctx, 3)
                self.state = 84
                self.retweet()
                pass
            elif token in [dslParser.FAVOURITE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 85
                self.favourite()
                pass
            elif token in [dslParser.SCHEDULE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 86
                self.scheduleTweet()
                pass
            elif token in [dslParser.DIRECT_MESSAGE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 87
                self.directMessage()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TWEET(self):
            return self.getToken(dslParser.TWEET, 0)

        def tweet_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Tweet_required_parameterContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def tweet_optional_parameters(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.Tweet_optional_parametersContext)
            else:
                return self.getTypedRuleContext(dslParser.Tweet_optional_parametersContext,i)


        def getRuleIndex(self):
            return dslParser.RULE_tweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweet" ):
                listener.enterTweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweet" ):
                listener.exitTweet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTweet" ):
                return visitor.visitTweet(self)
            else:
                return visitor.visitChildren(self)




    def tweet(self):

        localctx = dslParser.TweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_tweet)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 90
            self.match(dslParser.TWEET)
            self.state = 91
            self.tweet_required_parameter()
            self.state = 96
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dslParser.COMMA:
                self.state = 92
                self.match(dslParser.COMMA)
                self.state = 93
                self.tweet_optional_parameters()
                self.state = 98
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tweet_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STATUS(self):
            return self.getToken(dslParser.STATUS, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_tweet_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweet_required_parameter" ):
                listener.enterTweet_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweet_required_parameter" ):
                listener.exitTweet_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTweet_required_parameter" ):
                return visitor.visitTweet_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def tweet_required_parameter(self):

        localctx = dslParser.Tweet_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_tweet_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            self.match(dslParser.STATUS)
            self.state = 100
            self.match(dslParser.COLON)
            self.state = 101
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tweet_optional_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POSSIBLY_SENSITIVE(self):
            return self.getToken(dslParser.POSSIBLY_SENSITIVE, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def boolean(self):
            return self.getTypedRuleContext(dslParser.BooleanContext,0)


        def LAT(self):
            return self.getToken(dslParser.LAT, 0)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def LONG(self):
            return self.getToken(dslParser.LONG, 0)

        def PLACE_ID(self):
            return self.getToken(dslParser.PLACE_ID, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def DISPLAY_COORDINATES(self):
            return self.getToken(dslParser.DISPLAY_COORDINATES, 0)

        def getRuleIndex(self):
            return dslParser.RULE_tweet_optional_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweet_optional_parameters" ):
                listener.enterTweet_optional_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweet_optional_parameters" ):
                listener.exitTweet_optional_parameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTweet_optional_parameters" ):
                return visitor.visitTweet_optional_parameters(self)
            else:
                return visitor.visitChildren(self)




    def tweet_optional_parameters(self):

        localctx = dslParser.Tweet_optional_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_tweet_optional_parameters)
        try:
            self.state = 118
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dslParser.POSSIBLY_SENSITIVE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 103
                self.match(dslParser.POSSIBLY_SENSITIVE)
                self.state = 104
                self.match(dslParser.COLON)
                self.state = 105
                self.boolean()
                pass
            elif token in [dslParser.LAT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 106
                self.match(dslParser.LAT)
                self.state = 107
                self.match(dslParser.COLON)
                self.state = 108
                self.number()
                pass
            elif token in [dslParser.LONG]:
                self.enterOuterAlt(localctx, 3)
                self.state = 109
                self.match(dslParser.LONG)
                self.state = 110
                self.match(dslParser.COLON)
                self.state = 111
                self.number()
                pass
            elif token in [dslParser.PLACE_ID]:
                self.enterOuterAlt(localctx, 4)
                self.state = 112
                self.match(dslParser.PLACE_ID)
                self.state = 113
                self.match(dslParser.COLON)
                self.state = 114
                self.stringValue()
                pass
            elif token in [dslParser.DISPLAY_COORDINATES]:
                self.enterOuterAlt(localctx, 5)
                self.state = 115
                self.match(dslParser.DISPLAY_COORDINATES)
                self.state = 116
                self.match(dslParser.COLON)
                self.state = 117
                self.boolean()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPLY(self):
            return self.getToken(dslParser.REPLY, 0)

        def reply_required_parameters(self):
            return self.getTypedRuleContext(dslParser.Reply_required_parametersContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def tweet_optional_parameters(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.Tweet_optional_parametersContext)
            else:
                return self.getTypedRuleContext(dslParser.Tweet_optional_parametersContext,i)


        def getRuleIndex(self):
            return dslParser.RULE_reply

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReply" ):
                listener.enterReply(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReply" ):
                listener.exitReply(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReply" ):
                return visitor.visitReply(self)
            else:
                return visitor.visitChildren(self)




    def reply(self):

        localctx = dslParser.ReplyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_reply)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 120
            self.match(dslParser.REPLY)
            self.state = 121
            self.reply_required_parameters()
            self.state = 126
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dslParser.COMMA:
                self.state = 122
                self.match(dslParser.COMMA)
                self.state = 123
                self.tweet_optional_parameters()
                self.state = 128
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reply_required_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPLY_ID(self):
            return self.getToken(dslParser.REPLY_ID, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COLON)
            else:
                return self.getToken(dslParser.COLON, i)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def STATUS(self):
            return self.getToken(dslParser.STATUS, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_reply_required_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReply_required_parameters" ):
                listener.enterReply_required_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReply_required_parameters" ):
                listener.exitReply_required_parameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReply_required_parameters" ):
                return visitor.visitReply_required_parameters(self)
            else:
                return visitor.visitChildren(self)




    def reply_required_parameters(self):

        localctx = dslParser.Reply_required_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_reply_required_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self.match(dslParser.REPLY_ID)
            self.state = 130
            self.match(dslParser.COLON)
            self.state = 131
            self.number()
            self.state = 132
            self.match(dslParser.COMMA)
            self.state = 133
            self.match(dslParser.STATUS)
            self.state = 134
            self.match(dslParser.COLON)
            self.state = 135
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RetweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETWEET(self):
            return self.getToken(dslParser.RETWEET, 0)

        def retweet_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Retweet_required_parameterContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_retweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRetweet" ):
                listener.enterRetweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRetweet" ):
                listener.exitRetweet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRetweet" ):
                return visitor.visitRetweet(self)
            else:
                return visitor.visitChildren(self)




    def retweet(self):

        localctx = dslParser.RetweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_retweet)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            self.match(dslParser.RETWEET)
            self.state = 138
            self.retweet_required_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Retweet_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(dslParser.ID, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_retweet_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRetweet_required_parameter" ):
                listener.enterRetweet_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRetweet_required_parameter" ):
                listener.exitRetweet_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRetweet_required_parameter" ):
                return visitor.visitRetweet_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def retweet_required_parameter(self):

        localctx = dslParser.Retweet_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_retweet_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            self.match(dslParser.ID)
            self.state = 141
            self.match(dslParser.COLON)
            self.state = 142
            self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FavouriteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FAVOURITE(self):
            return self.getToken(dslParser.FAVOURITE, 0)

        def favourite_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Favourite_required_parameterContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_favourite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFavourite" ):
                listener.enterFavourite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFavourite" ):
                listener.exitFavourite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFavourite" ):
                return visitor.visitFavourite(self)
            else:
                return visitor.visitChildren(self)




    def favourite(self):

        localctx = dslParser.FavouriteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_favourite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 144
            self.match(dslParser.FAVOURITE)
            self.state = 145
            self.favourite_required_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Favourite_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(dslParser.ID, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_favourite_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFavourite_required_parameter" ):
                listener.enterFavourite_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFavourite_required_parameter" ):
                listener.exitFavourite_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFavourite_required_parameter" ):
                return visitor.visitFavourite_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def favourite_required_parameter(self):

        localctx = dslParser.Favourite_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_favourite_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 147
            self.match(dslParser.ID)
            self.state = 148
            self.match(dslParser.COLON)
            self.state = 149
            self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScheduleTweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCHEDULE(self):
            return self.getToken(dslParser.SCHEDULE, 0)

        def schedule_tweet_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Schedule_tweet_required_parameterContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_scheduleTweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScheduleTweet" ):
                listener.enterScheduleTweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScheduleTweet" ):
                listener.exitScheduleTweet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScheduleTweet" ):
                return visitor.visitScheduleTweet(self)
            else:
                return visitor.visitChildren(self)




    def scheduleTweet(self):

        localctx = dslParser.ScheduleTweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_scheduleTweet)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            self.match(dslParser.SCHEDULE)
            self.state = 152
            self.schedule_tweet_required_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Schedule_tweet_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def date_time_parameter(self):
            return self.getTypedRuleContext(dslParser.Date_time_parameterContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def tweet(self):
            return self.getTypedRuleContext(dslParser.TweetContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_schedule_tweet_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchedule_tweet_required_parameter" ):
                listener.enterSchedule_tweet_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchedule_tweet_required_parameter" ):
                listener.exitSchedule_tweet_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSchedule_tweet_required_parameter" ):
                return visitor.visitSchedule_tweet_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def schedule_tweet_required_parameter(self):

        localctx = dslParser.Schedule_tweet_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_schedule_tweet_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 154
            self.date_time_parameter()
            self.state = 155
            self.match(dslParser.COMMA)
            self.state = 156
            self.tweet()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Date_time_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE(self):
            return self.getToken(dslParser.DATE, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COLON)
            else:
                return self.getToken(dslParser.COLON, i)

        def date(self):
            return self.getTypedRuleContext(dslParser.DateContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def TIME(self):
            return self.getToken(dslParser.TIME, 0)

        def time(self):
            return self.getTypedRuleContext(dslParser.TimeContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_date_time_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate_time_parameter" ):
                listener.enterDate_time_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate_time_parameter" ):
                listener.exitDate_time_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDate_time_parameter" ):
                return visitor.visitDate_time_parameter(self)
            else:
                return visitor.visitChildren(self)




    def date_time_parameter(self):

        localctx = dslParser.Date_time_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_date_time_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 158
            self.match(dslParser.DATE)
            self.state = 159
            self.match(dslParser.COLON)
            self.state = 160
            self.date()
            self.state = 161
            self.match(dslParser.COMMA)
            self.state = 162
            self.match(dslParser.TIME)
            self.state = 163
            self.match(dslParser.COLON)
            self.state = 164
            self.time()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def day_month_year(self):
            return self.getTypedRuleContext(dslParser.Day_month_yearContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDate" ):
                return visitor.visitDate(self)
            else:
                return visitor.visitChildren(self)




    def date(self):

        localctx = dslParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166
            self.day_month_year()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Day_month_yearContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def day_month(self):
            return self.getTypedRuleContext(dslParser.Day_monthContext,0)


        def date_separator(self):
            return self.getTypedRuleContext(dslParser.Date_separatorContext,0)


        def year(self):
            return self.getTypedRuleContext(dslParser.YearContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_day_month_year

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDay_month_year" ):
                listener.enterDay_month_year(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDay_month_year" ):
                listener.exitDay_month_year(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDay_month_year" ):
                return visitor.visitDay_month_year(self)
            else:
                return visitor.visitChildren(self)




    def day_month_year(self):

        localctx = dslParser.Day_month_yearContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_day_month_year)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            self.day_month()
            self.state = 169
            self.date_separator()
            self.state = 170
            self.year()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Day_monthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeric_day(self):
            return self.getTypedRuleContext(dslParser.Numeric_dayContext,0)


        def date_separator(self):
            return self.getTypedRuleContext(dslParser.Date_separatorContext,0)


        def month(self):
            return self.getTypedRuleContext(dslParser.MonthContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_day_month

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDay_month" ):
                listener.enterDay_month(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDay_month" ):
                listener.exitDay_month(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDay_month" ):
                return visitor.visitDay_month(self)
            else:
                return visitor.visitChildren(self)




    def day_month(self):

        localctx = dslParser.Day_monthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_day_month)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self.numeric_day()
            self.state = 173
            self.date_separator()
            self.state = 174
            self.month()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MonthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeric_month(self):
            return self.getTypedRuleContext(dslParser.Numeric_monthContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_month

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMonth" ):
                listener.enterMonth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMonth" ):
                listener.exitMonth(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMonth" ):
                return visitor.visitMonth(self)
            else:
                return visitor.visitChildren(self)




    def month(self):

        localctx = dslParser.MonthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_month)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 176
            self.numeric_month()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_monthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_1(self):
            return self.getToken(dslParser.INT_1, 0)

        def INT_2(self):
            return self.getToken(dslParser.INT_2, 0)

        def INT_3(self):
            return self.getToken(dslParser.INT_3, 0)

        def INT_4(self):
            return self.getToken(dslParser.INT_4, 0)

        def INT_5(self):
            return self.getToken(dslParser.INT_5, 0)

        def INT_6(self):
            return self.getToken(dslParser.INT_6, 0)

        def INT_7(self):
            return self.getToken(dslParser.INT_7, 0)

        def INT_8(self):
            return self.getToken(dslParser.INT_8, 0)

        def INT_9(self):
            return self.getToken(dslParser.INT_9, 0)

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_month

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_month" ):
                listener.enterNumeric_month(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_month" ):
                listener.exitNumeric_month(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_month" ):
                return visitor.visitNumeric_month(self)
            else:
                return visitor.visitChildren(self)




    def numeric_month(self):

        localctx = dslParser.Numeric_monthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_numeric_month)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 178
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << dslParser.INT_1) | (1 << dslParser.INT_2) | (1 << dslParser.INT_3) | (1 << dslParser.INT_4) | (1 << dslParser.INT_5) | (1 << dslParser.INT_6) | (1 << dslParser.INT_7) | (1 << dslParser.INT_8) | (1 << dslParser.INT_9) | (1 << dslParser.INT_01) | (1 << dslParser.INT_02) | (1 << dslParser.INT_03) | (1 << dslParser.INT_04) | (1 << dslParser.INT_05) | (1 << dslParser.INT_06) | (1 << dslParser.INT_07) | (1 << dslParser.INT_08) | (1 << dslParser.INT_09) | (1 << dslParser.INT_10) | (1 << dslParser.INT_11) | (1 << dslParser.INT_12))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_dayContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_1(self):
            return self.getToken(dslParser.INT_1, 0)

        def INT_2(self):
            return self.getToken(dslParser.INT_2, 0)

        def INT_3(self):
            return self.getToken(dslParser.INT_3, 0)

        def INT_4(self):
            return self.getToken(dslParser.INT_4, 0)

        def INT_5(self):
            return self.getToken(dslParser.INT_5, 0)

        def INT_6(self):
            return self.getToken(dslParser.INT_6, 0)

        def INT_7(self):
            return self.getToken(dslParser.INT_7, 0)

        def INT_8(self):
            return self.getToken(dslParser.INT_8, 0)

        def INT_9(self):
            return self.getToken(dslParser.INT_9, 0)

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def INT_13(self):
            return self.getToken(dslParser.INT_13, 0)

        def INT_14(self):
            return self.getToken(dslParser.INT_14, 0)

        def INT_15(self):
            return self.getToken(dslParser.INT_15, 0)

        def INT_16(self):
            return self.getToken(dslParser.INT_16, 0)

        def INT_17(self):
            return self.getToken(dslParser.INT_17, 0)

        def INT_18(self):
            return self.getToken(dslParser.INT_18, 0)

        def INT_19(self):
            return self.getToken(dslParser.INT_19, 0)

        def INT_20(self):
            return self.getToken(dslParser.INT_20, 0)

        def INT_21(self):
            return self.getToken(dslParser.INT_21, 0)

        def INT_22(self):
            return self.getToken(dslParser.INT_22, 0)

        def INT_23(self):
            return self.getToken(dslParser.INT_23, 0)

        def INT_24(self):
            return self.getToken(dslParser.INT_24, 0)

        def INT_25(self):
            return self.getToken(dslParser.INT_25, 0)

        def INT_26(self):
            return self.getToken(dslParser.INT_26, 0)

        def INT_27(self):
            return self.getToken(dslParser.INT_27, 0)

        def INT_28(self):
            return self.getToken(dslParser.INT_28, 0)

        def INT_29(self):
            return self.getToken(dslParser.INT_29, 0)

        def INT_30(self):
            return self.getToken(dslParser.INT_30, 0)

        def INT_31(self):
            return self.getToken(dslParser.INT_31, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_day

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_day" ):
                listener.enterNumeric_day(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_day" ):
                listener.exitNumeric_day(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_day" ):
                return visitor.visitNumeric_day(self)
            else:
                return visitor.visitChildren(self)




    def numeric_day(self):

        localctx = dslParser.Numeric_dayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_numeric_day)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 180
            _la = self._input.LA(1)
            if not(((((_la - 35)) & ~0x3f) == 0 and ((1 << (_la - 35)) & ((1 << (dslParser.INT_1 - 35)) | (1 << (dslParser.INT_2 - 35)) | (1 << (dslParser.INT_3 - 35)) | (1 << (dslParser.INT_4 - 35)) | (1 << (dslParser.INT_5 - 35)) | (1 << (dslParser.INT_6 - 35)) | (1 << (dslParser.INT_7 - 35)) | (1 << (dslParser.INT_8 - 35)) | (1 << (dslParser.INT_9 - 35)) | (1 << (dslParser.INT_01 - 35)) | (1 << (dslParser.INT_02 - 35)) | (1 << (dslParser.INT_03 - 35)) | (1 << (dslParser.INT_04 - 35)) | (1 << (dslParser.INT_05 - 35)) | (1 << (dslParser.INT_06 - 35)) | (1 << (dslParser.INT_07 - 35)) | (1 << (dslParser.INT_08 - 35)) | (1 << (dslParser.INT_09 - 35)) | (1 << (dslParser.INT_10 - 35)) | (1 << (dslParser.INT_11 - 35)) | (1 << (dslParser.INT_12 - 35)) | (1 << (dslParser.INT_13 - 35)) | (1 << (dslParser.INT_14 - 35)) | (1 << (dslParser.INT_15 - 35)) | (1 << (dslParser.INT_16 - 35)) | (1 << (dslParser.INT_17 - 35)) | (1 << (dslParser.INT_18 - 35)) | (1 << (dslParser.INT_19 - 35)) | (1 << (dslParser.INT_20 - 35)) | (1 << (dslParser.INT_21 - 35)) | (1 << (dslParser.INT_22 - 35)) | (1 << (dslParser.INT_23 - 35)) | (1 << (dslParser.INT_24 - 35)) | (1 << (dslParser.INT_25 - 35)) | (1 << (dslParser.INT_26 - 35)) | (1 << (dslParser.INT_27 - 35)) | (1 << (dslParser.INT_28 - 35)) | (1 << (dslParser.INT_29 - 35)) | (1 << (dslParser.INT_30 - 35)) | (1 << (dslParser.INT_31 - 35)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YearContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOUR_DIGIT(self):
            return self.getToken(dslParser.FOUR_DIGIT, 0)

        def getRuleIndex(self):
            return dslParser.RULE_year

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYear" ):
                listener.enterYear(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYear" ):
                listener.exitYear(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYear" ):
                return visitor.visitYear(self)
            else:
                return visitor.visitChildren(self)




    def year(self):

        localctx = dslParser.YearContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_year)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self.match(dslParser.FOUR_DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Date_separatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SLASH(self):
            return self.getToken(dslParser.SLASH, 0)

        def getRuleIndex(self):
            return dslParser.RULE_date_separator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate_separator" ):
                listener.enterDate_separator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate_separator" ):
                listener.exitDate_separator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDate_separator" ):
                return visitor.visitDate_separator(self)
            else:
                return visitor.visitChildren(self)




    def date_separator(self):

        localctx = dslParser.Date_separatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_date_separator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 184
            self.match(dslParser.SLASH)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def hour_minute(self):
            return self.getTypedRuleContext(dslParser.Hour_minuteContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_time

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime" ):
                listener.enterTime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime" ):
                listener.exitTime(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime" ):
                return visitor.visitTime(self)
            else:
                return visitor.visitChildren(self)




    def time(self):

        localctx = dslParser.TimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_time)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 186
            self.hour_minute()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Hour_minuteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeric_hour(self):
            return self.getTypedRuleContext(dslParser.Numeric_hourContext,0)


        def time_separator(self):
            return self.getTypedRuleContext(dslParser.Time_separatorContext,0)


        def numeric_minute(self):
            return self.getTypedRuleContext(dslParser.Numeric_minuteContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_hour_minute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHour_minute" ):
                listener.enterHour_minute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHour_minute" ):
                listener.exitHour_minute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHour_minute" ):
                return visitor.visitHour_minute(self)
            else:
                return visitor.visitChildren(self)




    def hour_minute(self):

        localctx = dslParser.Hour_minuteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_hour_minute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 188
            self.numeric_hour()
            self.state = 189
            self.time_separator()
            self.state = 190
            self.numeric_minute()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Time_separatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOT(self):
            return self.getToken(dslParser.DOT, 0)

        def getRuleIndex(self):
            return dslParser.RULE_time_separator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_separator" ):
                listener.enterTime_separator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_separator" ):
                listener.exitTime_separator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime_separator" ):
                return visitor.visitTime_separator(self)
            else:
                return visitor.visitChildren(self)




    def time_separator(self):

        localctx = dslParser.Time_separatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_time_separator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 192
            self.match(dslParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_hourContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def INT_13(self):
            return self.getToken(dslParser.INT_13, 0)

        def INT_14(self):
            return self.getToken(dslParser.INT_14, 0)

        def INT_15(self):
            return self.getToken(dslParser.INT_15, 0)

        def INT_16(self):
            return self.getToken(dslParser.INT_16, 0)

        def INT_17(self):
            return self.getToken(dslParser.INT_17, 0)

        def INT_18(self):
            return self.getToken(dslParser.INT_18, 0)

        def INT_19(self):
            return self.getToken(dslParser.INT_19, 0)

        def INT_20(self):
            return self.getToken(dslParser.INT_20, 0)

        def INT_21(self):
            return self.getToken(dslParser.INT_21, 0)

        def INT_22(self):
            return self.getToken(dslParser.INT_22, 0)

        def INT_23(self):
            return self.getToken(dslParser.INT_23, 0)

        def INT_24(self):
            return self.getToken(dslParser.INT_24, 0)

        def INT_00(self):
            return self.getToken(dslParser.INT_00, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_hour

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_hour" ):
                listener.enterNumeric_hour(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_hour" ):
                listener.exitNumeric_hour(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_hour" ):
                return visitor.visitNumeric_hour(self)
            else:
                return visitor.visitChildren(self)




    def numeric_hour(self):

        localctx = dslParser.Numeric_hourContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_numeric_hour)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 194
            _la = self._input.LA(1)
            if not(((((_la - 44)) & ~0x3f) == 0 and ((1 << (_la - 44)) & ((1 << (dslParser.INT_00 - 44)) | (1 << (dslParser.INT_01 - 44)) | (1 << (dslParser.INT_02 - 44)) | (1 << (dslParser.INT_03 - 44)) | (1 << (dslParser.INT_04 - 44)) | (1 << (dslParser.INT_05 - 44)) | (1 << (dslParser.INT_06 - 44)) | (1 << (dslParser.INT_07 - 44)) | (1 << (dslParser.INT_08 - 44)) | (1 << (dslParser.INT_09 - 44)) | (1 << (dslParser.INT_10 - 44)) | (1 << (dslParser.INT_11 - 44)) | (1 << (dslParser.INT_12 - 44)) | (1 << (dslParser.INT_13 - 44)) | (1 << (dslParser.INT_14 - 44)) | (1 << (dslParser.INT_15 - 44)) | (1 << (dslParser.INT_16 - 44)) | (1 << (dslParser.INT_17 - 44)) | (1 << (dslParser.INT_18 - 44)) | (1 << (dslParser.INT_19 - 44)) | (1 << (dslParser.INT_20 - 44)) | (1 << (dslParser.INT_21 - 44)) | (1 << (dslParser.INT_22 - 44)) | (1 << (dslParser.INT_23 - 44)) | (1 << (dslParser.INT_24 - 44)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_minuteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def INT_13(self):
            return self.getToken(dslParser.INT_13, 0)

        def INT_14(self):
            return self.getToken(dslParser.INT_14, 0)

        def INT_15(self):
            return self.getToken(dslParser.INT_15, 0)

        def INT_16(self):
            return self.getToken(dslParser.INT_16, 0)

        def INT_17(self):
            return self.getToken(dslParser.INT_17, 0)

        def INT_18(self):
            return self.getToken(dslParser.INT_18, 0)

        def INT_19(self):
            return self.getToken(dslParser.INT_19, 0)

        def INT_20(self):
            return self.getToken(dslParser.INT_20, 0)

        def INT_21(self):
            return self.getToken(dslParser.INT_21, 0)

        def INT_22(self):
            return self.getToken(dslParser.INT_22, 0)

        def INT_23(self):
            return self.getToken(dslParser.INT_23, 0)

        def INT_24(self):
            return self.getToken(dslParser.INT_24, 0)

        def INT_25(self):
            return self.getToken(dslParser.INT_25, 0)

        def INT_26(self):
            return self.getToken(dslParser.INT_26, 0)

        def INT_27(self):
            return self.getToken(dslParser.INT_27, 0)

        def INT_28(self):
            return self.getToken(dslParser.INT_28, 0)

        def INT_29(self):
            return self.getToken(dslParser.INT_29, 0)

        def INT_30(self):
            return self.getToken(dslParser.INT_30, 0)

        def INT_31(self):
            return self.getToken(dslParser.INT_31, 0)

        def INT_32(self):
            return self.getToken(dslParser.INT_32, 0)

        def INT_33(self):
            return self.getToken(dslParser.INT_33, 0)

        def INT_34(self):
            return self.getToken(dslParser.INT_34, 0)

        def INT_35(self):
            return self.getToken(dslParser.INT_35, 0)

        def INT_36(self):
            return self.getToken(dslParser.INT_36, 0)

        def INT_37(self):
            return self.getToken(dslParser.INT_37, 0)

        def INT_38(self):
            return self.getToken(dslParser.INT_38, 0)

        def INT_39(self):
            return self.getToken(dslParser.INT_39, 0)

        def INT_40(self):
            return self.getToken(dslParser.INT_40, 0)

        def INT_41(self):
            return self.getToken(dslParser.INT_41, 0)

        def INT_42(self):
            return self.getToken(dslParser.INT_42, 0)

        def INT_43(self):
            return self.getToken(dslParser.INT_43, 0)

        def INT_44(self):
            return self.getToken(dslParser.INT_44, 0)

        def INT_45(self):
            return self.getToken(dslParser.INT_45, 0)

        def INT_46(self):
            return self.getToken(dslParser.INT_46, 0)

        def INT_47(self):
            return self.getToken(dslParser.INT_47, 0)

        def INT_48(self):
            return self.getToken(dslParser.INT_48, 0)

        def INT_49(self):
            return self.getToken(dslParser.INT_49, 0)

        def INT_50(self):
            return self.getToken(dslParser.INT_50, 0)

        def INT_51(self):
            return self.getToken(dslParser.INT_51, 0)

        def INT_52(self):
            return self.getToken(dslParser.INT_52, 0)

        def INT_53(self):
            return self.getToken(dslParser.INT_53, 0)

        def INT_54(self):
            return self.getToken(dslParser.INT_54, 0)

        def INT_55(self):
            return self.getToken(dslParser.INT_55, 0)

        def INT_56(self):
            return self.getToken(dslParser.INT_56, 0)

        def INT_57(self):
            return self.getToken(dslParser.INT_57, 0)

        def INT_58(self):
            return self.getToken(dslParser.INT_58, 0)

        def INT_59(self):
            return self.getToken(dslParser.INT_59, 0)

        def INT_00(self):
            return self.getToken(dslParser.INT_00, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_minute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_minute" ):
                listener.enterNumeric_minute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_minute" ):
                listener.exitNumeric_minute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_minute" ):
                return visitor.visitNumeric_minute(self)
            else:
                return visitor.visitChildren(self)




    def numeric_minute(self):

        localctx = dslParser.Numeric_minuteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_numeric_minute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 196
            _la = self._input.LA(1)
            if not(((((_la - 44)) & ~0x3f) == 0 and ((1 << (_la - 44)) & ((1 << (dslParser.INT_00 - 44)) | (1 << (dslParser.INT_01 - 44)) | (1 << (dslParser.INT_02 - 44)) | (1 << (dslParser.INT_03 - 44)) | (1 << (dslParser.INT_04 - 44)) | (1 << (dslParser.INT_05 - 44)) | (1 << (dslParser.INT_06 - 44)) | (1 << (dslParser.INT_07 - 44)) | (1 << (dslParser.INT_08 - 44)) | (1 << (dslParser.INT_09 - 44)) | (1 << (dslParser.INT_10 - 44)) | (1 << (dslParser.INT_11 - 44)) | (1 << (dslParser.INT_12 - 44)) | (1 << (dslParser.INT_13 - 44)) | (1 << (dslParser.INT_14 - 44)) | (1 << (dslParser.INT_15 - 44)) | (1 << (dslParser.INT_16 - 44)) | (1 << (dslParser.INT_17 - 44)) | (1 << (dslParser.INT_18 - 44)) | (1 << (dslParser.INT_19 - 44)) | (1 << (dslParser.INT_20 - 44)) | (1 << (dslParser.INT_21 - 44)) | (1 << (dslParser.INT_22 - 44)) | (1 << (dslParser.INT_23 - 44)) | (1 << (dslParser.INT_24 - 44)) | (1 << (dslParser.INT_25 - 44)) | (1 << (dslParser.INT_26 - 44)) | (1 << (dslParser.INT_27 - 44)) | (1 << (dslParser.INT_28 - 44)) | (1 << (dslParser.INT_29 - 44)) | (1 << (dslParser.INT_30 - 44)) | (1 << (dslParser.INT_31 - 44)) | (1 << (dslParser.INT_32 - 44)) | (1 << (dslParser.INT_33 - 44)) | (1 << (dslParser.INT_34 - 44)) | (1 << (dslParser.INT_35 - 44)) | (1 << (dslParser.INT_36 - 44)) | (1 << (dslParser.INT_37 - 44)) | (1 << (dslParser.INT_38 - 44)) | (1 << (dslParser.INT_39 - 44)) | (1 << (dslParser.INT_40 - 44)) | (1 << (dslParser.INT_41 - 44)) | (1 << (dslParser.INT_42 - 44)) | (1 << (dslParser.INT_43 - 44)) | (1 << (dslParser.INT_44 - 44)) | (1 << (dslParser.INT_45 - 44)) | (1 << (dslParser.INT_46 - 44)) | (1 << (dslParser.INT_47 - 44)) | (1 << (dslParser.INT_48 - 44)) | (1 << (dslParser.INT_49 - 44)) | (1 << (dslParser.INT_50 - 44)) | (1 << (dslParser.INT_51 - 44)) | (1 << (dslParser.INT_52 - 44)) | (1 << (dslParser.INT_53 - 44)) | (1 << (dslParser.INT_54 - 44)) | (1 << (dslParser.INT_55 - 44)) | (1 << (dslParser.INT_56 - 44)) | (1 << (dslParser.INT_57 - 44)) | (1 << (dslParser.INT_58 - 44)) | (1 << (dslParser.INT_59 - 44)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DirectMessageContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIRECT_MESSAGE(self):
            return self.getToken(dslParser.DIRECT_MESSAGE, 0)

        def direct_message_required_parameters(self):
            return self.getTypedRuleContext(dslParser.Direct_message_required_parametersContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_directMessage

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirectMessage" ):
                listener.enterDirectMessage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirectMessage" ):
                listener.exitDirectMessage(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirectMessage" ):
                return visitor.visitDirectMessage(self)
            else:
                return visitor.visitChildren(self)




    def directMessage(self):

        localctx = dslParser.DirectMessageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_directMessage)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 198
            self.match(dslParser.DIRECT_MESSAGE)
            self.state = 199
            self.direct_message_required_parameters()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Direct_message_required_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(dslParser.ID, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COLON)
            else:
                return self.getToken(dslParser.COLON, i)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def TEXT(self):
            return self.getToken(dslParser.TEXT, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_direct_message_required_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirect_message_required_parameters" ):
                listener.enterDirect_message_required_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirect_message_required_parameters" ):
                listener.exitDirect_message_required_parameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirect_message_required_parameters" ):
                return visitor.visitDirect_message_required_parameters(self)
            else:
                return visitor.visitChildren(self)




    def direct_message_required_parameters(self):

        localctx = dslParser.Direct_message_required_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_direct_message_required_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self.match(dslParser.ID)
            self.state = 202
            self.match(dslParser.COLON)
            self.state = 203
            self.number()
            self.state = 204
            self.match(dslParser.COMMA)
            self.state = 205
            self.match(dslParser.TEXT)
            self.state = 206
            self.match(dslParser.COLON)
            self.state = 207
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringValueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def StringLiteral(self):
            return self.getToken(dslParser.StringLiteral, 0)

        def getRuleIndex(self):
            return dslParser.RULE_stringValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringValue" ):
                listener.enterStringValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringValue" ):
                listener.exitStringValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringValue" ):
                return visitor.visitStringValue(self)
            else:
                return visitor.visitChildren(self)




    def stringValue(self):

        localctx = dslParser.StringValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_stringValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            self.match(dslParser.StringLiteral)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unsigned_number(self):
            return self.getTypedRuleContext(dslParser.Unsigned_numberContext,0)


        def unary_operator(self):
            return self.getTypedRuleContext(dslParser.Unary_operatorContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)




    def number(self):

        localctx = dslParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 212
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dslParser.T__0 or _la==dslParser.T__1:
                self.state = 211
                self.unary_operator()


            self.state = 214
            self.unsigned_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unary_operatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return dslParser.RULE_unary_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnary_operator" ):
                listener.enterUnary_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnary_operator" ):
                listener.exitUnary_operator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnary_operator" ):
                return visitor.visitUnary_operator(self)
            else:
                return visitor.visitChildren(self)




    def unary_operator(self):

        localctx = dslParser.Unary_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_unary_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 216
            _la = self._input.LA(1)
            if not(_la==dslParser.T__0 or _la==dslParser.T__1):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unsigned_numberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNSIGNED_INT(self):
            return self.getToken(dslParser.UNSIGNED_INT, 0)

        def UNSIGNED_FLOAT(self):
            return self.getToken(dslParser.UNSIGNED_FLOAT, 0)

        def getRuleIndex(self):
            return dslParser.RULE_unsigned_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnsigned_number" ):
                listener.enterUnsigned_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnsigned_number" ):
                listener.exitUnsigned_number(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnsigned_number" ):
                return visitor.visitUnsigned_number(self)
            else:
                return visitor.visitChildren(self)




    def unsigned_number(self):

        localctx = dslParser.Unsigned_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_unsigned_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 218
            _la = self._input.LA(1)
            if not(_la==dslParser.UNSIGNED_INT or _la==dslParser.UNSIGNED_FLOAT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(dslParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(dslParser.FALSE, 0)

        def getRuleIndex(self):
            return dslParser.RULE_boolean

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolean" ):
                listener.enterBoolean(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolean" ):
                listener.exitBoolean(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolean" ):
                return visitor.visitBoolean(self)
            else:
                return visitor.visitChildren(self)




    def boolean(self):

        localctx = dslParser.BooleanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_boolean)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 220
            _la = self._input.LA(1)
            if not(_la==dslParser.TRUE or _la==dslParser.FALSE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





