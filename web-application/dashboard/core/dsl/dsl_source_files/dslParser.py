# Generated from dsl.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3o")
        buf.write("\u010d\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\3\2\3\2\3\2\3\2\3\2\7\2X\n\2\f\2")
        buf.write("\16\2[\13\2\3\3\3\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3")
        buf.write("\4\5\4h\n\4\3\5\3\5\3\5\3\5\7\5n\n\5\f\5\16\5q\13\5\3")
        buf.write("\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7")
        buf.write("\3\7\3\7\3\7\3\7\3\7\5\7\u0086\n\7\3\b\3\b\3\b\3\b\7\b")
        buf.write("\u008c\n\b\f\b\16\b\u008f\13\b\3\t\3\t\3\t\3\t\3\t\3\t")
        buf.write("\3\t\3\t\3\n\3\n\3\n\3\13\3\13\3\13\3\13\3\f\3\f\3\f\3")
        buf.write("\r\3\r\3\r\3\r\3\16\3\16\3\16\3\17\3\17\3\17\3\17\3\20")
        buf.write("\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\21\3\21\3\22\3\22")
        buf.write("\3\22\3\22\3\23\3\23\3\23\3\23\3\24\3\24\3\25\3\25\3\26")
        buf.write("\3\26\3\27\3\27\3\30\3\30\3\31\3\31\3\32\3\32\3\32\3\32")
        buf.write("\3\33\3\33\3\34\3\34\3\35\3\35\3\36\3\36\3\36\3\37\3\37")
        buf.write("\3\37\3\37\3\37\3\37\3\37\3\37\3 \3 \3 \3 \7 \u00e5\n")
        buf.write(" \f \16 \u00e8\13 \3!\3!\3\"\3\"\3\"\3\"\6\"\u00f0\n\"")
        buf.write("\r\"\16\"\u00f1\3#\3#\3#\3#\3#\3#\3#\3#\3$\3$\3$\3$\3")
        buf.write("%\3%\3&\5&\u0103\n&\3&\3&\3\'\3\'\3(\3(\3)\3)\3)\2\2*")
        buf.write("\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62")
        buf.write("\64\668:<>@BDFHJLNP\2\t\4\2+\63\65@\4\2+\63\65S\3\2\64")
        buf.write("L\3\2\64o\3\2\3\4\3\2\7\b\3\2\n\13\2\u00f6\2R\3\2\2\2")
        buf.write("\4\\\3\2\2\2\6g\3\2\2\2\bi\3\2\2\2\nr\3\2\2\2\f\u0085")
        buf.write("\3\2\2\2\16\u0087\3\2\2\2\20\u0090\3\2\2\2\22\u0098\3")
        buf.write("\2\2\2\24\u009b\3\2\2\2\26\u009f\3\2\2\2\30\u00a2\3\2")
        buf.write("\2\2\32\u00a6\3\2\2\2\34\u00a9\3\2\2\2\36\u00ad\3\2\2")
        buf.write("\2 \u00b5\3\2\2\2\"\u00b7\3\2\2\2$\u00bb\3\2\2\2&\u00bf")
        buf.write("\3\2\2\2(\u00c1\3\2\2\2*\u00c3\3\2\2\2,\u00c5\3\2\2\2")
        buf.write(".\u00c7\3\2\2\2\60\u00c9\3\2\2\2\62\u00cb\3\2\2\2\64\u00cf")
        buf.write("\3\2\2\2\66\u00d1\3\2\2\28\u00d3\3\2\2\2:\u00d5\3\2\2")
        buf.write("\2<\u00d8\3\2\2\2>\u00e0\3\2\2\2@\u00e9\3\2\2\2B\u00eb")
        buf.write("\3\2\2\2D\u00f3\3\2\2\2F\u00fb\3\2\2\2H\u00ff\3\2\2\2")
        buf.write("J\u0102\3\2\2\2L\u0106\3\2\2\2N\u0108\3\2\2\2P\u010a\3")
        buf.write("\2\2\2RS\5\4\3\2SY\7\35\2\2TU\5\4\3\2UV\7\35\2\2VX\3\2")
        buf.write("\2\2WT\3\2\2\2X[\3\2\2\2YW\3\2\2\2YZ\3\2\2\2Z\3\3\2\2")
        buf.write("\2[Y\3\2\2\2\\]\5\6\4\2]\5\3\2\2\2^h\5\b\5\2_h\5\16\b")
        buf.write("\2`h\5\22\n\2ah\5\26\f\2bh\5\32\16\2ch\5:\36\2dh\5> \2")
        buf.write("eh\5@!\2fh\5B\"\2g^\3\2\2\2g_\3\2\2\2g`\3\2\2\2ga\3\2")
        buf.write("\2\2gb\3\2\2\2gc\3\2\2\2gd\3\2\2\2ge\3\2\2\2gf\3\2\2\2")
        buf.write("h\7\3\2\2\2ij\7\r\2\2jo\5\n\6\2kl\7\34\2\2ln\5\f\7\2m")
        buf.write("k\3\2\2\2nq\3\2\2\2om\3\2\2\2op\3\2\2\2p\t\3\2\2\2qo\3")
        buf.write("\2\2\2rs\7\17\2\2st\7\36\2\2tu\5H%\2u\13\3\2\2\2vw\7\20")
        buf.write("\2\2wx\7\36\2\2x\u0086\5P)\2yz\7\t\2\2z{\7\36\2\2{\u0086")
        buf.write("\5J&\2|}\7\21\2\2}~\7\36\2\2~\u0086\5J&\2\177\u0080\7")
        buf.write("\22\2\2\u0080\u0081\7\36\2\2\u0081\u0086\5H%\2\u0082\u0083")
        buf.write("\7\23\2\2\u0083\u0084\7\36\2\2\u0084\u0086\5P)\2\u0085")
        buf.write("v\3\2\2\2\u0085y\3\2\2\2\u0085|\3\2\2\2\u0085\177\3\2")
        buf.write("\2\2\u0085\u0082\3\2\2\2\u0086\r\3\2\2\2\u0087\u0088\7")
        buf.write("\24\2\2\u0088\u008d\5\20\t\2\u0089\u008a\7\34\2\2\u008a")
        buf.write("\u008c\5\f\7\2\u008b\u0089\3\2\2\2\u008c\u008f\3\2\2\2")
        buf.write("\u008d\u008b\3\2\2\2\u008d\u008e\3\2\2\2\u008e\17\3\2")
        buf.write("\2\2\u008f\u008d\3\2\2\2\u0090\u0091\7\16\2\2\u0091\u0092")
        buf.write("\7\36\2\2\u0092\u0093\5J&\2\u0093\u0094\7\34\2\2\u0094")
        buf.write("\u0095\7\17\2\2\u0095\u0096\7\36\2\2\u0096\u0097\5H%\2")
        buf.write("\u0097\21\3\2\2\2\u0098\u0099\7\25\2\2\u0099\u009a\5\24")
        buf.write("\13\2\u009a\23\3\2\2\2\u009b\u009c\7\f\2\2\u009c\u009d")
        buf.write("\7\36\2\2\u009d\u009e\5J&\2\u009e\25\3\2\2\2\u009f\u00a0")
        buf.write("\7\27\2\2\u00a0\u00a1\5\30\r\2\u00a1\27\3\2\2\2\u00a2")
        buf.write("\u00a3\7\f\2\2\u00a3\u00a4\7\36\2\2\u00a4\u00a5\5J&\2")
        buf.write("\u00a5\31\3\2\2\2\u00a6\u00a7\7\30\2\2\u00a7\u00a8\5\34")
        buf.write("\17\2\u00a8\33\3\2\2\2\u00a9\u00aa\5\36\20\2\u00aa\u00ab")
        buf.write("\7\34\2\2\u00ab\u00ac\5\b\5\2\u00ac\35\3\2\2\2\u00ad\u00ae")
        buf.write("\7\31\2\2\u00ae\u00af\7\36\2\2\u00af\u00b0\5 \21\2\u00b0")
        buf.write("\u00b1\7\34\2\2\u00b1\u00b2\7\32\2\2\u00b2\u00b3\7\36")
        buf.write("\2\2\u00b3\u00b4\5\60\31\2\u00b4\37\3\2\2\2\u00b5\u00b6")
        buf.write("\5\"\22\2\u00b6!\3\2\2\2\u00b7\u00b8\5$\23\2\u00b8\u00b9")
        buf.write("\5.\30\2\u00b9\u00ba\5,\27\2\u00ba#\3\2\2\2\u00bb\u00bc")
        buf.write("\5*\26\2\u00bc\u00bd\5.\30\2\u00bd\u00be\5&\24\2\u00be")
        buf.write("%\3\2\2\2\u00bf\u00c0\5(\25\2\u00c0\'\3\2\2\2\u00c1\u00c2")
        buf.write("\t\2\2\2\u00c2)\3\2\2\2\u00c3\u00c4\t\3\2\2\u00c4+\3\2")
        buf.write("\2\2\u00c5\u00c6\7(\2\2\u00c6-\3\2\2\2\u00c7\u00c8\7&")
        buf.write("\2\2\u00c8/\3\2\2\2\u00c9\u00ca\5\62\32\2\u00ca\61\3\2")
        buf.write("\2\2\u00cb\u00cc\5\66\34\2\u00cc\u00cd\5\64\33\2\u00cd")
        buf.write("\u00ce\58\35\2\u00ce\63\3\2\2\2\u00cf\u00d0\7\'\2\2\u00d0")
        buf.write("\65\3\2\2\2\u00d1\u00d2\t\4\2\2\u00d2\67\3\2\2\2\u00d3")
        buf.write("\u00d4\t\5\2\2\u00d49\3\2\2\2\u00d5\u00d6\7\26\2\2\u00d6")
        buf.write("\u00d7\5<\37\2\u00d7;\3\2\2\2\u00d8\u00d9\7\f\2\2\u00d9")
        buf.write("\u00da\7\36\2\2\u00da\u00db\5J&\2\u00db\u00dc\7\34\2\2")
        buf.write("\u00dc\u00dd\7\33\2\2\u00dd\u00de\7\36\2\2\u00de\u00df")
        buf.write("\5H%\2\u00df=\3\2\2\2\u00e0\u00e1\7%\2\2\u00e1\u00e6\5")
        buf.write("F$\2\u00e2\u00e3\7\34\2\2\u00e3\u00e5\5F$\2\u00e4\u00e2")
        buf.write("\3\2\2\2\u00e5\u00e8\3\2\2\2\u00e6\u00e4\3\2\2\2\u00e6")
        buf.write("\u00e7\3\2\2\2\u00e7?\3\2\2\2\u00e8\u00e6\3\2\2\2\u00e9")
        buf.write("\u00ea\7 \2\2\u00eaA\3\2\2\2\u00eb\u00ec\7#\2\2\u00ec")
        buf.write("\u00ef\5D#\2\u00ed\u00ee\7\34\2\2\u00ee\u00f0\5F$\2\u00ef")
        buf.write("\u00ed\3\2\2\2\u00f0\u00f1\3\2\2\2\u00f1\u00ef\3\2\2\2")
        buf.write("\u00f1\u00f2\3\2\2\2\u00f2C\3\2\2\2\u00f3\u00f4\7!\2\2")
        buf.write("\u00f4\u00f5\7\36\2\2\u00f5\u00f6\5J&\2\u00f6\u00f7\7")
        buf.write("\34\2\2\u00f7\u00f8\7\"\2\2\u00f8\u00f9\7\36\2\2\u00f9")
        buf.write("\u00fa\5H%\2\u00faE\3\2\2\2\u00fb\u00fc\7\37\2\2\u00fc")
        buf.write("\u00fd\7\36\2\2\u00fd\u00fe\5H%\2\u00feG\3\2\2\2\u00ff")
        buf.write("\u0100\7\5\2\2\u0100I\3\2\2\2\u0101\u0103\5L\'\2\u0102")
        buf.write("\u0101\3\2\2\2\u0102\u0103\3\2\2\2\u0103\u0104\3\2\2\2")
        buf.write("\u0104\u0105\5N(\2\u0105K\3\2\2\2\u0106\u0107\t\6\2\2")
        buf.write("\u0107M\3\2\2\2\u0108\u0109\t\7\2\2\u0109O\3\2\2\2\u010a")
        buf.write("\u010b\t\b\2\2\u010bQ\3\2\2\2\nYgo\u0085\u008d\u00e6\u00f1")
        buf.write("\u0102")
        return buf.getvalue()


class dslParser ( Parser ):

    grammarFileName = "dsl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'+'", "'-'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'lat'", "'True'", "'False'", 
                     "'id'", "'tweet'", "'in_reply_to_status_id'", "'status'", 
                     "'possibly_sensitive'", "'long'", "'place_id'", "'display_coordinates'", 
                     "'reply'", "'retweet'", "'direct_message'", "'favourite'", 
                     "'schedule'", "'date'", "'time'", "'text'", "','", 
                     "';'", "':'", "'keyword'", "'follow_all_followers'", 
                     "'automate_time_minutes'", "'response'", "'automate_reply_to_mentions'", 
                     "<INVALID>", "'automate_favourites_retweets'", "'/'", 
                     "'.'", "<INVALID>", "<INVALID>", "'0'", "'1'", "'2'", 
                     "'3'", "'4'", "'5'", "'6'", "'7'", "'8'", "'9'", "'00'", 
                     "'01'", "'02'", "'03'", "'04'", "'05'", "'06'", "'07'", 
                     "'08'", "'09'", "'10'", "'11'", "'12'", "'13'", "'14'", 
                     "'15'", "'16'", "'17'", "'18'", "'19'", "'20'", "'21'", 
                     "'22'", "'23'", "'24'", "'25'", "'26'", "'27'", "'28'", 
                     "'29'", "'30'", "'31'", "'32'", "'33'", "'34'", "'35'", 
                     "'36'", "'37'", "'38'", "'39'", "'40'", "'41'", "'42'", 
                     "'43'", "'44'", "'45'", "'46'", "'47'", "'48'", "'49'", 
                     "'50'", "'51'", "'52'", "'53'", "'54'", "'55'", "'56'", 
                     "'57'", "'58'", "'59'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "StringLiteral", 
                      "UnterminatedStringLiteral", "UNSIGNED_INT", "UNSIGNED_FLOAT", 
                      "LAT", "TRUE", "FALSE", "ID", "TWEET", "REPLY_ID", 
                      "STATUS", "POSSIBLY_SENSITIVE", "LONG", "PLACE_ID", 
                      "DISPLAY_COORDINATES", "REPLY", "RETWEET", "DIRECT_MESSAGE", 
                      "FAVOURITE", "SCHEDULE", "DATE", "TIME", "TEXT", "COMMA", 
                      "SEMICOLON", "COLON", "KEYWORD", "FOLLOWALL", "AUTOMATE_TIME", 
                      "RESPONSE", "AUTOMATE_REPLY_MENTIONS", "WS", "AUTO_FAV_RETWEET", 
                      "SLASH", "DOT", "FOUR_DIGIT", "DIGIT", "INT_0", "INT_1", 
                      "INT_2", "INT_3", "INT_4", "INT_5", "INT_6", "INT_7", 
                      "INT_8", "INT_9", "INT_00", "INT_01", "INT_02", "INT_03", 
                      "INT_04", "INT_05", "INT_06", "INT_07", "INT_08", 
                      "INT_09", "INT_10", "INT_11", "INT_12", "INT_13", 
                      "INT_14", "INT_15", "INT_16", "INT_17", "INT_18", 
                      "INT_19", "INT_20", "INT_21", "INT_22", "INT_23", 
                      "INT_24", "INT_25", "INT_26", "INT_27", "INT_28", 
                      "INT_29", "INT_30", "INT_31", "INT_32", "INT_33", 
                      "INT_34", "INT_35", "INT_36", "INT_37", "INT_38", 
                      "INT_39", "INT_40", "INT_41", "INT_42", "INT_43", 
                      "INT_44", "INT_45", "INT_46", "INT_47", "INT_48", 
                      "INT_49", "INT_50", "INT_51", "INT_52", "INT_53", 
                      "INT_54", "INT_55", "INT_56", "INT_57", "INT_58", 
                      "INT_59" ]

    RULE_twitbot = 0
    RULE_stat = 1
    RULE_action = 2
    RULE_tweet = 3
    RULE_tweet_required_parameter = 4
    RULE_tweet_optional_parameters = 5
    RULE_reply = 6
    RULE_reply_required_parameters = 7
    RULE_retweet = 8
    RULE_retweet_required_parameter = 9
    RULE_favourite = 10
    RULE_favourite_required_parameter = 11
    RULE_scheduleTweet = 12
    RULE_schedule_tweet_required_parameter = 13
    RULE_date_time_parameter = 14
    RULE_date = 15
    RULE_day_month_year = 16
    RULE_day_month = 17
    RULE_month = 18
    RULE_numeric_month = 19
    RULE_numeric_day = 20
    RULE_year = 21
    RULE_date_separator = 22
    RULE_time = 23
    RULE_hour_minute = 24
    RULE_time_separator = 25
    RULE_numeric_hour = 26
    RULE_numeric_minute = 27
    RULE_directMessage = 28
    RULE_direct_message_required_parameters = 29
    RULE_autoFavouriteRetweet = 30
    RULE_autoFollowFollowers = 31
    RULE_autoReplyMentions = 32
    RULE_automateReplyParameter = 33
    RULE_keyword = 34
    RULE_stringValue = 35
    RULE_number = 36
    RULE_unary_operator = 37
    RULE_unsigned_number = 38
    RULE_boolean = 39

    ruleNames =  [ "twitbot", "stat", "action", "tweet", "tweet_required_parameter", 
                   "tweet_optional_parameters", "reply", "reply_required_parameters", 
                   "retweet", "retweet_required_parameter", "favourite", 
                   "favourite_required_parameter", "scheduleTweet", "schedule_tweet_required_parameter", 
                   "date_time_parameter", "date", "day_month_year", "day_month", 
                   "month", "numeric_month", "numeric_day", "year", "date_separator", 
                   "time", "hour_minute", "time_separator", "numeric_hour", 
                   "numeric_minute", "directMessage", "direct_message_required_parameters", 
                   "autoFavouriteRetweet", "autoFollowFollowers", "autoReplyMentions", 
                   "automateReplyParameter", "keyword", "stringValue", "number", 
                   "unary_operator", "unsigned_number", "boolean" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    StringLiteral=3
    UnterminatedStringLiteral=4
    UNSIGNED_INT=5
    UNSIGNED_FLOAT=6
    LAT=7
    TRUE=8
    FALSE=9
    ID=10
    TWEET=11
    REPLY_ID=12
    STATUS=13
    POSSIBLY_SENSITIVE=14
    LONG=15
    PLACE_ID=16
    DISPLAY_COORDINATES=17
    REPLY=18
    RETWEET=19
    DIRECT_MESSAGE=20
    FAVOURITE=21
    SCHEDULE=22
    DATE=23
    TIME=24
    TEXT=25
    COMMA=26
    SEMICOLON=27
    COLON=28
    KEYWORD=29
    FOLLOWALL=30
    AUTOMATE_TIME=31
    RESPONSE=32
    AUTOMATE_REPLY_MENTIONS=33
    WS=34
    AUTO_FAV_RETWEET=35
    SLASH=36
    DOT=37
    FOUR_DIGIT=38
    DIGIT=39
    INT_0=40
    INT_1=41
    INT_2=42
    INT_3=43
    INT_4=44
    INT_5=45
    INT_6=46
    INT_7=47
    INT_8=48
    INT_9=49
    INT_00=50
    INT_01=51
    INT_02=52
    INT_03=53
    INT_04=54
    INT_05=55
    INT_06=56
    INT_07=57
    INT_08=58
    INT_09=59
    INT_10=60
    INT_11=61
    INT_12=62
    INT_13=63
    INT_14=64
    INT_15=65
    INT_16=66
    INT_17=67
    INT_18=68
    INT_19=69
    INT_20=70
    INT_21=71
    INT_22=72
    INT_23=73
    INT_24=74
    INT_25=75
    INT_26=76
    INT_27=77
    INT_28=78
    INT_29=79
    INT_30=80
    INT_31=81
    INT_32=82
    INT_33=83
    INT_34=84
    INT_35=85
    INT_36=86
    INT_37=87
    INT_38=88
    INT_39=89
    INT_40=90
    INT_41=91
    INT_42=92
    INT_43=93
    INT_44=94
    INT_45=95
    INT_46=96
    INT_47=97
    INT_48=98
    INT_49=99
    INT_50=100
    INT_51=101
    INT_52=102
    INT_53=103
    INT_54=104
    INT_55=105
    INT_56=106
    INT_57=107
    INT_58=108
    INT_59=109

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class TwitbotContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.StatContext)
            else:
                return self.getTypedRuleContext(dslParser.StatContext,i)


        def SEMICOLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.SEMICOLON)
            else:
                return self.getToken(dslParser.SEMICOLON, i)

        def getRuleIndex(self):
            return dslParser.RULE_twitbot

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTwitbot" ):
                listener.enterTwitbot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTwitbot" ):
                listener.exitTwitbot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTwitbot" ):
                return visitor.visitTwitbot(self)
            else:
                return visitor.visitChildren(self)




    def twitbot(self):

        localctx = dslParser.TwitbotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_twitbot)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 80
            self.stat()
            self.state = 81
            self.match(dslParser.SEMICOLON)
            self.state = 87
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << dslParser.TWEET) | (1 << dslParser.REPLY) | (1 << dslParser.RETWEET) | (1 << dslParser.DIRECT_MESSAGE) | (1 << dslParser.FAVOURITE) | (1 << dslParser.SCHEDULE) | (1 << dslParser.FOLLOWALL) | (1 << dslParser.AUTOMATE_REPLY_MENTIONS) | (1 << dslParser.AUTO_FAV_RETWEET))) != 0):
                self.state = 82
                self.stat()
                self.state = 83
                self.match(dslParser.SEMICOLON)
                self.state = 89
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def action(self):
            return self.getTypedRuleContext(dslParser.ActionContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_stat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat" ):
                listener.enterStat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat" ):
                listener.exitStat(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStat" ):
                return visitor.visitStat(self)
            else:
                return visitor.visitChildren(self)




    def stat(self):

        localctx = dslParser.StatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_stat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 90
            self.action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def tweet(self):
            return self.getTypedRuleContext(dslParser.TweetContext,0)


        def reply(self):
            return self.getTypedRuleContext(dslParser.ReplyContext,0)


        def retweet(self):
            return self.getTypedRuleContext(dslParser.RetweetContext,0)


        def favourite(self):
            return self.getTypedRuleContext(dslParser.FavouriteContext,0)


        def scheduleTweet(self):
            return self.getTypedRuleContext(dslParser.ScheduleTweetContext,0)


        def directMessage(self):
            return self.getTypedRuleContext(dslParser.DirectMessageContext,0)


        def autoFavouriteRetweet(self):
            return self.getTypedRuleContext(dslParser.AutoFavouriteRetweetContext,0)


        def autoFollowFollowers(self):
            return self.getTypedRuleContext(dslParser.AutoFollowFollowersContext,0)


        def autoReplyMentions(self):
            return self.getTypedRuleContext(dslParser.AutoReplyMentionsContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAction" ):
                return visitor.visitAction(self)
            else:
                return visitor.visitChildren(self)




    def action(self):

        localctx = dslParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_action)
        try:
            self.state = 101
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dslParser.TWEET]:
                self.enterOuterAlt(localctx, 1)
                self.state = 92
                self.tweet()
                pass
            elif token in [dslParser.REPLY]:
                self.enterOuterAlt(localctx, 2)
                self.state = 93
                self.reply()
                pass
            elif token in [dslParser.RETWEET]:
                self.enterOuterAlt(localctx, 3)
                self.state = 94
                self.retweet()
                pass
            elif token in [dslParser.FAVOURITE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 95
                self.favourite()
                pass
            elif token in [dslParser.SCHEDULE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 96
                self.scheduleTweet()
                pass
            elif token in [dslParser.DIRECT_MESSAGE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 97
                self.directMessage()
                pass
            elif token in [dslParser.AUTO_FAV_RETWEET]:
                self.enterOuterAlt(localctx, 7)
                self.state = 98
                self.autoFavouriteRetweet()
                pass
            elif token in [dslParser.FOLLOWALL]:
                self.enterOuterAlt(localctx, 8)
                self.state = 99
                self.autoFollowFollowers()
                pass
            elif token in [dslParser.AUTOMATE_REPLY_MENTIONS]:
                self.enterOuterAlt(localctx, 9)
                self.state = 100
                self.autoReplyMentions()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TWEET(self):
            return self.getToken(dslParser.TWEET, 0)

        def tweet_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Tweet_required_parameterContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def tweet_optional_parameters(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.Tweet_optional_parametersContext)
            else:
                return self.getTypedRuleContext(dslParser.Tweet_optional_parametersContext,i)


        def getRuleIndex(self):
            return dslParser.RULE_tweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweet" ):
                listener.enterTweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweet" ):
                listener.exitTweet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTweet" ):
                return visitor.visitTweet(self)
            else:
                return visitor.visitChildren(self)




    def tweet(self):

        localctx = dslParser.TweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_tweet)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 103
            self.match(dslParser.TWEET)
            self.state = 104
            self.tweet_required_parameter()
            self.state = 109
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dslParser.COMMA:
                self.state = 105
                self.match(dslParser.COMMA)
                self.state = 106
                self.tweet_optional_parameters()
                self.state = 111
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tweet_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STATUS(self):
            return self.getToken(dslParser.STATUS, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_tweet_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweet_required_parameter" ):
                listener.enterTweet_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweet_required_parameter" ):
                listener.exitTweet_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTweet_required_parameter" ):
                return visitor.visitTweet_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def tweet_required_parameter(self):

        localctx = dslParser.Tweet_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_tweet_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 112
            self.match(dslParser.STATUS)
            self.state = 113
            self.match(dslParser.COLON)
            self.state = 114
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tweet_optional_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POSSIBLY_SENSITIVE(self):
            return self.getToken(dslParser.POSSIBLY_SENSITIVE, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def boolean(self):
            return self.getTypedRuleContext(dslParser.BooleanContext,0)


        def LAT(self):
            return self.getToken(dslParser.LAT, 0)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def LONG(self):
            return self.getToken(dslParser.LONG, 0)

        def PLACE_ID(self):
            return self.getToken(dslParser.PLACE_ID, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def DISPLAY_COORDINATES(self):
            return self.getToken(dslParser.DISPLAY_COORDINATES, 0)

        def getRuleIndex(self):
            return dslParser.RULE_tweet_optional_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTweet_optional_parameters" ):
                listener.enterTweet_optional_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTweet_optional_parameters" ):
                listener.exitTweet_optional_parameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTweet_optional_parameters" ):
                return visitor.visitTweet_optional_parameters(self)
            else:
                return visitor.visitChildren(self)




    def tweet_optional_parameters(self):

        localctx = dslParser.Tweet_optional_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_tweet_optional_parameters)
        try:
            self.state = 131
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [dslParser.POSSIBLY_SENSITIVE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 116
                self.match(dslParser.POSSIBLY_SENSITIVE)
                self.state = 117
                self.match(dslParser.COLON)
                self.state = 118
                self.boolean()
                pass
            elif token in [dslParser.LAT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 119
                self.match(dslParser.LAT)
                self.state = 120
                self.match(dslParser.COLON)
                self.state = 121
                self.number()
                pass
            elif token in [dslParser.LONG]:
                self.enterOuterAlt(localctx, 3)
                self.state = 122
                self.match(dslParser.LONG)
                self.state = 123
                self.match(dslParser.COLON)
                self.state = 124
                self.number()
                pass
            elif token in [dslParser.PLACE_ID]:
                self.enterOuterAlt(localctx, 4)
                self.state = 125
                self.match(dslParser.PLACE_ID)
                self.state = 126
                self.match(dslParser.COLON)
                self.state = 127
                self.stringValue()
                pass
            elif token in [dslParser.DISPLAY_COORDINATES]:
                self.enterOuterAlt(localctx, 5)
                self.state = 128
                self.match(dslParser.DISPLAY_COORDINATES)
                self.state = 129
                self.match(dslParser.COLON)
                self.state = 130
                self.boolean()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReplyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPLY(self):
            return self.getToken(dslParser.REPLY, 0)

        def reply_required_parameters(self):
            return self.getTypedRuleContext(dslParser.Reply_required_parametersContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def tweet_optional_parameters(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.Tweet_optional_parametersContext)
            else:
                return self.getTypedRuleContext(dslParser.Tweet_optional_parametersContext,i)


        def getRuleIndex(self):
            return dslParser.RULE_reply

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReply" ):
                listener.enterReply(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReply" ):
                listener.exitReply(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReply" ):
                return visitor.visitReply(self)
            else:
                return visitor.visitChildren(self)




    def reply(self):

        localctx = dslParser.ReplyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_reply)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 133
            self.match(dslParser.REPLY)
            self.state = 134
            self.reply_required_parameters()
            self.state = 139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dslParser.COMMA:
                self.state = 135
                self.match(dslParser.COMMA)
                self.state = 136
                self.tweet_optional_parameters()
                self.state = 141
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reply_required_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPLY_ID(self):
            return self.getToken(dslParser.REPLY_ID, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COLON)
            else:
                return self.getToken(dslParser.COLON, i)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def STATUS(self):
            return self.getToken(dslParser.STATUS, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_reply_required_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReply_required_parameters" ):
                listener.enterReply_required_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReply_required_parameters" ):
                listener.exitReply_required_parameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReply_required_parameters" ):
                return visitor.visitReply_required_parameters(self)
            else:
                return visitor.visitChildren(self)




    def reply_required_parameters(self):

        localctx = dslParser.Reply_required_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_reply_required_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self.match(dslParser.REPLY_ID)
            self.state = 143
            self.match(dslParser.COLON)
            self.state = 144
            self.number()
            self.state = 145
            self.match(dslParser.COMMA)
            self.state = 146
            self.match(dslParser.STATUS)
            self.state = 147
            self.match(dslParser.COLON)
            self.state = 148
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RetweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETWEET(self):
            return self.getToken(dslParser.RETWEET, 0)

        def retweet_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Retweet_required_parameterContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_retweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRetweet" ):
                listener.enterRetweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRetweet" ):
                listener.exitRetweet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRetweet" ):
                return visitor.visitRetweet(self)
            else:
                return visitor.visitChildren(self)




    def retweet(self):

        localctx = dslParser.RetweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_retweet)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 150
            self.match(dslParser.RETWEET)
            self.state = 151
            self.retweet_required_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Retweet_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(dslParser.ID, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_retweet_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRetweet_required_parameter" ):
                listener.enterRetweet_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRetweet_required_parameter" ):
                listener.exitRetweet_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRetweet_required_parameter" ):
                return visitor.visitRetweet_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def retweet_required_parameter(self):

        localctx = dslParser.Retweet_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_retweet_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 153
            self.match(dslParser.ID)
            self.state = 154
            self.match(dslParser.COLON)
            self.state = 155
            self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FavouriteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FAVOURITE(self):
            return self.getToken(dslParser.FAVOURITE, 0)

        def favourite_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Favourite_required_parameterContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_favourite

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFavourite" ):
                listener.enterFavourite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFavourite" ):
                listener.exitFavourite(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFavourite" ):
                return visitor.visitFavourite(self)
            else:
                return visitor.visitChildren(self)




    def favourite(self):

        localctx = dslParser.FavouriteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_favourite)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 157
            self.match(dslParser.FAVOURITE)
            self.state = 158
            self.favourite_required_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Favourite_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(dslParser.ID, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_favourite_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFavourite_required_parameter" ):
                listener.enterFavourite_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFavourite_required_parameter" ):
                listener.exitFavourite_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFavourite_required_parameter" ):
                return visitor.visitFavourite_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def favourite_required_parameter(self):

        localctx = dslParser.Favourite_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_favourite_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 160
            self.match(dslParser.ID)
            self.state = 161
            self.match(dslParser.COLON)
            self.state = 162
            self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ScheduleTweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCHEDULE(self):
            return self.getToken(dslParser.SCHEDULE, 0)

        def schedule_tweet_required_parameter(self):
            return self.getTypedRuleContext(dslParser.Schedule_tweet_required_parameterContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_scheduleTweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScheduleTweet" ):
                listener.enterScheduleTweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScheduleTweet" ):
                listener.exitScheduleTweet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitScheduleTweet" ):
                return visitor.visitScheduleTweet(self)
            else:
                return visitor.visitChildren(self)




    def scheduleTweet(self):

        localctx = dslParser.ScheduleTweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_scheduleTweet)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 164
            self.match(dslParser.SCHEDULE)
            self.state = 165
            self.schedule_tweet_required_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Schedule_tweet_required_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def date_time_parameter(self):
            return self.getTypedRuleContext(dslParser.Date_time_parameterContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def tweet(self):
            return self.getTypedRuleContext(dslParser.TweetContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_schedule_tweet_required_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchedule_tweet_required_parameter" ):
                listener.enterSchedule_tweet_required_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchedule_tweet_required_parameter" ):
                listener.exitSchedule_tweet_required_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSchedule_tweet_required_parameter" ):
                return visitor.visitSchedule_tweet_required_parameter(self)
            else:
                return visitor.visitChildren(self)




    def schedule_tweet_required_parameter(self):

        localctx = dslParser.Schedule_tweet_required_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_schedule_tweet_required_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 167
            self.date_time_parameter()
            self.state = 168
            self.match(dslParser.COMMA)
            self.state = 169
            self.tweet()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Date_time_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATE(self):
            return self.getToken(dslParser.DATE, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COLON)
            else:
                return self.getToken(dslParser.COLON, i)

        def date(self):
            return self.getTypedRuleContext(dslParser.DateContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def TIME(self):
            return self.getToken(dslParser.TIME, 0)

        def time(self):
            return self.getTypedRuleContext(dslParser.TimeContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_date_time_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate_time_parameter" ):
                listener.enterDate_time_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate_time_parameter" ):
                listener.exitDate_time_parameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDate_time_parameter" ):
                return visitor.visitDate_time_parameter(self)
            else:
                return visitor.visitChildren(self)




    def date_time_parameter(self):

        localctx = dslParser.Date_time_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_date_time_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 171
            self.match(dslParser.DATE)
            self.state = 172
            self.match(dslParser.COLON)
            self.state = 173
            self.date()
            self.state = 174
            self.match(dslParser.COMMA)
            self.state = 175
            self.match(dslParser.TIME)
            self.state = 176
            self.match(dslParser.COLON)
            self.state = 177
            self.time()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def day_month_year(self):
            return self.getTypedRuleContext(dslParser.Day_month_yearContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDate" ):
                return visitor.visitDate(self)
            else:
                return visitor.visitChildren(self)




    def date(self):

        localctx = dslParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            self.day_month_year()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Day_month_yearContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def day_month(self):
            return self.getTypedRuleContext(dslParser.Day_monthContext,0)


        def date_separator(self):
            return self.getTypedRuleContext(dslParser.Date_separatorContext,0)


        def year(self):
            return self.getTypedRuleContext(dslParser.YearContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_day_month_year

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDay_month_year" ):
                listener.enterDay_month_year(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDay_month_year" ):
                listener.exitDay_month_year(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDay_month_year" ):
                return visitor.visitDay_month_year(self)
            else:
                return visitor.visitChildren(self)




    def day_month_year(self):

        localctx = dslParser.Day_month_yearContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_day_month_year)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            self.day_month()
            self.state = 182
            self.date_separator()
            self.state = 183
            self.year()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Day_monthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeric_day(self):
            return self.getTypedRuleContext(dslParser.Numeric_dayContext,0)


        def date_separator(self):
            return self.getTypedRuleContext(dslParser.Date_separatorContext,0)


        def month(self):
            return self.getTypedRuleContext(dslParser.MonthContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_day_month

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDay_month" ):
                listener.enterDay_month(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDay_month" ):
                listener.exitDay_month(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDay_month" ):
                return visitor.visitDay_month(self)
            else:
                return visitor.visitChildren(self)




    def day_month(self):

        localctx = dslParser.Day_monthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_day_month)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185
            self.numeric_day()
            self.state = 186
            self.date_separator()
            self.state = 187
            self.month()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MonthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeric_month(self):
            return self.getTypedRuleContext(dslParser.Numeric_monthContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_month

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMonth" ):
                listener.enterMonth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMonth" ):
                listener.exitMonth(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMonth" ):
                return visitor.visitMonth(self)
            else:
                return visitor.visitChildren(self)




    def month(self):

        localctx = dslParser.MonthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_month)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 189
            self.numeric_month()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_monthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_1(self):
            return self.getToken(dslParser.INT_1, 0)

        def INT_2(self):
            return self.getToken(dslParser.INT_2, 0)

        def INT_3(self):
            return self.getToken(dslParser.INT_3, 0)

        def INT_4(self):
            return self.getToken(dslParser.INT_4, 0)

        def INT_5(self):
            return self.getToken(dslParser.INT_5, 0)

        def INT_6(self):
            return self.getToken(dslParser.INT_6, 0)

        def INT_7(self):
            return self.getToken(dslParser.INT_7, 0)

        def INT_8(self):
            return self.getToken(dslParser.INT_8, 0)

        def INT_9(self):
            return self.getToken(dslParser.INT_9, 0)

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_month

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_month" ):
                listener.enterNumeric_month(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_month" ):
                listener.exitNumeric_month(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_month" ):
                return visitor.visitNumeric_month(self)
            else:
                return visitor.visitChildren(self)




    def numeric_month(self):

        localctx = dslParser.Numeric_monthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_numeric_month)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << dslParser.INT_1) | (1 << dslParser.INT_2) | (1 << dslParser.INT_3) | (1 << dslParser.INT_4) | (1 << dslParser.INT_5) | (1 << dslParser.INT_6) | (1 << dslParser.INT_7) | (1 << dslParser.INT_8) | (1 << dslParser.INT_9) | (1 << dslParser.INT_01) | (1 << dslParser.INT_02) | (1 << dslParser.INT_03) | (1 << dslParser.INT_04) | (1 << dslParser.INT_05) | (1 << dslParser.INT_06) | (1 << dslParser.INT_07) | (1 << dslParser.INT_08) | (1 << dslParser.INT_09) | (1 << dslParser.INT_10) | (1 << dslParser.INT_11) | (1 << dslParser.INT_12))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_dayContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_1(self):
            return self.getToken(dslParser.INT_1, 0)

        def INT_2(self):
            return self.getToken(dslParser.INT_2, 0)

        def INT_3(self):
            return self.getToken(dslParser.INT_3, 0)

        def INT_4(self):
            return self.getToken(dslParser.INT_4, 0)

        def INT_5(self):
            return self.getToken(dslParser.INT_5, 0)

        def INT_6(self):
            return self.getToken(dslParser.INT_6, 0)

        def INT_7(self):
            return self.getToken(dslParser.INT_7, 0)

        def INT_8(self):
            return self.getToken(dslParser.INT_8, 0)

        def INT_9(self):
            return self.getToken(dslParser.INT_9, 0)

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def INT_13(self):
            return self.getToken(dslParser.INT_13, 0)

        def INT_14(self):
            return self.getToken(dslParser.INT_14, 0)

        def INT_15(self):
            return self.getToken(dslParser.INT_15, 0)

        def INT_16(self):
            return self.getToken(dslParser.INT_16, 0)

        def INT_17(self):
            return self.getToken(dslParser.INT_17, 0)

        def INT_18(self):
            return self.getToken(dslParser.INT_18, 0)

        def INT_19(self):
            return self.getToken(dslParser.INT_19, 0)

        def INT_20(self):
            return self.getToken(dslParser.INT_20, 0)

        def INT_21(self):
            return self.getToken(dslParser.INT_21, 0)

        def INT_22(self):
            return self.getToken(dslParser.INT_22, 0)

        def INT_23(self):
            return self.getToken(dslParser.INT_23, 0)

        def INT_24(self):
            return self.getToken(dslParser.INT_24, 0)

        def INT_25(self):
            return self.getToken(dslParser.INT_25, 0)

        def INT_26(self):
            return self.getToken(dslParser.INT_26, 0)

        def INT_27(self):
            return self.getToken(dslParser.INT_27, 0)

        def INT_28(self):
            return self.getToken(dslParser.INT_28, 0)

        def INT_29(self):
            return self.getToken(dslParser.INT_29, 0)

        def INT_30(self):
            return self.getToken(dslParser.INT_30, 0)

        def INT_31(self):
            return self.getToken(dslParser.INT_31, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_day

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_day" ):
                listener.enterNumeric_day(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_day" ):
                listener.exitNumeric_day(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_day" ):
                return visitor.visitNumeric_day(self)
            else:
                return visitor.visitChildren(self)




    def numeric_day(self):

        localctx = dslParser.Numeric_dayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_numeric_day)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            _la = self._input.LA(1)
            if not(((((_la - 41)) & ~0x3f) == 0 and ((1 << (_la - 41)) & ((1 << (dslParser.INT_1 - 41)) | (1 << (dslParser.INT_2 - 41)) | (1 << (dslParser.INT_3 - 41)) | (1 << (dslParser.INT_4 - 41)) | (1 << (dslParser.INT_5 - 41)) | (1 << (dslParser.INT_6 - 41)) | (1 << (dslParser.INT_7 - 41)) | (1 << (dslParser.INT_8 - 41)) | (1 << (dslParser.INT_9 - 41)) | (1 << (dslParser.INT_01 - 41)) | (1 << (dslParser.INT_02 - 41)) | (1 << (dslParser.INT_03 - 41)) | (1 << (dslParser.INT_04 - 41)) | (1 << (dslParser.INT_05 - 41)) | (1 << (dslParser.INT_06 - 41)) | (1 << (dslParser.INT_07 - 41)) | (1 << (dslParser.INT_08 - 41)) | (1 << (dslParser.INT_09 - 41)) | (1 << (dslParser.INT_10 - 41)) | (1 << (dslParser.INT_11 - 41)) | (1 << (dslParser.INT_12 - 41)) | (1 << (dslParser.INT_13 - 41)) | (1 << (dslParser.INT_14 - 41)) | (1 << (dslParser.INT_15 - 41)) | (1 << (dslParser.INT_16 - 41)) | (1 << (dslParser.INT_17 - 41)) | (1 << (dslParser.INT_18 - 41)) | (1 << (dslParser.INT_19 - 41)) | (1 << (dslParser.INT_20 - 41)) | (1 << (dslParser.INT_21 - 41)) | (1 << (dslParser.INT_22 - 41)) | (1 << (dslParser.INT_23 - 41)) | (1 << (dslParser.INT_24 - 41)) | (1 << (dslParser.INT_25 - 41)) | (1 << (dslParser.INT_26 - 41)) | (1 << (dslParser.INT_27 - 41)) | (1 << (dslParser.INT_28 - 41)) | (1 << (dslParser.INT_29 - 41)) | (1 << (dslParser.INT_30 - 41)) | (1 << (dslParser.INT_31 - 41)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class YearContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOUR_DIGIT(self):
            return self.getToken(dslParser.FOUR_DIGIT, 0)

        def getRuleIndex(self):
            return dslParser.RULE_year

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterYear" ):
                listener.enterYear(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitYear" ):
                listener.exitYear(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitYear" ):
                return visitor.visitYear(self)
            else:
                return visitor.visitChildren(self)




    def year(self):

        localctx = dslParser.YearContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_year)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            self.match(dslParser.FOUR_DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Date_separatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SLASH(self):
            return self.getToken(dslParser.SLASH, 0)

        def getRuleIndex(self):
            return dslParser.RULE_date_separator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate_separator" ):
                listener.enterDate_separator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate_separator" ):
                listener.exitDate_separator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDate_separator" ):
                return visitor.visitDate_separator(self)
            else:
                return visitor.visitChildren(self)




    def date_separator(self):

        localctx = dslParser.Date_separatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_date_separator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.match(dslParser.SLASH)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def hour_minute(self):
            return self.getTypedRuleContext(dslParser.Hour_minuteContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_time

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime" ):
                listener.enterTime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime" ):
                listener.exitTime(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime" ):
                return visitor.visitTime(self)
            else:
                return visitor.visitChildren(self)




    def time(self):

        localctx = dslParser.TimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_time)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            self.hour_minute()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Hour_minuteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numeric_hour(self):
            return self.getTypedRuleContext(dslParser.Numeric_hourContext,0)


        def time_separator(self):
            return self.getTypedRuleContext(dslParser.Time_separatorContext,0)


        def numeric_minute(self):
            return self.getTypedRuleContext(dslParser.Numeric_minuteContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_hour_minute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHour_minute" ):
                listener.enterHour_minute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHour_minute" ):
                listener.exitHour_minute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHour_minute" ):
                return visitor.visitHour_minute(self)
            else:
                return visitor.visitChildren(self)




    def hour_minute(self):

        localctx = dslParser.Hour_minuteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_hour_minute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self.numeric_hour()
            self.state = 202
            self.time_separator()
            self.state = 203
            self.numeric_minute()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Time_separatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOT(self):
            return self.getToken(dslParser.DOT, 0)

        def getRuleIndex(self):
            return dslParser.RULE_time_separator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_separator" ):
                listener.enterTime_separator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_separator" ):
                listener.exitTime_separator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime_separator" ):
                return visitor.visitTime_separator(self)
            else:
                return visitor.visitChildren(self)




    def time_separator(self):

        localctx = dslParser.Time_separatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_time_separator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 205
            self.match(dslParser.DOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_hourContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def INT_13(self):
            return self.getToken(dslParser.INT_13, 0)

        def INT_14(self):
            return self.getToken(dslParser.INT_14, 0)

        def INT_15(self):
            return self.getToken(dslParser.INT_15, 0)

        def INT_16(self):
            return self.getToken(dslParser.INT_16, 0)

        def INT_17(self):
            return self.getToken(dslParser.INT_17, 0)

        def INT_18(self):
            return self.getToken(dslParser.INT_18, 0)

        def INT_19(self):
            return self.getToken(dslParser.INT_19, 0)

        def INT_20(self):
            return self.getToken(dslParser.INT_20, 0)

        def INT_21(self):
            return self.getToken(dslParser.INT_21, 0)

        def INT_22(self):
            return self.getToken(dslParser.INT_22, 0)

        def INT_23(self):
            return self.getToken(dslParser.INT_23, 0)

        def INT_24(self):
            return self.getToken(dslParser.INT_24, 0)

        def INT_00(self):
            return self.getToken(dslParser.INT_00, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_hour

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_hour" ):
                listener.enterNumeric_hour(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_hour" ):
                listener.exitNumeric_hour(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_hour" ):
                return visitor.visitNumeric_hour(self)
            else:
                return visitor.visitChildren(self)




    def numeric_hour(self):

        localctx = dslParser.Numeric_hourContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_numeric_hour)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 207
            _la = self._input.LA(1)
            if not(((((_la - 50)) & ~0x3f) == 0 and ((1 << (_la - 50)) & ((1 << (dslParser.INT_00 - 50)) | (1 << (dslParser.INT_01 - 50)) | (1 << (dslParser.INT_02 - 50)) | (1 << (dslParser.INT_03 - 50)) | (1 << (dslParser.INT_04 - 50)) | (1 << (dslParser.INT_05 - 50)) | (1 << (dslParser.INT_06 - 50)) | (1 << (dslParser.INT_07 - 50)) | (1 << (dslParser.INT_08 - 50)) | (1 << (dslParser.INT_09 - 50)) | (1 << (dslParser.INT_10 - 50)) | (1 << (dslParser.INT_11 - 50)) | (1 << (dslParser.INT_12 - 50)) | (1 << (dslParser.INT_13 - 50)) | (1 << (dslParser.INT_14 - 50)) | (1 << (dslParser.INT_15 - 50)) | (1 << (dslParser.INT_16 - 50)) | (1 << (dslParser.INT_17 - 50)) | (1 << (dslParser.INT_18 - 50)) | (1 << (dslParser.INT_19 - 50)) | (1 << (dslParser.INT_20 - 50)) | (1 << (dslParser.INT_21 - 50)) | (1 << (dslParser.INT_22 - 50)) | (1 << (dslParser.INT_23 - 50)) | (1 << (dslParser.INT_24 - 50)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Numeric_minuteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_01(self):
            return self.getToken(dslParser.INT_01, 0)

        def INT_02(self):
            return self.getToken(dslParser.INT_02, 0)

        def INT_03(self):
            return self.getToken(dslParser.INT_03, 0)

        def INT_04(self):
            return self.getToken(dslParser.INT_04, 0)

        def INT_05(self):
            return self.getToken(dslParser.INT_05, 0)

        def INT_06(self):
            return self.getToken(dslParser.INT_06, 0)

        def INT_07(self):
            return self.getToken(dslParser.INT_07, 0)

        def INT_08(self):
            return self.getToken(dslParser.INT_08, 0)

        def INT_09(self):
            return self.getToken(dslParser.INT_09, 0)

        def INT_10(self):
            return self.getToken(dslParser.INT_10, 0)

        def INT_11(self):
            return self.getToken(dslParser.INT_11, 0)

        def INT_12(self):
            return self.getToken(dslParser.INT_12, 0)

        def INT_13(self):
            return self.getToken(dslParser.INT_13, 0)

        def INT_14(self):
            return self.getToken(dslParser.INT_14, 0)

        def INT_15(self):
            return self.getToken(dslParser.INT_15, 0)

        def INT_16(self):
            return self.getToken(dslParser.INT_16, 0)

        def INT_17(self):
            return self.getToken(dslParser.INT_17, 0)

        def INT_18(self):
            return self.getToken(dslParser.INT_18, 0)

        def INT_19(self):
            return self.getToken(dslParser.INT_19, 0)

        def INT_20(self):
            return self.getToken(dslParser.INT_20, 0)

        def INT_21(self):
            return self.getToken(dslParser.INT_21, 0)

        def INT_22(self):
            return self.getToken(dslParser.INT_22, 0)

        def INT_23(self):
            return self.getToken(dslParser.INT_23, 0)

        def INT_24(self):
            return self.getToken(dslParser.INT_24, 0)

        def INT_25(self):
            return self.getToken(dslParser.INT_25, 0)

        def INT_26(self):
            return self.getToken(dslParser.INT_26, 0)

        def INT_27(self):
            return self.getToken(dslParser.INT_27, 0)

        def INT_28(self):
            return self.getToken(dslParser.INT_28, 0)

        def INT_29(self):
            return self.getToken(dslParser.INT_29, 0)

        def INT_30(self):
            return self.getToken(dslParser.INT_30, 0)

        def INT_31(self):
            return self.getToken(dslParser.INT_31, 0)

        def INT_32(self):
            return self.getToken(dslParser.INT_32, 0)

        def INT_33(self):
            return self.getToken(dslParser.INT_33, 0)

        def INT_34(self):
            return self.getToken(dslParser.INT_34, 0)

        def INT_35(self):
            return self.getToken(dslParser.INT_35, 0)

        def INT_36(self):
            return self.getToken(dslParser.INT_36, 0)

        def INT_37(self):
            return self.getToken(dslParser.INT_37, 0)

        def INT_38(self):
            return self.getToken(dslParser.INT_38, 0)

        def INT_39(self):
            return self.getToken(dslParser.INT_39, 0)

        def INT_40(self):
            return self.getToken(dslParser.INT_40, 0)

        def INT_41(self):
            return self.getToken(dslParser.INT_41, 0)

        def INT_42(self):
            return self.getToken(dslParser.INT_42, 0)

        def INT_43(self):
            return self.getToken(dslParser.INT_43, 0)

        def INT_44(self):
            return self.getToken(dslParser.INT_44, 0)

        def INT_45(self):
            return self.getToken(dslParser.INT_45, 0)

        def INT_46(self):
            return self.getToken(dslParser.INT_46, 0)

        def INT_47(self):
            return self.getToken(dslParser.INT_47, 0)

        def INT_48(self):
            return self.getToken(dslParser.INT_48, 0)

        def INT_49(self):
            return self.getToken(dslParser.INT_49, 0)

        def INT_50(self):
            return self.getToken(dslParser.INT_50, 0)

        def INT_51(self):
            return self.getToken(dslParser.INT_51, 0)

        def INT_52(self):
            return self.getToken(dslParser.INT_52, 0)

        def INT_53(self):
            return self.getToken(dslParser.INT_53, 0)

        def INT_54(self):
            return self.getToken(dslParser.INT_54, 0)

        def INT_55(self):
            return self.getToken(dslParser.INT_55, 0)

        def INT_56(self):
            return self.getToken(dslParser.INT_56, 0)

        def INT_57(self):
            return self.getToken(dslParser.INT_57, 0)

        def INT_58(self):
            return self.getToken(dslParser.INT_58, 0)

        def INT_59(self):
            return self.getToken(dslParser.INT_59, 0)

        def INT_00(self):
            return self.getToken(dslParser.INT_00, 0)

        def getRuleIndex(self):
            return dslParser.RULE_numeric_minute

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumeric_minute" ):
                listener.enterNumeric_minute(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumeric_minute" ):
                listener.exitNumeric_minute(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumeric_minute" ):
                return visitor.visitNumeric_minute(self)
            else:
                return visitor.visitChildren(self)




    def numeric_minute(self):

        localctx = dslParser.Numeric_minuteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_numeric_minute)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            _la = self._input.LA(1)
            if not(((((_la - 50)) & ~0x3f) == 0 and ((1 << (_la - 50)) & ((1 << (dslParser.INT_00 - 50)) | (1 << (dslParser.INT_01 - 50)) | (1 << (dslParser.INT_02 - 50)) | (1 << (dslParser.INT_03 - 50)) | (1 << (dslParser.INT_04 - 50)) | (1 << (dslParser.INT_05 - 50)) | (1 << (dslParser.INT_06 - 50)) | (1 << (dslParser.INT_07 - 50)) | (1 << (dslParser.INT_08 - 50)) | (1 << (dslParser.INT_09 - 50)) | (1 << (dslParser.INT_10 - 50)) | (1 << (dslParser.INT_11 - 50)) | (1 << (dslParser.INT_12 - 50)) | (1 << (dslParser.INT_13 - 50)) | (1 << (dslParser.INT_14 - 50)) | (1 << (dslParser.INT_15 - 50)) | (1 << (dslParser.INT_16 - 50)) | (1 << (dslParser.INT_17 - 50)) | (1 << (dslParser.INT_18 - 50)) | (1 << (dslParser.INT_19 - 50)) | (1 << (dslParser.INT_20 - 50)) | (1 << (dslParser.INT_21 - 50)) | (1 << (dslParser.INT_22 - 50)) | (1 << (dslParser.INT_23 - 50)) | (1 << (dslParser.INT_24 - 50)) | (1 << (dslParser.INT_25 - 50)) | (1 << (dslParser.INT_26 - 50)) | (1 << (dslParser.INT_27 - 50)) | (1 << (dslParser.INT_28 - 50)) | (1 << (dslParser.INT_29 - 50)) | (1 << (dslParser.INT_30 - 50)) | (1 << (dslParser.INT_31 - 50)) | (1 << (dslParser.INT_32 - 50)) | (1 << (dslParser.INT_33 - 50)) | (1 << (dslParser.INT_34 - 50)) | (1 << (dslParser.INT_35 - 50)) | (1 << (dslParser.INT_36 - 50)) | (1 << (dslParser.INT_37 - 50)) | (1 << (dslParser.INT_38 - 50)) | (1 << (dslParser.INT_39 - 50)) | (1 << (dslParser.INT_40 - 50)) | (1 << (dslParser.INT_41 - 50)) | (1 << (dslParser.INT_42 - 50)) | (1 << (dslParser.INT_43 - 50)) | (1 << (dslParser.INT_44 - 50)) | (1 << (dslParser.INT_45 - 50)) | (1 << (dslParser.INT_46 - 50)) | (1 << (dslParser.INT_47 - 50)) | (1 << (dslParser.INT_48 - 50)) | (1 << (dslParser.INT_49 - 50)) | (1 << (dslParser.INT_50 - 50)) | (1 << (dslParser.INT_51 - 50)) | (1 << (dslParser.INT_52 - 50)) | (1 << (dslParser.INT_53 - 50)) | (1 << (dslParser.INT_54 - 50)) | (1 << (dslParser.INT_55 - 50)) | (1 << (dslParser.INT_56 - 50)) | (1 << (dslParser.INT_57 - 50)) | (1 << (dslParser.INT_58 - 50)) | (1 << (dslParser.INT_59 - 50)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DirectMessageContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIRECT_MESSAGE(self):
            return self.getToken(dslParser.DIRECT_MESSAGE, 0)

        def direct_message_required_parameters(self):
            return self.getTypedRuleContext(dslParser.Direct_message_required_parametersContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_directMessage

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirectMessage" ):
                listener.enterDirectMessage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirectMessage" ):
                listener.exitDirectMessage(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirectMessage" ):
                return visitor.visitDirectMessage(self)
            else:
                return visitor.visitChildren(self)




    def directMessage(self):

        localctx = dslParser.DirectMessageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_directMessage)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            self.match(dslParser.DIRECT_MESSAGE)
            self.state = 212
            self.direct_message_required_parameters()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Direct_message_required_parametersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(dslParser.ID, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COLON)
            else:
                return self.getToken(dslParser.COLON, i)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def TEXT(self):
            return self.getToken(dslParser.TEXT, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_direct_message_required_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirect_message_required_parameters" ):
                listener.enterDirect_message_required_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirect_message_required_parameters" ):
                listener.exitDirect_message_required_parameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDirect_message_required_parameters" ):
                return visitor.visitDirect_message_required_parameters(self)
            else:
                return visitor.visitChildren(self)




    def direct_message_required_parameters(self):

        localctx = dslParser.Direct_message_required_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_direct_message_required_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 214
            self.match(dslParser.ID)
            self.state = 215
            self.match(dslParser.COLON)
            self.state = 216
            self.number()
            self.state = 217
            self.match(dslParser.COMMA)
            self.state = 218
            self.match(dslParser.TEXT)
            self.state = 219
            self.match(dslParser.COLON)
            self.state = 220
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutoFavouriteRetweetContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AUTO_FAV_RETWEET(self):
            return self.getToken(dslParser.AUTO_FAV_RETWEET, 0)

        def keyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.KeywordContext)
            else:
                return self.getTypedRuleContext(dslParser.KeywordContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def getRuleIndex(self):
            return dslParser.RULE_autoFavouriteRetweet

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutoFavouriteRetweet" ):
                listener.enterAutoFavouriteRetweet(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutoFavouriteRetweet" ):
                listener.exitAutoFavouriteRetweet(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAutoFavouriteRetweet" ):
                return visitor.visitAutoFavouriteRetweet(self)
            else:
                return visitor.visitChildren(self)




    def autoFavouriteRetweet(self):

        localctx = dslParser.AutoFavouriteRetweetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_autoFavouriteRetweet)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 222
            self.match(dslParser.AUTO_FAV_RETWEET)
            self.state = 223
            self.keyword()
            self.state = 228
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==dslParser.COMMA:
                self.state = 224
                self.match(dslParser.COMMA)
                self.state = 225
                self.keyword()
                self.state = 230
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutoFollowFollowersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOLLOWALL(self):
            return self.getToken(dslParser.FOLLOWALL, 0)

        def getRuleIndex(self):
            return dslParser.RULE_autoFollowFollowers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutoFollowFollowers" ):
                listener.enterAutoFollowFollowers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutoFollowFollowers" ):
                listener.exitAutoFollowFollowers(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAutoFollowFollowers" ):
                return visitor.visitAutoFollowFollowers(self)
            else:
                return visitor.visitChildren(self)




    def autoFollowFollowers(self):

        localctx = dslParser.AutoFollowFollowersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_autoFollowFollowers)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            self.match(dslParser.FOLLOWALL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutoReplyMentionsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AUTOMATE_REPLY_MENTIONS(self):
            return self.getToken(dslParser.AUTOMATE_REPLY_MENTIONS, 0)

        def automateReplyParameter(self):
            return self.getTypedRuleContext(dslParser.AutomateReplyParameterContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COMMA)
            else:
                return self.getToken(dslParser.COMMA, i)

        def keyword(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dslParser.KeywordContext)
            else:
                return self.getTypedRuleContext(dslParser.KeywordContext,i)


        def getRuleIndex(self):
            return dslParser.RULE_autoReplyMentions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutoReplyMentions" ):
                listener.enterAutoReplyMentions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutoReplyMentions" ):
                listener.exitAutoReplyMentions(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAutoReplyMentions" ):
                return visitor.visitAutoReplyMentions(self)
            else:
                return visitor.visitChildren(self)




    def autoReplyMentions(self):

        localctx = dslParser.AutoReplyMentionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_autoReplyMentions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            self.match(dslParser.AUTOMATE_REPLY_MENTIONS)
            self.state = 234
            self.automateReplyParameter()
            self.state = 237 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 235
                self.match(dslParser.COMMA)
                self.state = 236
                self.keyword()
                self.state = 239 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==dslParser.COMMA):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AutomateReplyParameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AUTOMATE_TIME(self):
            return self.getToken(dslParser.AUTOMATE_TIME, 0)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(dslParser.COLON)
            else:
                return self.getToken(dslParser.COLON, i)

        def number(self):
            return self.getTypedRuleContext(dslParser.NumberContext,0)


        def COMMA(self):
            return self.getToken(dslParser.COMMA, 0)

        def RESPONSE(self):
            return self.getToken(dslParser.RESPONSE, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_automateReplyParameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAutomateReplyParameter" ):
                listener.enterAutomateReplyParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAutomateReplyParameter" ):
                listener.exitAutomateReplyParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAutomateReplyParameter" ):
                return visitor.visitAutomateReplyParameter(self)
            else:
                return visitor.visitChildren(self)




    def automateReplyParameter(self):

        localctx = dslParser.AutomateReplyParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_automateReplyParameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 241
            self.match(dslParser.AUTOMATE_TIME)
            self.state = 242
            self.match(dslParser.COLON)
            self.state = 243
            self.number()
            self.state = 244
            self.match(dslParser.COMMA)
            self.state = 245
            self.match(dslParser.RESPONSE)
            self.state = 246
            self.match(dslParser.COLON)
            self.state = 247
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeywordContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEYWORD(self):
            return self.getToken(dslParser.KEYWORD, 0)

        def COLON(self):
            return self.getToken(dslParser.COLON, 0)

        def stringValue(self):
            return self.getTypedRuleContext(dslParser.StringValueContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_keyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeyword" ):
                listener.enterKeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeyword" ):
                listener.exitKeyword(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeyword" ):
                return visitor.visitKeyword(self)
            else:
                return visitor.visitChildren(self)




    def keyword(self):

        localctx = dslParser.KeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_keyword)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            self.match(dslParser.KEYWORD)
            self.state = 250
            self.match(dslParser.COLON)
            self.state = 251
            self.stringValue()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringValueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def StringLiteral(self):
            return self.getToken(dslParser.StringLiteral, 0)

        def getRuleIndex(self):
            return dslParser.RULE_stringValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringValue" ):
                listener.enterStringValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringValue" ):
                listener.exitStringValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStringValue" ):
                return visitor.visitStringValue(self)
            else:
                return visitor.visitChildren(self)




    def stringValue(self):

        localctx = dslParser.StringValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_stringValue)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 253
            self.match(dslParser.StringLiteral)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unsigned_number(self):
            return self.getTypedRuleContext(dslParser.Unsigned_numberContext,0)


        def unary_operator(self):
            return self.getTypedRuleContext(dslParser.Unary_operatorContext,0)


        def getRuleIndex(self):
            return dslParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)




    def number(self):

        localctx = dslParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 256
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==dslParser.T__0 or _la==dslParser.T__1:
                self.state = 255
                self.unary_operator()


            self.state = 258
            self.unsigned_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unary_operatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return dslParser.RULE_unary_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnary_operator" ):
                listener.enterUnary_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnary_operator" ):
                listener.exitUnary_operator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnary_operator" ):
                return visitor.visitUnary_operator(self)
            else:
                return visitor.visitChildren(self)




    def unary_operator(self):

        localctx = dslParser.Unary_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_unary_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 260
            _la = self._input.LA(1)
            if not(_la==dslParser.T__0 or _la==dslParser.T__1):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unsigned_numberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNSIGNED_INT(self):
            return self.getToken(dslParser.UNSIGNED_INT, 0)

        def UNSIGNED_FLOAT(self):
            return self.getToken(dslParser.UNSIGNED_FLOAT, 0)

        def getRuleIndex(self):
            return dslParser.RULE_unsigned_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnsigned_number" ):
                listener.enterUnsigned_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnsigned_number" ):
                listener.exitUnsigned_number(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnsigned_number" ):
                return visitor.visitUnsigned_number(self)
            else:
                return visitor.visitChildren(self)




    def unsigned_number(self):

        localctx = dslParser.Unsigned_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_unsigned_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 262
            _la = self._input.LA(1)
            if not(_la==dslParser.UNSIGNED_INT or _la==dslParser.UNSIGNED_FLOAT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(dslParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(dslParser.FALSE, 0)

        def getRuleIndex(self):
            return dslParser.RULE_boolean

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolean" ):
                listener.enterBoolean(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolean" ):
                listener.exitBoolean(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolean" ):
                return visitor.visitBoolean(self)
            else:
                return visitor.visitChildren(self)




    def boolean(self):

        localctx = dslParser.BooleanContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_boolean)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 264
            _la = self._input.LA(1)
            if not(_la==dslParser.TRUE or _la==dslParser.FALSE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





