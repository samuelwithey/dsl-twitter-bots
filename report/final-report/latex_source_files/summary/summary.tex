\chapter{Summary and Reflections}

\section{Further Work}

Further extensions of the project would have been to include the functionality described in the desired functional requirements. These extensions include implementing a front-end to the Django web application where users can interact with the domain specific language. This web application would be deployed on cloud-based web services such as Amazon Web Services and allow access by any user with API keys. The desirable functional requirements were not achieved due to time constraints and the complexity of the implementation of the system. \newline \par

Another extension of the project would be to include more automation and bot scripts. The Tweepy library has powerful functions which is seen in the StreamListeners. StreamListeners obtains high volumes of tweets in real-time and its functionality is demonstrated in FavRetweetListener in `bot\_scripts.py'. This functionality provides many opportunities for automation and could be integrated with sentiment analysis in natural language processing to engage and interact with tweets based on its sentiment. There is vast potential for more complex and practical bot scripts to be implemented using the Tweepy library, which would add to the completeness of a system to manage bots. \newline \par
 
The project meets Functional Requirement 1, as it provides all the functionality of what can be completed by a human on the standard Twitter web page. A limitation of this functional requirement is that the interaction of the basic functionality of Twitter is a complicated process through the API. This is due to the Twitter API using Snowflake to generate unique IDs for objects within Twitter (Tweets, Direct Messages, Users). These ID's are often unknown and are not a viable or practical solution to interacting with the basic functionality of the API. Tweeting a user can manually be achieved by including their username following the standard `@' notation. However to retweet, reply to tweet and favourite, the ID of the Tweet must be known. Further extensions of the project would look at solutions to solve this, including algorithms to search for ID's by usernames through the Tweepy library to create a more intuitive and natural interaction with the domain specific language.

\section{Conclusion}

The project was completed using an Agile SCRUM methodology. This methodology focuses on using short work cycles called sprints. Sprints throughout the project varied in length depending on what the sprint aimed to achieve in the sprint plan. The sprint plans used the GANT chart produced in the interim report to break down tasks further. This process of dividing the larger tasks into smaller sprint plans allowed for smooth implementation of the project and was managed through a Trello board. This board included three columns, things to do, doing and completed. Each task within the column had a label and a sprint number to make it easy to identify which sprint cycle includes which tasks and what work is outstanding at the end of a sprint. This method of project planning was beneficial, allowing each task to be easily managed and implemented and allowed for real-world delays and issues. The project timeline and management encountered a few delays. The most significant delay for the management of the project was getting access to the Twitter API keys. It took several weeks to gain access to the API keys, and this delayed the implementation of the project. This delay was due to the application to gain access keys not being completed until after the planning and designs. This delayed the implementation stage of the project as the API keys were vital for this stage. \newline \par

While the project is deemed a success in terms of the mandatory requirements, the project needs additional development to ensure it is a safe to use and entirely practical application. The mandatory Non-Functional Requirement 1 and 2 has not been tested, and it is not known if the project will run on Windows Operating Systems or macOS due to the lack of resources to achieve this. The project was unable to meet the desired requirements due to the underestimated amount of time it would take to implement the domain specific language and the visitors successfully. These limitations came from a small number of errors in the domain specific language which had to be refactored, leaving outstanding work at the end of some sprints. Another factor for the underestimated amount of time to complete the mandatory requirements was due to the choice to write the software in Python. ANTLR4 has Python 3 as a code generation target, but does not include any documentation for Python. Using Python 3 required all of the examples and documentation from The Definitive ANTLR 4 \cite{parr2013definitive} to be converted from Java to Python. This process made implementation a slow process as the documentation and examples did not always directly translate to Python. In these scenarios, it was required to view the ANTLR 4 Python source code to understand how to implement certain functionality, and this was most prevalent when implementing the visitor functions. \newline \par

The decision to use specific tools and technologies added complications to the project. The decision to use the Python ANTLR generation was to be able to easily include the domain specific language in the Django web application. As the front end of the Django web application was not implemented, it was not necessary to use Django or ANTLR Python code generation. Django provides a simple way to manage the account credentials, execute the domain specific language, create Twitter Campaigns and execute tests. Django provides features which would work well with the future aims and objects and desirable requirements, however, for the project these features could easily be implemented without the use of Django and using the Java runtime instead of Python. \newline \par

Mandatory Functional Requirement 2 is implemented into the system, and this requirement is scheduling content. While the solution is implemented, it does not provide a practical solution to achieve the outcome of the requirement. The implemented solution uses a native Python module sched which defines a class which implements a general-purpose event scheduler. The cons of using this method of implementation is the scheduler runs for the duration of time until the event is executed. This implementation makes it an impractical solution for scheduling events which are not in the immediate future as it locks the entire system. One solution to this would be to implement a multi-threaded system where each scheduled event has a thread. Another solution, which was an explored method of implementation is to use cron scheduling. Using cron scheduling would be more practical as these scheduled events would run in the background; however, this method of implementation was intricate and did not consistently work. \newline \par

The original project ideas and designs had the intention of working across a broader range of social media platforms and not limited to Twitter. This project limitation came from the lack of access for the API and developer tools for other social media platforms. Other social media platforms such as Facebook and Instagram have limited access to their API and developer toolkits, where the specification of the project was not eligible for API access. \newline \par