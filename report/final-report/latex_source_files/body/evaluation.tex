\chapter{Evaluation}

The evaluation of the system is determined from a set of unit tests. The unit tests are split into four different classes which test different components and functionality of the system. The first class of unit tests, DSLParsingTest, tests how the input is parsed and if the visitor/interpreter implementation successfully visits the child nodes to return the correct input data. DSLParsingTest uses a different visitor class than the rest of the system, as this testing visitor class, DSLVisitorWalkerTest, returns the kwargs of the parsed input instead of executing application specific code. The kwargs are the result of the parsed input, which is to be passed to the Tweepy object to perform the actions of the given input. This testing class validates the core functionality of the domain specific language, the parser and the interpreter by proving the output is as expected for a valid input. \newline \par

The second test class, DSLVisitorWalkerAPITests, tests the visitor and the visitors interaction with the Twitter API through the Tweepy library. The test class tests all the core functionality and the different actions performed by the domain specific language. The unit tests directly interact with Twitter, making it difficult to control all the variables for unit testing. The tests can be run individually; however, running the test class is better suited as some test functions depend on other test functions. An example of this would be test\_retweet and test\_favourite as the unit tests would fail if ran twice with quick succession. This is because there would likely be no new tweets from the user's timeline, and the unit tests would throw an assertion error as the retrieved tweet would already be retweeted and favourited. \newline \par

The unit test class utilises the Tweepy library by interacting with a timeline tweet and assessing if the action functionality has been performed through assertions. Unit test functions such as test\_tweet perform an action and retrieve data from the timeline and check the text with a unique message to determine if the action has been performed correctly. The test class also tests the scheduling functionality. The function performs an assertion that the latest tweet text is not equal to the scheduled tweet text, executes the scheduling task, executes a delay of 60 seconds and then asserts the latest tweet text is equal to the input action text. \newline \par

The third test class, BotScriptTest, tests the bot scripts. These tests are not in the standard unit test form as it is an intricate task to assess their functionality in a unit test. This is due to the amount of unpredictable factors which involve the interaction of other Twitter accounts. An example of this would be the follow\_followers\_bot. Without other accounts API access, it is impossible to perform a unit test as selected accounts cannot follow and unfollow to determine if the bot has successfully achieved its functionality. These tests require user interaction to determine if they are functioning as intended. This requires a user to manually follow the bot account and check if the bot automatically follows the account when the test class or unit test has run. This applies to the other two bot scripts, where user interaction with other accounts is required to ensure the bots are working as intended. \newline \par

The final test class, TwitterAccountCampaignUploadTest, tests the functionality of uploads and execution using the Django models. It uses `test\_utils' to create Django Model objects and uploads a domain specific language program to be executed. The test class evaluates the functionality of executing a domain specific language through the use of text files. The other test classes test through the use of input strings as parameters. The TwitterAccountCampaignUploadTest class tests the majority of the functionality demonstrated in the other three classes. The test class does not test the functionality of the action `tweetImage' as uploading and asserting images in a unit test is a complex task. This functionality has been tested externally to ensure it executes as intended. \newline \par

The unit tests determine that the system works as intended with a syntactically correct input. It explores all functionality with different inputs to ensure each component of the system works correctly and interacts with the Twitter API as intended. The unit tests determine that Functional Requirement 1, 2, 3, 4 are all successfully achieved, meeting all the mandatory functional requirements. \newline \par

The unit tests do not explore the edge cases or when a syntactically invalid user input is entered. The unit tests could be extended further to test this functionality, and understand what happens when a syntactically incorrect input is entered. This includes inputs which are correct for the lexical analysis stage, but do not grammatically make sense and inputs which do not adhere to the grammar. The domain specific language does not perform any error handling. This is because ANTLR handles all error handling for parsing. Error messages are displayed to the user if the input is incorrect and the program terminates, which is a difficult task to encapsulate in unit testing. The unit tests could enter syntactically invalid programs and test that the raised errors are the ones expected to be generated by ANTLR. Completing these additional tests would allow the unit tests to prove the system can be interacted fully as intended and safe for practical application. 



