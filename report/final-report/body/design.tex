\chapter{Design}
UML designs assist with the visualisation of the requirements analysis and it demonstrates the functionality and user interaction of the system. This was the first design decision to understand how the different components of the system will interact with eachother and how the user of the system will interact with the system. The UML designs include the full scope and wider scope of the projects aims and objectives. \\

The initial stage of design for the domain specific language was to write out all of the actions that the domain specific language should achieve based on the requirements analysis. This then developed by looking at the Twitter API actions and understating how the desired actions split into API method calls. The original design of the system was to include a RESTful web service to handle HTTP requests and interact with the Twitter API using JSON objects. The intuitive design approach for the domain specific language was to create a language with actions and a similar grammar structure to JSON objects. This then lead to the first grammar design of: (statement, action (comma parameter)*, action: identifier COLON value). \\

The outcome of the first grammar design lead to the first ideas around the design and implementation of how the interpreter would work. The initial idea was to have the interpreter generate JSON objects based on the different actions and take the JSON inspired parameter values to populate the JSON object key value pairs. \\

After the initial outcome of the first grammar design, decisions had to be made around the power and the limits of the domain specific language. The initial design of the grammar had very restricted functionality and power, it did not include any conditional statements, any types, and looping functionality or recursion. The initial grammar design was a lightweight language designed to populate JSON objects. \\

The next design decisions evaluated the trade-offs between utilising the machinery and back-end software against building a feature in the language. This decision was prevalent when having to deal with user authentication of tokens and keys to access the Twitter API as for each API call, a user had to be authenticated. An option to overcome this issue was to include a separate login statement, which included login parameters to take the different authentication keys and tokens. This option was not an ideal option as it makes the language clunky and repetitive. Another option to solve this problem would have been to define macros to retrieve user login details in a separate to abstract the authentication from the user in a simplified way. Due to the nature of the domain specific language, its aims and objectives and requirements, a design decision was made to keep the language simple and remove any complexity from the language. This design decision was made as the domain specific language aims and objectives is to be utilised by programmers and non programmers. As the domain specific language is designed to be operated and executed by a Django web application, the design decision was to implement the functionality of authentication and management of authentication keys and tokens to the web application. \\

After the design decisions to utilise Django and the Tweepy API, the final design of the domain specific language could be completed. The final grammar for the domain specific language is: . \\

After the designs of the language and interpreter were completed, the designs for the web application could be completed. The design for the web application was simple as it aligns with Djangos conventions. 
