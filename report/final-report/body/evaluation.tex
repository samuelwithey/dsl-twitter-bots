\chapter{Evaluation}

The evaluation of the system can be determined from a set of unit tests. The unit tests are split into three different classes which test different components and functionality of the system. The first class of unit tests, DSLTest, tests how the input is parsed and if the visitor/interpreter implementation successfully visits the child nodes to return the correct input data. DSLTest uses a different visitor class than the rest of the system, as this testing visitor class, DSLVisitorWalkerTest, returns the kwargs of the parsed input instead of executing application specific code. The kwargs are the result of the parsed input which is to be passed to the Tweepy API to perform the actions of the given input. This testing class validates the core functionality of the domain specific language, the parser and the interpreter by proving the output is as expected for a valid input. \newline \par

The second test class, DSLVisitorWalkerTests, tests the visitor and the visitors interaction with the Tweepy API. The test class tests all the core functionality and the different actions performed by the domain specific language. The unit tests directly interact with Twitter, making it difficult to control all the variables for unit testing. The tests can be run individually however running the test class is better suited as some test functions depend on other test functions. An example of this would be test\_retweet and test\_favourite as the unit tests would fail if ran twice with quick succession as it would be likely that there would be no new tweets from the system as the unit tests would be attempting to retweet and favourite the most recent tweet on the users timeline which will throw an assertion error. The unit tests all utilise the Tweepy API by interacting with a timeline tweet and assessing if the action functionality has been performed. Other unit tests such as test\_tweet perform an action and retrieve data from the timeline and check the text with a unique message to determine if the action has been performed correctly. \newline \par

The final test class, BotScriptTest, tests the bot scripts. These tests are not in standard unit test form as it is an intricate tasks to assess their functionality in a unit test. This is due to the amount of unpredicatble factors which involve the interaction of other Twitter accounts. An example of this would be the follow\_followers\_bot. Without more accounts API access, it is impossible to perform a unit test as selected accounts cannot follow and unfollow to determine if the bot has successfully achieved its functionality. These tests require user interaction to determine if they are functioning as intended. This requires a user to manually follow the bot account and check if the bot automatically follows the account when the test class or unit test has run. This applies to the other two bot accounts, where user interaction with other accounts is required to ensure the bots are working as intended. \newline \par

The unit tests determine that the system works as intended with a syntactically correct input. It explores all functionality with different inputs to ensure each component of the system works correctly and interacts with the Twitter API as intended. The unit tests determine that Functional Requirement 1, 3, 4, 5 are all successfully achieved, meeting all the mandatory functional requirements. \newline \par

The unit tests do not explore the edge cases or when a syntactically invalid user input is entered. The unit tests could be extended further to test this functionality, and understand what happens when a syntactically incorrect input is entered. This includes inputs which are correct for the lexical analysis stage, but do not grammatically make sense and inputs which do not adhere to the grammar. The domain specific language does not perform any error handling. This is because all error handling for the parsing is handled by ANTLR. Error messages are displayed to the user if the input is incorrect and the program terminates, which is a difficult task to encapsulate in unit testing. The unit tests could enter syntactically invalid programs and test that the raised errors are the ones expected to be generated by ANTLR. This would allow the unit tests to prove the system can be interacted fully as intended and safe for practical application. 

